Here is the pasted-in Linear issue for the current bug fix task:

https://linear.app/common-tools/issue/CT-762/ast-schema-transformer-fails-to-handle-intersection-types-with-cell
AST: schema transformer fails to handle intersection types with cell properties
The TypeScript schema transformer cannot properly handle intersection types that include Cell properties. When using intersection types like ListState & { index: number }, the transformer falls back to generating generic schemas with additionalProperties: true, losing critical type information about Cell fields.

When a handler uses an intersection type:

interface ListState {
  items: Cell<Item[]>;
}
const removeItem = handler<unknown, ListState & { index: number }>((_, { items, index }) => {
  items.get(); // Runtime error: items.get is not a function
});


The transformer generates:

handler({
  type: "object",
  additionalProperties: true
} as const satisfies JSONSchema, {
  type: "object",
  additionalProperties: true
} as const satisfies JSONSchema, ...)


This loses the Cell type information, causing runtime errors.

Metadata
URL: [https://linear.app/common-tools/issue/CT-762/ast-schema-transformer-fails-to-handle-intersection-types-with-cell](https://linear.app/common-tools/issue/CT-762/ast-schema-transformer-fails-to-handle-intersection-types-with-cell)
Identifier: CT-762
Status: On Deck
Priority: No priority
Assignee: Ellyse Cedeno
Created: 2025-08-08T20:00:33.092Z
Updated: 2025-08-18T13:21:25.723Z

You can look at packages/patterns/array-in-cell-with-remove-ast-nocomponents.tsx
 to see an example of code that wants to be written as an intersection type,
 but currently cannot be due to this bug/issue; instead it is written as an
 anonymous type with two parts to it, where the ListState type cannot be used
 and instead the anonymous type needs to be written with the underlying fields
 and their types that ListState is intended to abstract over.

As you should know from your general project review, the command
 `deno task ct dev --show-transformed array-in-cell-with-remove-ast-nocomponents.tsx`
 (with filepath modified appropriately based on cwd) will output the
 transformed Typescript for the currently written version of the pattern,
 which uses the explicit anonymous type instead of the desired intersection
 type.

If you run `deno task test` from packages/js-runtime, you'll see the output
 from the current automated test suite. We should approach this task in TDD
 fashion; you should begin by creating a pair of new fixtures in the style of
 the other existing passing tests, one with an as-simple-as-possible
 reproduction of the current working recipe as input and with an appropriately
 updated version of the transformed output as expected. Once we have that
 working/passing successfully, we can then change the input recipe to use
 the intersection type, at which point we should observe that the test begins
 failing instead of passing.

This is all the preamble to being able to effectively work on the task/bug, so
 you should definitely stop once you get to this point and confirm with me that
 we are here and everything has gone as expected up to this point. As always,
 please stop and ask me any questions you have as you go if you are confused
 or get stuck before this point.

Once we're here, it'll be time to investigate and fix the bug. You can begin
 doing this by using the --show-transformed deno task on the test fixture
 recipe you've created in the previous stage to see what the output looks like
 currently from intersection types; it should resemble approximately the
 incorrect output given in the Linear task above. We can then explore the parts
 of the codebase responsible for actually performing the transformations in
 question and investigate which ones of them are at issue here. This part of
 working on the task should be highly interactive.
 
**I AM TRYING TO LEARN AS MUCH AS POSSIBLE ABOUT THIS CODEBASE AS WE GO,
 BECAUSE IT IS CURRENTLY NEW TO ME, SO PLEASE TALK ME THROUGH WHAT YOU DISCOVER
 AND CONCLUDE DURING THIS ACTUAL IMPLEMENTATION PORTION IN GREAT DETAIL!**

---

Implementation Plan for CT-762 (Intersection types with Cell in schema transformer)

Current state of relevant code
- Handler type arguments are rewritten to explicit schema calls in `packages/js-runtime/typescript/transformer/opaque-ref.ts`:
  - `handler<E, S>(fn)` → `handler(toSchema<E>(), toSchema<S>(), fn)`
  - `recipe<T>(...)` similarly prepends `toSchema<T>()` schemas when types are provided.
- `packages/js-runtime/typescript/transformer/schema.ts` transforms `toSchema<T>()` calls by invoking `typeToJsonSchema(type, checker, typeNode)` from `schema-generator.ts` and replacing the call with a JSON Schema literal (`as const satisfies JSONSchema`).
- `packages/js-runtime/typescript/transformer/schema-generator.ts` implements `typeToJsonSchemaHelper`, which handles:
  - Known wrappers: `Default<T,V>`, `Cell<T>`, `Stream<T>` (propagates defaults and adds `asCell`/`asStream`).
  - Arrays (both `T[]` and `Array<T>`), primitives, Date, objects (via `buildObjectSchema`), and unions.
  - Depth/cycle handling with `$ref`/`definitions` when needed.
- Notably missing: explicit handling of intersection types (`A & B`).

Why this leads to the observed failure
- Our failing case is a handler state like `ListState & { index: number }` where `ListState` includes `items: Cell<Item[]>`.
- In `typeToJsonSchemaHelper`, intersections are not handled explicitly. They are neither unions nor plain objects; the code path for `type.flags & ts.TypeFlags.Object` does not run for intersection types.
- As a result, the helper falls through to the final fallback: `{ type: "object", additionalProperties: true }`.
- That collapses the state schema, losing both the `items` property and its `Cell` metadata (`asCell: true`), which explains the runtime mismatch and the failing intersection fixture.

Planned changes/additions
- Add explicit handling for intersection types in `typeToJsonSchemaHelper` before the object/union/fallback branches:
  - Detect with `type.flags & ts.TypeFlags.Intersection` (treat as `ts.IntersectionType`).
  - Build the schema using the existing `buildObjectSchema(...)` helper on the intersection type itself. The TypeScript checker’s `getPropertiesOfType` returns the merged property set for intersections, so `buildObjectSchema` will:
    - Traverse all merged properties,
    - Recurse through `typeToJsonSchemaHelper` for each property type (preserving `Cell`/`Stream` handling),
    - Compute `required` from symbol optional flags.
  - Return that merged object schema. This preserves the style of existing outputs (inline object with `properties` and `required`) rather than introducing a JSON Schema `allOf`.

Pseudocode (conceptual)
  if (type.flags & ts.TypeFlags.Intersection) {
    return buildObjectSchema(
      type,
      checker,
      typeNode,
      depth,
      newSeenTypes,
      cyclicTypes,
      definitions,
      definitionStack,
      inProgressNames,
      emittedRefs,
    );
  }

Testing strategy
- Keep both fixture pairs:
  - Anonymous type (passing): `{ items: Cell<Item[]>; index: number }` → should remain green and still match the pattern’s `--show-transformed` output.
  - Intersection type (currently failing): `ListState & { index: number }` → should start passing with the same state schema as the anonymous case (merged `properties`, `required`, `asCell` preserved).
- Run the full `packages/js-runtime` test suite to guard against regressions.

Risks and mitigations
- Intersections with non-object constituents: `buildObjectSchema` derives properties from `checker.getPropertiesOfType`, which for intersections exposes the combined object surface; this aligns with how we want to represent handler state.
- Potential cycles/definitions: we reuse the existing cycle/definition machinery; no special handling needed.
- JSON Schema semantics (`allOf` vs merge): we choose property merging to remain consistent with existing transformer output and consumers.

If this plan looks good, the next step is to implement the intersection handling in `schema-generator.ts`, re-run tests, and review the diff in detail together.

Update: Guarded handling and legible fallback
- We will only merge intersections when all constituents are clearly object-like and safe:
  - All parts must be object types (`t.flags & ts.TypeFlags.Object`).
  - No index signatures present (string/number index via `checker.getIndexTypeOfType`).
  - No call/construct signatures on any constituent.
- If any check fails, we will not attempt to merge. Instead we will:
  - Return `{ type: "object", additionalProperties: true, $comment: "Unsupported intersection pattern: <reason>" }`.
  - Emit a `logger.warn` with the same short reason and type summary.
- When merging is allowed, we reuse `buildObjectSchema` on the intersection type itself so properties are gathered from the checker’s merged view and nested `Cell`/`Stream` are preserved by existing logic.
- We will not implement a strict mode now; this can be a future extension if desired.