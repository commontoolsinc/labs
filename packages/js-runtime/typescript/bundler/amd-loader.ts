// This function is a minimal AMD implementation that gets
// stringified via `.toString()` (and "minified", stripping new lines)
// in order to load the bundle generated by the TypeScript compiler.
export function getAMDLoader() {
  interface ModuleDefinition {
    dependencies: string[];
    factory: (...deps: any[]) => any;
    exports?: any;
    resolved?: boolean;
  }

  class AMDLoader {
    private modules = new Map<string, ModuleDefinition>();
    private loading = new Set<string>();

    define(
      id: string,
      dependencies: string[],
      factory: (...deps: any[]) => any,
    ): void;
    define(dependencies: string[], factory: (...deps: any[]) => any): void;
    define(factory: () => any): void;
    define(
      idOrDepsOrFactory: string | string[] | (() => any),
      depsOrFactory?: string[] | ((...deps: any[]) => any),
      factory?: (...deps: any[]) => any,
    ): void {
      let id: string;
      let dependencies: string[];
      let moduleFactory: (...deps: any[]) => any;

      if (typeof idOrDepsOrFactory === "string") {
        id = idOrDepsOrFactory;
        dependencies = depsOrFactory as string[];
        moduleFactory = factory!;
      } else if (Array.isArray(idOrDepsOrFactory)) {
        id = this.generateAnonymousId();
        dependencies = idOrDepsOrFactory;
        moduleFactory = depsOrFactory as (...deps: any[]) => any;
      } else {
        id = this.generateAnonymousId();
        dependencies = [];
        moduleFactory = idOrDepsOrFactory;
      }

      this.modules.set(id, {
        dependencies,
        factory: moduleFactory,
        resolved: false,
      });
    }

    require(
      dependencies: string[],
      callback: (...modules: any[]) => void,
    ): void;
    require(id: string): any;
    require(
      depsOrId: string[] | string,
      callback?: (...modules: any[]) => void,
    ): any {
      if (typeof depsOrId === "string") {
        return this.resolveModule(depsOrId);
      } else {
        const resolvedModules = depsOrId.map((dep) => this.resolveModule(dep));
        callback?.(...resolvedModules);
      }
    }

    private resolveModule(id: string): any {
      const module = this.modules.get(id);
      if (!module) {
        throw new Error(`Module '${id}' not found`);
      }

      if (module.resolved) {
        return module.exports;
      }

      if (this.loading.has(id)) {
        throw new Error(`Circular dependency detected: ${id}`);
      }

      this.loading.add(id);

      try {
        const resolvedDeps = module.dependencies.map((dep) => {
          if (dep === "require") return this.require.bind(this);
          if (dep === "exports") return {};
          if (dep === "module") return { exports: {} };
          return this.resolveModule(dep);
        });

        const result = module.factory(...resolvedDeps);

        if (result !== undefined) {
          module.exports = result;
        } else if (
          resolvedDeps.length > 0 && typeof resolvedDeps[1] === "object"
        ) {
          module.exports = resolvedDeps[1];
        }

        module.resolved = true;
        return module.exports;
      } finally {
        this.loading.delete(id);
      }
    }

    private generateAnonymousId(): string {
      return `__anonymous_${Date.now()}_${
        Math.random().toString(36).substr(2, 9)
      }`;
    }
  }

  const loader = new AMDLoader();
  return {
    define: loader.define.bind(loader),
    require: loader.require.bind(loader),
  };
}
