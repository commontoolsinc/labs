# Helper Detection (Symbol-Based) Design

## Problem Statement

`dataflow.ts` previously special-cased certain call expressions by matching
identifier text:

- `BUILDER_FUNCTIONS` (recipe, lift, handler, derive, compute, render, ifElse,
  str) are detected by calling `getFunctionName` and comparing strings.
- Array `map` is recognised when the identifier is literally "map".

That approach only worked when the helper was imported under its canonical name
and called directly. It failed in several scenarios:

- Import aliasing (`import { recipe as build }`).
- Namespace-qualified calls (`commontools.recipe`).
- Re-exports or future helpers (e.g. adding `lift` support) where the helper
  might live in a different module than expected.

To deliver on the "foundation for closures" requirement, call classification
needs to be resilient and tied to the actual runtime symbol, not the identifier
text.

## Proposed Approach

1. When analysing a `CallExpression`, resolve the signature using the type
   checker:
   `const signature = checker.getResolvedSignature(expression);`
2. Inspect `signature.declaration` (or the symbol at `expression.expression`) to
   determine the module that defines the helper. Specifically, retrieve the
   source file path, e.g. `declaration.getSourceFile().fileName`.
3. Maintain a minimal table mapping known helper modules (or symbols) to call
   kinds. Example:

   ```ts
   const CALL_KIND_TABLE = new Map<string, CallKind>([
     ["@commontools/runtime/derive.ts", CallKind.Derive],
     ["@commontools/runtime/if_else.ts", CallKind.IfElse],
     ["@commontools/runtime/lift.ts", CallKind.Lift],
     ["@commontools/runtime/handler.ts", CallKind.Handler],
   ]);
   ```

   (Exact module identifiers determined by the runtime package exports.)

4. Record the detected `CallKind` in the analysis result (e.g. extend
   `RewriteHint` or attach metadata to `DependencyNode`).
5. Emitters branch on the `CallKind` enum instead of string sets. This ensures:
   - Aliasing and dot-qualified names resolve correctly (the symbol still comes
     from the same source module).
   - Adding new helpers (e.g. lift) only requires updating the table with the
     new module path.

## Benefits

- **Resilience to aliasing:** detection works regardless of identifier text or
  namespace qualification.
- **Extensibility:** adding support for new runtime helpers involves updating a
  single mapping.
- **Clarity:** emitters can check `CallKind` values, making the logic more
  self-documenting than string comparisons.

## Implementation Notes

- Use `checker.getSymbolAtLocation(expression.expression)` if the signature
  resolution lacks a declaration; the symbol's declarations give access to the
  source file.
- Normalise module paths (e.g. `path.posix.normalize`) to avoid platform
  discrepancies in the lookup table.
- Store the detected kind on `OpaqueExpressionAnalysis` (e.g. `rewriteHint` or a
  new field). Emitters can base their decisions on that metadata.
- Keep the matching set intentionally smallâ€”only helpers we ship in the runtime
  package need to be considered.

The implementation now lives in `src/opaque-ref/call-kind.ts` as
`detectCallKind`, which resolves aliases, inspects method declarations (including
`OpaqueRef.map`), and feeds the result back into both the dependency analyser
and the schema-injection rule.
