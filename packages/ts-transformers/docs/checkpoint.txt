Schema transformer has been migrated into @commontools/ts-transformers (exports from src/schema/schema-transformer.ts). @commontools/js-runtime now imports it from the new package; the old schema.ts file has been deleted.

We have copied the shared OpaqueRef utilities into @commontools/ts-transformers:
- src/opaque-ref/types.ts (isOpaqueRefType, containsOpaqueRef, collectOpaqueRefs, etc.).
- src/opaque-ref/transforms.ts (createIfElseCall, transformExpressionWithOpaqueRef, etc.).

The legacy OpaqueRef transformer is still supplied via src/legacy.ts, re-exporting the existing js-runtime implementation. Next steps are:
1. Start modularizing OpaqueRef by introducing a new transformer wrapper that uses the shared context and delegates to modular rules.
2. Peel off rule by rule (JSX expression handling first) into the new structure while keeping fixtures green.
3. Eventually remove the legacy monolithic transformer once all behaviors are migrated.

Tests currently pass in all packages:
- packages/ts-transformers: deno task check/test
- packages/js-runtime: deno task test
- packages/schema-generator: deno task test

No other changes pending.

---

OpaqueRef modular rewrite progress:
- Introduced the modular transformer wrapper and schema injection rule; JSX rule now runs inside the new pipeline.
- Added a dependency analyzer to reason about opaque refs structurally instead of relying on ad-hoc heuristics.
- Initial attempts to adapt the legacy rewrite helper (`transformExpressionWithOpaqueRef`) showed that mixing the old `collectOpaqueRefs` logic with the new analyzer yields incorrect outputs (duplicate state objects, mis-scoped locals).

Current conclusion:
- Replace the legacy helper with a fresh pipeline: dependency analysis + scope-aware normalization + focused emitters (binary/call/template/etc.).
- Keep schema injection separate, but feed the analyzer through the new emitters so future features (e.g. closures) can share the same analysis layer.
- Write unit coverage for the emitters before re-running fixtures to ensure the new architecture matches legacy behaviour without reverting to heuristic spaghetti.

This refactor is in progress; tests currently fail on JSX fixtures until the new pipeline lands.

---

OpaqueRef modular rewrite checkpoint
- Added the scope-aware dependency graph (node ids + scope ids) and a normaliser that groups occurrences, drops ancestor refs, and produces deterministic binding descriptors.
- Introduced the new rewrite pipeline (bindings/helpers + emitters for property access, binary, call, template, conditional, and element access) and wired it into the JSX rule ahead of the legacy helper.
- Parameter naming now matches legacy output: identifiers retain their names while generated bindings stay `_v#`; event-handler call sites are skipped to avoid unnecessary derives.
- Updated `isOpaqueRefType` to ignore callable types so helper methods (e.g. `state.items.map`) are not treated as opaque dependencies.

Current state
- `deno task check` passes; `deno task test` in ts-transformers still fails on five JSX fixtures: `jsx-complex-mixed`, `jsx-conditional-rendering`, `jsx-function-calls`, `jsx-property-access`, and `recipe-statements-vs-jsx`.
- Failures show two classes of gaps:
  1. Pure boolean/predicate expressions (e.g. `state.count > 10`) are being wrapped in the wrong location; legacy output derives the predicate while leaving the surrounding `ifElse` call intact.
  2. Builder-style methods such as `state.items.map(...)` currently cause the entire call to be wrapped in `derive`; legacy behaviour derives only the result of the callback and keeps the method invocation unchanged.
- Legacy `transformExpressionWithOpaqueRef` remains as fallback; we only fall back when the new pipeline returns `undefined`.

Next steps
1. Extend analyzer/normaliser metadata to flag predicates and builder method calls so emitters can rewrite the relevant operand rather than the entire call.
2. Update call/binary emitters accordingly: derive only the predicate/value (e.g. the first argument to `ifElse`, the result of a `.map` callback) while leaving the surrounding call intact.
3. Add focused unit tests for analyzer, normaliser, and the new emitters covering the failing fixture patterns before retrying the fixture suite.
4. Once fixtures are green, remove the fallback to the legacy helper and delete the dead code.

Outstanding work from the overall plan
- Implement emitter-level heuristics based on analyzer metadata (above) and ensure future closures support is enabled by keeping scope info intact.
- Add analyzer/normaliser test coverage (per rewrite_design plan) and extend docs once the pipeline is stable.

---

Latest checkpoint (post-fallback removal)
- Removed the legacy `transformExpressionWithOpaqueRef` fallback path so the
  modular pipeline now runs unconditionally for JSX expressions.
- Augmented the dependency analyser to flag expressions that originate from
  root recipe/handler parameters (e.g. `state.items[index]`) so that array
  element access can be rewritten without relying on type information.
- After these changes the fixture suite regressed: with the fallback gone we
  now under-detect opaque references inside method chains (e.g.
  `state.items.filter`, `state.name.toUpperCase`) because the type checker
  reports those identifiers as `any` in the harness. As a result multiple JSX
  fixtures (`jsx-complex-mixed`, `jsx-function-calls`, `jsx-property-access`,
  `jsx-string-operations`) currently differ from expectations.

Next steps
- Teach the analyser to conservatively treat property/element accesses whose
  root identifier is a known opaque parameter as opaque even when the checker
  returns `any`, or update the testing harness to provide the `OpaqueRef`
  declaration so that TypeScript can detect the intersection type.
- Revisit the emitter logic once the analyser correctly reports dependencies
  so that method calls and chained expressions derive over the enclosing
  object instead of the method symbols.
