Schema transformer has been migrated into @commontools/ts-transformers (exports from src/schema/schema-transformer.ts). @commontools/js-runtime now imports it from the new package; the old schema.ts file has been deleted.

We have copied the shared OpaqueRef utilities into @commontools/ts-transformers:
- src/opaque-ref/types.ts (isOpaqueRefType, containsOpaqueRef, collectOpaqueRefs, etc.).
- src/opaque-ref/transforms.ts (createIfElseCall, transformExpressionWithOpaqueRef, etc.).

The legacy OpaqueRef transformer is still supplied via src/legacy.ts, re-exporting the existing js-runtime implementation. Next steps are:
1. Start modularizing OpaqueRef by introducing a new transformer wrapper that uses the shared context and delegates to modular rules.
2. Peel off rule by rule (JSX expression handling first) into the new structure while keeping fixtures green.
3. Eventually remove the legacy monolithic transformer once all behaviors are migrated.

Tests currently pass in all packages:
- packages/ts-transformers: deno task check/test
- packages/js-runtime: deno task test
- packages/schema-generator: deno task test

No other changes pending.

---

OpaqueRef modular rewrite progress:
- Introduced the modular transformer wrapper and schema injection rule; JSX rule now runs inside the new pipeline.
- Added a dependency analyzer to reason about opaque refs structurally instead of relying on ad-hoc heuristics.
- Initial attempts to adapt the legacy rewrite helper (`transformExpressionWithOpaqueRef`) showed that mixing the old `collectOpaqueRefs` logic with the new analyzer yields incorrect outputs (duplicate state objects, mis-scoped locals).

Current conclusion:
- Replace the legacy helper with a fresh pipeline: dependency analysis + scope-aware normalization + focused emitters (binary/call/template/etc.).
- Keep schema injection separate, but feed the analyzer through the new emitters so future features (e.g. closures) can share the same analysis layer.
- Write unit coverage for the emitters before re-running fixtures to ensure the new architecture matches legacy behaviour without reverting to heuristic spaghetti.

This refactor is in progress; tests currently fail on JSX fixtures until the new pipeline lands.

---

OpaqueRef modular rewrite checkpoint
- Added the scope-aware dependency graph (node ids + scope ids) and a normaliser that groups occurrences, drops ancestor refs, and produces deterministic binding descriptors.
- Introduced the new rewrite pipeline (bindings/helpers + emitters for property access, binary, call, template, conditional, and element access) and wired it into the JSX rule ahead of the legacy helper.
- Parameter naming now matches legacy output: identifiers retain their names while generated bindings stay `_v#`; event-handler call sites are skipped to avoid unnecessary derives.
- Updated `isOpaqueRefType` to ignore callable types so helper methods (e.g. `state.items.map`) are not treated as opaque dependencies.

Current state
- `deno task check` passes; `deno task test` in ts-transformers still fails on five JSX fixtures: `jsx-complex-mixed`, `jsx-conditional-rendering`, `jsx-function-calls`, `jsx-property-access`, and `recipe-statements-vs-jsx`.
- Failures show two classes of gaps:
  1. Pure boolean/predicate expressions (e.g. `state.count > 10`) are being wrapped in the wrong location; legacy output derives the predicate while leaving the surrounding `ifElse` call intact.
  2. Builder-style methods such as `state.items.map(...)` currently cause the entire call to be wrapped in `derive`; legacy behaviour derives only the result of the callback and keeps the method invocation unchanged.
- Legacy `transformExpressionWithOpaqueRef` remains as fallback; we only fall back when the new pipeline returns `undefined`.

Next steps
1. Extend analyzer/normaliser metadata to flag predicates and builder method calls so emitters can rewrite the relevant operand rather than the entire call.
2. Update call/binary emitters accordingly: derive only the predicate/value (e.g. the first argument to `ifElse`, the result of a `.map` callback) while leaving the surrounding call intact.
3. Add focused unit tests for analyzer, normaliser, and the new emitters covering the failing fixture patterns before retrying the fixture suite.
4. Once fixtures are green, remove the fallback to the legacy helper and delete the dead code.

Outstanding work from the overall plan
- Implement emitter-level heuristics based on analyzer metadata (above) and ensure future closures support is enabled by keeping scope info intact.
- Add analyzer/normaliser test coverage (per rewrite_design plan) and extend docs once the pipeline is stable.
