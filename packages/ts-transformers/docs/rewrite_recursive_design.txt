# Nested Rewrite Design Notes

## Problem Statement

The current `rewriteExpression` implementation dispatches to a set of emitters
(based on node kind) and, if none of them handle the top-level expression,
performs a second traversal that re-enters `rewriteExpression` on child nodes
(lines 25-72 of `rewrite/rewrite.ts`). This fallback ensures that nested
expressions (e.g. a `PropertyAssignment` inside an object literal) are rewritten
when no top-level emitter matched. While effective, the approach masks a design
issue:

- Emitters that succeed do not visit their children. Their responsibility ends
  with producing a replacement node for the expression they recognise.
- Container expressions (object/array literals, parenthesised expressions,
  type assertions, etc.) rely on the fallback traversal to rewrite inner nodes.
- The fallback re-runs dependency analysis and recursively re-enters the full
  dispatcher, which adds complexity and makes it harder to reason about
  per-node responsibilities.

The schema-generator pipeline avoids this pattern: formatters rewrite their own
node and explicitly recurse into child nodes via the same formatting interface.
This design is easier to extend, avoids extra analysis work, and clarifies
ownership for nested structures.

## Proposed Refactor

Introduce an explicit "rewrite children" step that emitters call before (or
while) building their replacement node. Key ideas:

1. Provide a helper `rewriteChildren(node, context)` that walks the node's
   immediate children, runs `context.analyze` on expression children, and
   dispatches to `rewriteExpression` for each expression that still requires a
   rewrite.
2. Each emitter becomes responsible for invoking `rewriteChildren` before it
   constructs the new node. For example, `emitPropertyAccess` would rewrite the
   child `expression` first, then create the new derive call using the rewritten
   child as input.
3. For node kinds we do not rewrite (e.g. `ObjectLiteralExpression`), add a
   simple emitter that leaves the node shape intact but rewrites its children by
   calling `rewriteChildren`.
4. With every emitter owning its subtree, the fallback recursion at the bottom
   of `rewriteExpression` is no longer needed and can be removed.

## Benefits

- **Single ownership:** each emitter emits a node and ensures its children are
  rewritten. No implicit second pass.
- **Performance:** avoids redundant analysis when the first dispatch already
  knows which children need rewriting.
- **Extensibility:** adding support for new expression kinds (especially when
  closures introduce nested functions) becomes a matter of adding an emitter and
  calling `rewriteChildren`, mirroring the schema generator design.

## Implementation Notes

- Reuse `ts.visitEachChild` with a visitor that invokes `context.analyze` on
  expression children and recurses into `rewriteExpression` as needed.
- Update existing emitters (binary, call, template, conditional, element,
  property) to rewrite child nodes explicitly.
- Introduce emitters for container nodes we currently leave untouched (object
  literal, array literal, parenthesised expression, type assertions, etc.).
- Remove the fallback traversal in `rewriteExpression` once emitters handle
  child rewrites directly.
- Ensure helper tracking (`Set<OpaqueRefHelperName>`) merges child helpers
  correctly when emitters rewrite nested expressions.

