# Nested Rewrite Status

## Current Implementation

`rewriteExpression` now delegates child rewriting to emitters rather than
falling back to a second traversal. The dispatcher (see
`src/opaque-ref/rewrite/rewrite.ts`) wraps the transformation context with a
`rewriteChildren` helper. Emitters call this helper to rewrite their inputs
before building a replacement node, while `emitContainerExpression` handles
pass-through nodes such as object and array literals.

Key points:

- Emitters own their subtrees: every operator, call, template, conditional,
  element access, and container emitter invokes `context.rewriteChildren` as
  needed and merges any helper imports returned by the recursive calls.
- The historical fallback (re-running analysis and redispatching when no
  emitter matched) has been deleted. Each emitter either rewrites its node or
  yields `undefined`, and containers ensure descendants are visited exactly once.
- Helper tracking merges child helpers into the parent result via the shared
  `Set<OpaqueRefHelperName>` maintained inside `rewriteExpression`.

## Benefits

- **Single ownership:** the transformer no longer depends on an implicit second
  pass, making per-node responsibilities clearer.
- **Lower overhead:** analysis happens once per expression tree, eliminating the
  redundant work triggered by the former fallback traversal.
- **Extensibility:** adding new emitters or supporting closures now means
  composing with `rewriteChildren`, mirroring the schema-generator architecture
  that originally inspired this change.

## Follow-up Considerations

- Container coverage is intentionally minimal; when we add new expression kinds
  we should provide emitters that either rewrite them directly or defer to
  `rewriteChildren`.
- The helper still walks the entire subtree when any child requires a rewrite.
  If performance becomes a concern we can allow emitters to shortcut specific
  child paths, but that is not necessary today.
