Context & Goals

  - Initial snapshot: the branch began by copying the legacy helper (`transformExpressionWithOpaqueRef`) into @commontools/ts-transformers and layering new rules (schema
  injection, JSX) around it. That version relied on the legacy collector logic and inherited its inaccuracies.
  - Objective: replace the monolithic helper with a maintainable architecture that (a) reaches functional parity with the old transformer, (b) cleanly separates concerns,
  and (c) sets a foundation for closures/other future features. ✅ The branch now delivers this modular pipeline and no longer falls back to the legacy helper.

  Core Principles

  - Single source of truth for dependency info; no recomputing or ad-hoc heuristics.
  - Scope-aware analysis that treats lambda parameters/local bindings as distinct from recipe state.
  - Emitters specialized by expression shape; analysis and emission independent.
  - Deterministic ordering and naming to keep diffs stable.

  Proposed Architecture

  1. Analyzer Layer (dependency.ts)
      - Entry: createDependencyAnalyzer(typeChecker) returning an analyzer object with methods like analyzeExpression(expr) and analyzeFunction(fn) plus access to scope
  stack.
      - Output: OpaqueExpressionAnalysis enriched with:
          - containsOpaqueRef
          - requiresRewrite
          - dependencies: array of DependencyNode (wrapping the literal ts.Expression, unique id, parent ref). This replaces raw ts.Expression[].
          - scopes: metadata capturing ignored symbols and closure boundaries.
      - Implementation notes:
          - Maintain explicit scope stack; when encountering function/loop, push parameter symbols; pop on exit.
          - When property access contains an opaque ref, record the full expression and mark parent chain so we can collapse later.
          - Preserve duplicates by giving every occurrence a distinct id; duplicates linked via canonicalKey (text + position).
  2. Normalizer Layer (normalise.ts or similar)
      - Entry: normaliseDependencies(analysis, sourceFile).
      - Responsibilities:
          - Reduce DependencyNode graph to a NormalisedDependencySet.
              - map from canonicalKey → NormalisedDependency with fields { rootExpression, occurrences[], scopeId }.
          - Collapse child dependencies whose parent is already present (e.g., state.price.length → keep state.price).
          - Deduplicate occurrences by text while keeping count to derive stable ordering; explicit list ensures we can reattach when needed for matching positions.
      - Also prepare binding descriptors: for each canonical key produce binding name, destructuring key, parameter identifier. We can choose names deterministically:
          - For identifiers: reuse name.
          - For property accesses: convert to snake-ish state_price.
          - For collisions: append suffix _1, _2.
      - Normalizer should be purely data transformation (no TS factory usage). This makes it unit-testable.
  3. Emitter Layer (emit/*.ts)
      - Split into small modules per expression family:
          - emitCallExpression, emitPropertyAccess, emitBinary, emitTemplate, emitConditional, etc.
      - Shared helper: emitDeriveCall(dependencies, bodyFactory) that accepts NormalisedDependencySet and returns:
          - helper spec { helper: "derive", importRequest }.
          - expression node created via provided ts.NodeFactory.
      - Emitters receive context { factory, checker, sourceFile, analyzer } plus the NormalisedDependencySet.
      - Each emitter decides rewrite strategy:
          - Single dependency → derive(dep, value => ...).
          - Multiple dependencies → derive({ depA, depB }, ({ depA, depB }) => ...).
          - Calls to builder functions (recipe/lift/etc.) considered safe: allow analyzer to mark requiresRewrite = false even if dependencies exist.
          - Conditionals: generate ifElse call if the condition or branches depend on opaque refs.
      - Emitters never reach back into analyzer; they rely only on normalized data + original node.
  4. Rule Integration (rules/jsx-expression.ts etc.)
      - Update JSX rule to:
          - Call analyzer once for each expression.
          - If analysis.requiresRewrite, pass both analysis and normalisedDependencies into the new `rewriteExpression` function (which now fully replaces the legacy
  helper). The function dispatches by node kind and returns { expression, helpers }.
      - Schema rule unaffected (remains orthogonal). Later we can share analyzer for type-argument handling if needed.
  5. Helper & Import Management
      - Centralize helper registrations: emitters return a set of required helpers so rules can request imports (derive, ifElse, future helpers).
      - Plan for closures: analyzer data should already expose scope structure; emitters can later handle closure emission by referencing this scope metadata.

  Testing Strategy

  1. Unit Tests
      - Analyzer tests (dependency.test.ts):
          - Confirm proper detection of opaque refs vs ignored parameters.
          - Validate property access vs identifier handling.
      - Normalizer tests (normalise.test.ts):
          - Verify duplicate collapsing, naming collisions, parent-child elimination.
      - Emitter tests per module (use synthetic ASTs to ensure expected TS code output). Snapshot tests acceptable for emitter output.
  2. Fixture Tests
      - Once unit coverage is green, re-run existing fixture suites in ts-transformers and the legacy js-runtime harness to confirm parity.
      - Add new fixtures covering trickier cases discovered during refactor (e.g., nested array maps, nested ternaries).
  3. Integration Tests
      - Keep createModularOpaqueRefTransformer fixture suites running; ensure tests still pass once new pipeline wired.

  Migration Plan

  1. Introduce analyzer/normalizer data structures alongside existing functions (no rewiring yet).
  2. Write unit tests for analyzer + normalizer, ensure they pass against varied expressions (pull examples from existing fixtures).
  3. Build new emitter modules and unit tests.
  4. Implement new rewriteExpression entry point (replacing transformExpressionWithOpaqueRef).
  5. Update JSX rule (and any other rules) to use new entry point with analyzer + normaliser.
  6. Run fixtures; fix discrepancies by adjusting normaliser/emitter rather than adding heuristics.
  7. Once parity confirmed, delete legacy helper / dead exports; update module exports to reflect new public API.
  8. Document architecture in ts-transformers/docs/ (possibly opaque-ref-architecture.md) for future contributors.

  Open Questions / Decisions Needed

  - Naming scheme for object destructuring keys: current approach uses dot-to-underscore; confirm this matches legacy output and coding standards.
  - Where to place normaliser module (src/opaque-ref/normalise.ts vs nested folder).
  - Should analyzer expose incremental APIs (e.g., for re-analysing subtrees) to support future rules? Default assumption: full expression analysis per call is fine.
  - How to represent helper requirements across modular rules (simple Set of helper names is likely enough, but confirm import manager usage).
  - Handling of builder functions: confirm list (recipe, lift, derive, handler, compute, render, ifElse, str) is accurate and whether more should be included.

---

Status Update
- Analyzer + normaliser implemented per design: dependency nodes track scope and parent ids, and the normaliser produces canonical dependency groups for the emitters.
- Emitters in place for property access, binary expressions, call expressions, template literals, conditional expressions, and element access. The JSX rule now invokes these emitters first and falls back to the legacy helper only when no emitter handles the expression.
- Parameter naming and event-handler call handling are aligned with legacy output; callable types are excluded from opaque-ref detection to avoid rewriting helper methods directly.
- Remaining discrepancies are in the call/binary emitters: we still wrap builder calls (e.g., `state.items.map(...)`) and pure predicate expressions; the legacy transformer derives only the callback result or the conditional predicate while leaving the surrounding call intact. The JSX fixture suite remains red because of this over-eager rewriting.

Focused Next Steps
1. Extend analyzer output to classify predicate-only expressions and builder method calls so emitters can make context-aware decisions.
2. Update call/conditional emitters to derive only the predicate/value (e.g., the first argument to `ifElse`, the result of a `.map` callback) while leaving the enclosing call unchanged and skipping pure boolean comparisons.
3. Add unit coverage for analyzer/normaliser edge cases and the new emitters before re-running the full fixture suite.
4. Once fixtures match legacy output, remove the legacy fallback (`transformExpressionWithOpaqueRef`) and update the documentation with the final architecture notes.

---

Post-fallback progress snapshot
- Dropped the JSX-rule fallback to `transformExpressionWithOpaqueRef`; the
  modular rewrite pipeline now runs by itself. This surfaced several analyzer
  blind spots that were previously masked.
- Added utilities in the analyzer to chase property/element roots and detect
  when they originate from recipe/handler parameters (e.g. the `state` binding)
  so array element access can be marked as a dependency even when the checker
  reports `any`.
- With the fallback removed, additional regressions are now visible: method
  calls such as `state.name.toUpperCase()` and chained expressions like
  `state.items.filter(...).length` are being rewritten against the method
  symbols instead of deriving the receiver because the analyzer still records
  `state.name.toUpperCase` rather than the `state.name` root.

Updated action items
- Improve the analyzer to attribute dependencies to the receiver/root
  identifier for property/method/element chains when that root resolves to a
  known opaque parameter, even if TypeScript reports the type as `any`.
- Once analysis is fixed, update emitters so method calls derive the receiver
  and invoke the method inside the lambda, restoring the readable derive
  patterns used in the legacy implementation.
- Re-run the JSX fixtures and update the expectations only after the new
  pipeline reproduces the intended output for the outstanding cases
  (`jsx-complex-mixed`, `jsx-function-calls`, `jsx-property-access`,
  `jsx-string-operations`).
