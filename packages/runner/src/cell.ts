import { isObject, isRecord } from "@commontools/utils/types";
import { type MemorySpace } from "@commontools/memory/interface";
import { getTopFrame } from "./builder/recipe.ts";
import {
  type Cell,
  ID,
  ID_FIELD,
  isStreamValue,
  type JSONSchema,
  type Schema,
} from "./builder/types.ts";
import { type DeepKeyLookup, type DocImpl } from "./doc.ts";
import { getEntityId } from "./doc-map.ts";
import {
  createQueryResultProxy,
  type QueryResult,
} from "./query-result-proxy.ts";
import { diffAndUpdate } from "./data-updating.ts";
import {
  resolveLinkToValue,
  resolveLinkToWriteRedirect,
} from "./link-resolution.ts";
import type { ReactivityLog } from "./scheduler.ts";
import { type EntityId } from "./doc-map.ts";
import { type Cancel, isCancel, useCancelGroup } from "./cancel.ts";
import { validateAndTransform } from "./schema.ts";
import { toURI } from "./uri-utils.ts";
import {
  type JSONCellLink,
  type LegacyDocCellLink,
  LINK_V1_TAG,
  type SigilLink,
  type SigilWriteRedirectLink,
  type URI,
} from "./sigil-types.ts";
import { areLinksSame, isLink } from "./link-utils.ts";
import { type IRuntime } from "./runtime.ts";
import {
  type NormalizedFullLink,
  parseNormalizedFullLinktoLegacyDocCellLink,
} from "./link-utils.ts";
import { type IStorageTransaction } from "./storage/interface.ts";

/**
 * This is the regular Cell interface, generated by DocImpl.asCell().
 *
 * This abstracts away the paths behind an interface that e.g. the UX code or
 * modules that prefer cell interfaces can use.
 *
 * These methods are available in the system and in spell code:
 *
 * @method get Returns the current value of the cell.
 * @returns {T}
 *
 * @method set Alias for `send`. Sets a new value for the cell.
 * @method send Sets a new value for the cell.
 * @param {T} value - The new value to set.
 * @returns {void}
 *
 * @method update Updates multiple properties of an object cell at once.
 * @param {Partial<T>} values - The properties to update.
 * @returns {void}
 *
 * @method push Adds an item to the end of an array cell.
 * @param {U | DocImpl<U> | LegacyDocCellLink} value - The value to add, where U is
 * the array element type.
 * @returns {void}
 *
 * @method equals Compares two cells for equality.
 * @param {Cell<any>} other - The cell to compare with.
 * @returns {boolean}
 *
 * @method key Returns a new cell for the specified key path.
 * @param {K} valueKey - The key to access in the cell's value.
 * @returns {Cell<T[K]>}
 *
 * Everything below is only available in the system, not in spell code:
 *
 * @method asSchema Creates a new cell with a specific schema.
 * @param {JSONSchema} schema - The schema to apply.
 * @returns {Cell<T>} - A cell with the specified schema.
 *
 * @method withLog Creates a new cell with a specific reactivity log.
 * @param {ReactivityLog} log - The log to use.
 * @returns {Cell<T>}
 *
 * @method sink Adds a callback that is called immediately and on cell changes.
 * @param {function} callback - The callback to be called when the cell changes.
 * @returns {function} - A function to Cleanup the callback.
 *
 * @method getAsQueryResult Returns a query result for the cell.
 * @param {Path} path - The optional path to follow.
 * @param {ReactivityLog} log - Optional reactivity log.
 * @returns {QueryResult<DeepKeyLookup<T, Path>>}
 *
 * @method getAsLegacyCellLink Returns a cell link for the cell (legacy format).
 * @returns {LegacyDocCellLink}
 *
 * @method getAsNormalizedFullLink Returns a normalized full link for the cell.
 * @returns {NormalizedFullLink}
 *
 * @method getAsLink Returns a cell link for the cell (new sigil format).
 * @returns {SigilLink}
 *
 * @method getRaw Raw access method, without following aliases (which would
 * write to the destination instead of the cell itself).
 * @returns {any} - Raw document data
 *
 * @method setRaw Raw write method that bypasses Cell validation,
 * transformation, and alias resolution. Writes directly to the cell without
 * following aliases.
 * @param {any} value - Raw value to write directly to document
 * @returns {boolean} - Result from underlying doc.send()
 *
 * @method getSourceCell Returns the source cell with optional schema.
 * @param {JSONSchema} schema - Optional schema to apply.
 * @returns {Cell<T & {[TYPE]: string | undefined} & {argument: any}>}
 *
 * @method toJSON Returns a serializable cell link (not the contents) to the
 * cell. This is used e.g. when creating merkle references that refer to cells.
 * It currentlly doesn't contain the space. We'll eventually want to get a
 * relative link here, but that will require context toJSON doesn't get.
 * @returns {{cell: {"/": string} | undefined, path: PropertyKey[]}}
 *
 * @property entityId Returns the current entity ID of the cell.
 * @returns {EntityId}
 *
 * @property sourceURI Returns the source URI of the cell.
 * @returns {URI}
 *
 * @property schema Optional schema for the cell.
 * @returns {JSONSchema | undefined}
 *
 * @property rootSchema Optional root schema for cell's schema. This differs
 * from `schema` when the cell represents a child of the original cell (e.g. via
 * `key()`). We need to keep the root schema to resolve `$ref` in the schema.
 * @returns {JSONSchema | undefined}
 *
 * The following are just for debugging and might disappear: (This allows
 * clicking on a property in the debugger and getting the value)
 *
 * @method value Returns the current value of the cell.
 * @returns {T}
 *
 * @property cellLink The cell link representing this cell.
 * @returns {LegacyDocCellLink}
 */
declare module "@commontools/api" {
  interface Cell<T> {
    get(): T;
    set(value: Cellify<T> | T): void;
    send(value: Cellify<T> | T): void;
    update<V extends Cellify<Partial<T> | Partial<T>>>(
      values: V extends object ? V : never,
    ): void;
    push(
      ...value: Array<
        | (T extends Array<infer U> ? (Cellify<U> | U | DocImpl<U>) : any)
        | Cell
      >
    ): void;
    equals(other: any): boolean;
    key<K extends T extends Cell<infer S> ? keyof S : keyof T>(
      valueKey: K,
    ): Cell<
      T extends Cell<infer S> ? S[K & keyof S] : T[K] extends never ? any : T[K]
    >;

    asSchema<S extends JSONSchema = JSONSchema>(
      schema: S,
    ): Cell<Schema<S>>;
    asSchema<T>(
      schema?: JSONSchema,
    ): Cell<T>;
    withLog(log: ReactivityLog): Cell<T>;
    sink(callback: (value: T) => Cancel | undefined | void): Cancel;
    getAsQueryResult<Path extends PropertyKey[]>(
      path?: Path,
      log?: ReactivityLog,
    ): QueryResult<DeepKeyLookup<T, Path>>;
    getAsLegacyCellLink(): LegacyDocCellLink;
    getAsNormalizedFullLink(): NormalizedFullLink;
    getAsLink(
      options?: {
        base?: Cell<any>;
        baseSpace?: MemorySpace;
        includeSchema?: boolean;
      },
    ): SigilLink;
    getAsWriteRedirectLink(
      options?: {
        base?: Cell<any>;
        baseSpace?: MemorySpace;
        includeSchema?: boolean;
      },
    ): SigilWriteRedirectLink;
    getDoc(): DocImpl<any>;
    getRaw(): any;
    setRaw(value: any): boolean;
    getSourceCell<T>(
      schema?: JSONSchema,
    ):
      | Cell<
        & T
        // Add default types for TYPE and `argument`. A more specific type in T will
        // take precedence.
        & { [TYPE]: string | undefined }
        & ("argument" extends keyof T ? unknown : { argument: any })
      >
      | undefined;
    getSourceCell<S extends JSONSchema = JSONSchema>(
      schema: S,
    ):
      | Cell<
        & Schema<S>
        // Add default types for TYPE and `argument`. A more specific type in
        // `schema` will take precedence.
        & { [TYPE]: string | undefined }
        & ("argument" extends keyof Schema<S> ? unknown
          : { argument: any })
      >
      | undefined;
    setSourceCell(sourceCell: Cell<any>): void;
    freeze(reason: string): void;
    isFrozen(): boolean;
    toJSON(): JSONCellLink;
    schema?: JSONSchema;
    rootSchema?: JSONSchema;
    value: T;
    cellLink: LegacyDocCellLink;
    space: MemorySpace;
    entityId: EntityId;
    sourceURI: URI;
    path: PropertyKey[];
    [isCellMarker]: true;
    copyTrap: boolean;
  }
}

export type { Cell } from "@commontools/api";

export type { MemorySpace } from "@commontools/memory/interface";

/**
 * Cellify is a type utility that allows any part of type T to be wrapped in
 * Cell<>, and allow any part of T that is currently wrapped in Cell<> to be
 * used unwrapped. This is designed for use with Cell<T> method parameters,
 * allowing flexibility in how values are passed.
 */
export type Cellify<T> =
  // Handle existing Cell<> types, allowing unwrapping
  T extends Cell<infer U> ? Cellify<U> | Cell<Cellify<U>>
    // Handle arrays
    : T extends Array<infer U> ? Array<Cellify<U>> | Cell<Array<Cellify<U>>>
    // Handle objects (excluding null), adding optional ID fields
    : T extends object ?
        | ({ [K in keyof T]: Cellify<T[K]> } & { [ID]?: any; [ID_FIELD]?: any })
        | Cell<
          { [K in keyof T]: Cellify<T[K]> } & { [ID]?: any; [ID_FIELD]?: any }
        >
    // Handle primitives
    : T | Cell<T>;

export interface Stream<T> {
  send(event: T): void;
  sink(callback: (event: T) => Cancel | undefined | void): Cancel;
  getRaw(): any;
  getAsNormalizedFullLink(): NormalizedFullLink;
  getDoc(): DocImpl<any>;
  schema?: JSONSchema;
  rootSchema?: JSONSchema;
  [isStreamMarker]: true;
}

export function createCell<T>(
  runtime: IRuntime,
  link: NormalizedFullLink,
  log?: ReactivityLog,
  noResolve = false,
): Cell<T> {
  const doc = runtime.documentMap.getDocByEntityId(link.space, link.id, true);
  let { path, schema, rootSchema } = link;

  // Resolve the path to check whether it's a stream. We're not logging this right now.
  // The corner case where during it's lifetime this changes from non-stream to stream
  // or vice versa will not be detected.
  const ref = noResolve
    ? { cell: doc, path, schema, rootSchema }
    : resolveLinkToValue(doc, path, undefined, schema, rootSchema);
  // Use schema from alias if provided and no explicit schema was set
  if (!schema && ref.schema) {
    schema = ref.schema;
    rootSchema = ref.rootSchema || ref.schema;
  }

  if (isStreamValue(ref.cell.getAtPath(ref.path))) {
    return createStreamCell(
      runtime,
      {
        ...link,
        space: ref.cell.space,
        id: toURI(ref.cell.entityId),
        path: ref.path as string[],
        schema,
        rootSchema,
      },
      log,
    ) as unknown as Cell<T>;
  } else {
    return createRegularCell(runtime, { ...link, schema, rootSchema }, log);
  }
}

function createStreamCell<T>(
  runtime: IRuntime,
  link: NormalizedFullLink,
  _log?: ReactivityLog,
): Stream<T> {
  const listeners = new Set<(event: T) => Cancel | undefined>();

  let cleanup: Cancel | undefined;

  const self: Stream<T> = {
    // Implementing just the subset of Cell<T> that is needed for streams.
    send: (event: T) => {
      // Use runtime from doc if available
      runtime.scheduler.queueEvent(link, event);

      cleanup?.();
      const [cancel, addCancel] = useCancelGroup();
      cleanup = cancel;

      listeners.forEach((callback) => addCancel(callback(event)));
    },
    sink: (callback: (value: T) => Cancel | undefined): Cancel => {
      listeners.add(callback);
      return () => listeners.delete(callback);
    },
    getRaw: () => self.getDoc().getAtPath(link.path),
    getAsNormalizedFullLink: () => link,
    getDoc: () => runtime.documentMap.getDocByEntityId(link.space, link.id),
    schema: link.schema,
    rootSchema: link.rootSchema,
    [isStreamMarker]: true,
  } satisfies Stream<T>;

  return self;
}

function appendTxToReactivityLog(
  log: ReactivityLog,
  tx: IStorageTransaction,
  runtime: IRuntime,
) {
  for (const change of tx.log()) {
    if ("read" in change) {
      log.reads.push(parseNormalizedFullLinktoLegacyDocCellLink(
        change.read!.address,
        runtime,
      ));
    }
    if ("write" in change) {
      log.writes.push(parseNormalizedFullLinktoLegacyDocCellLink(
        change.write!.address,
        runtime,
      ));
    }
  }
}

function createRegularCell<T>(
  runtime: IRuntime,
  link: NormalizedFullLink,
  log?: ReactivityLog,
): Cell<T> {
  const doc = runtime.documentMap.getDocByEntityId(link.space, link.id);
  const { path, schema, rootSchema } = link;

  const self = {
    get: () => {
      const tx = runtime.edit();
      const value = validateAndTransform(
        runtime,
        tx,
        link,
        log,
      );
      tx.commit();
      if (log) appendTxToReactivityLog(log, tx, runtime);
      return value;
    },
    set: (newValue: Cellify<T>) =>
      // TODO(@ubik2) investigate whether i need to check classified as i walk down my own obj
      diffAndUpdate(
        resolveLinkToWriteRedirect(doc, path, log, schema, rootSchema),
        newValue,
        log,
        getTopFrame()?.cause,
      ),
    send: (newValue: Cellify<T>) => self.set(newValue),
    update: (values: Cellify<Partial<T>>) => {
      if (!isRecord(values)) {
        throw new Error("Can't update with non-object value");
      }
      // Get current value, following aliases and references
      const ref = resolveLinkToValue(doc, path, log, schema, rootSchema);
      const currentValue = ref.cell.getAtPath(ref.path);

      // If there's no current value, initialize based on schema
      if (currentValue === undefined) {
        if (schema) {
          // Check if schema allows objects
          const allowsObject = schema.type === "object" ||
            (Array.isArray(schema.type) && schema.type.includes("object")) ||
            (schema.anyOf &&
              schema.anyOf.some((s) =>
                typeof s === "object" && s.type === "object"
              ));

          if (!allowsObject) {
            throw new Error(
              "Cannot update with object value - schema does not allow objects",
            );
          }
        }
        ref.cell.setAtPath(ref.path, {}, log, schema);
      }

      // Now update each property
      for (const [key, value] of Object.entries(values)) {
        // Workaround for type checking, since T can be Cell<> and that's fine.
        (self.key as any)(key).set(value);
      }
    },
    push: (
      ...values: Array<
        | (T extends Array<infer U> ? (Cellify<U> | U | DocImpl<U>) : any)
        | Cell
      >
    ) => {
      // Follow aliases and references, since we want to get to an assumed
      // existing array.
      const ref = resolveLinkToValue(doc, path, log, schema, rootSchema);
      const cause = getTopFrame()?.cause;

      let array = ref.cell.getAtPath(ref.path);
      if (array !== undefined && !Array.isArray(array)) {
        throw new Error("Can't push into non-array value");
      }

      // If this is an object and it doesn't have an ID, add one.
      const valuesToWrite = values.map((value: any) =>
        (!isLink(value) && isObject(value) &&
            (value as { [ID]?: unknown })[ID] === undefined && getTopFrame())
          ? { [ID]: getTopFrame()!.generatedIdCounter++, ...value }
          : value
      );

      // If there is no array yet, create it first. We have to do this as a
      // separate operation, so that in the next steps [ID] is properly anchored
      // in the array.
      if (array === undefined) {
        diffAndUpdate(ref, [], log, cause);
        array = Array.isArray(schema?.default) ? schema.default : [];
      }

      // Append the new values to the array.
      diffAndUpdate(ref, [...array, ...valuesToWrite], log, cause);

      const appended = ref.cell.getAtPath(ref.path).slice(
        -valuesToWrite.length,
      );

      // Hacky retry logic for push only. See storage.ts for details on this
      // retry approach and what we should really be doing instead.
      if (!ref.cell.retry) ref.cell.retry = [];
      ref.cell.retry.push((newBaseValue) => {
        // Unlikely, but maybe the conflict reset to undefined?
        if (!Array.isArray(newBaseValue)) {
          newBaseValue = Array.isArray(schema?.default) ? schema.default : [];
        }

        // Serialize cell links that were appended during the push. This works
        // because of the .toJSON() method on Cell.
        const newValues = JSON.parse(JSON.stringify(appended));

        // Reappend the new values.
        return [...(newBaseValue as unknown[]), ...newValues];
      });
    },
    equals: (other: any) => areLinksSame(self, other),
    key: <K extends T extends Cell<infer S> ? keyof S : keyof T>(
      valueKey: K,
    ): T extends Cell<infer S> ? Cell<S[K & keyof S]> : Cell<T[K]> => {
      const childSchema = doc.runtime.cfc.getSchemaAtPath(
        schema,
        [valueKey.toString()],
        rootSchema,
      );
      return createCell(
        runtime,
        {
          ...link,
          path: [...path, valueKey.toString()],
          schema: childSchema,
        },
        log,
      ) as T extends Cell<infer S> ? Cell<S[K & keyof S]> : Cell<T[K]>;
    },

    asSchema: (newSchema?: JSONSchema) =>
      createCell(
        runtime,
        { ...link, schema: newSchema, rootSchema: newSchema },
        log,
      ),
    withLog: (newLog: ReactivityLog) => createCell(runtime, link, newLog),
    sink: (callback: (value: T) => Cancel | undefined) =>
      subscribeToReferencedDocs(callback, runtime, link),
    getAsQueryResult: (subPath: PropertyKey[] = [], newLog?: ReactivityLog) =>
      createQueryResultProxy(doc, [...path, ...subPath], newLog ?? log),
    getAsLegacyCellLink: (): LegacyDocCellLink => {
      return { space: doc.space, cell: doc, path, schema, rootSchema };
    },
    getAsNormalizedFullLink: () => link,
    getAsLink: (
      options?: {
        base?: Cell<any>;
        baseSpace?: MemorySpace;
        includeSchema?: boolean;
      },
    ): SigilLink => {
      return createSigilLink(
        doc,
        path,
        schema,
        rootSchema,
        options,
      ) as SigilLink;
    },
    getAsWriteRedirectLink: (
      options?: {
        base?: Cell<any>;
        baseSpace?: MemorySpace;
        includeSchema?: boolean;
      },
    ): SigilWriteRedirectLink => {
      return createSigilLink(
        doc,
        path,
        schema,
        rootSchema,
        { ...options, overwrite: "redirect" },
      ) as SigilWriteRedirectLink;
    },
    getDoc: () => doc,
    getRaw: () => doc.getAtPath(path),
    setRaw: (value: any) => doc.setAtPath(path, value),
    getSourceCell: (newSchema?: JSONSchema) =>
      doc.sourceCell?.asCell([], log, newSchema, newSchema) as Cell<any>,
    setSourceCell: (sourceCell: Cell<any>) => {
      if (sourceCell.path.length > 0) {
        throw new Error("Source cell must have empty path for now");
      }
      doc.sourceCell = sourceCell.getDoc();
    },
    freeze: (reason: string) => doc.freeze(reason),
    isFrozen: () => doc.isFrozen(),
    toJSON: (): JSONCellLink => // Keep old format for backward compatibility
    ({ cell: doc.toJSON()!, path: path as (string | number)[] }),
    get value(): T {
      return self.get();
    },
    get cellLink(): LegacyDocCellLink {
      return { space: doc.space, cell: doc, path, schema, rootSchema };
    },
    get space(): MemorySpace {
      return doc.space;
    },
    get entityId(): EntityId | undefined {
      return getEntityId({ cell: doc, path });
    },
    get sourceURI(): URI {
      return toURI(doc.entityId);
    },
    get path(): PropertyKey[] {
      return path;
    },
    [isCellMarker]: true,
    get copyTrap(): boolean {
      throw new Error(
        "Copy trap: Don't copy renderer cells. Create references instead.",
      );
    },
    schema,
    rootSchema,
  } as Cell<T>;

  return self;
}

function subscribeToReferencedDocs<T>(
  callback: (value: T) => Cancel | undefined,
  runtime: IRuntime,
  link: NormalizedFullLink,
): Cancel {
  const initialLog = {
    reads: [],
    writes: [],
  } satisfies ReactivityLog;

  // Get the value once to determine all the docs that need to be subscribed to.
  const tx = runtime.edit();
  const value = validateAndTransform(
    runtime,
    tx,
    link,
    initialLog,
  ) as T;
  tx.commit();
  appendTxToReactivityLog(initialLog, tx, runtime);

  // Call the callback once with initial value if requested.
  let cleanup: Cancel | undefined = callback(value);

  // Subscribe to the docs that are read (via logs), call callback on next change.
  if (!runtime) {
    throw new Error("No runtime available for subscribe");
  }
  const cancel = runtime.scheduler.subscribe((log) => {
    const newLog = {
      reads: [],
      writes: [],
    } satisfies ReactivityLog;

    if (isCancel(cleanup)) cleanup();

    const tx = runtime.edit();
    const newValue = validateAndTransform(
      runtime,
      tx,
      link,
      newLog,
    ) as T;

    // Copy reads to log _before_ calling the callback, as we're only interested
    // in dependencies for the initial get, not further cells the callback might
    // read. The callback is responsible for calling sink on those cells if it
    // wants to stay updated.
    log.reads.push(...newLog.reads);
    appendTxToReactivityLog(log, tx, runtime);
    cleanup = callback(newValue);
    tx.commit();
  }, initialLog);

  return () => {
    cancel();
    if (isCancel(cleanup)) cleanup();
  };
}

/**
 * Creates a sigil reference (link or alias) with shared logic
 */
function createSigilLink(
  doc: DocImpl<any>,
  path: PropertyKey[],
  schema?: JSONSchema,
  rootSchema?: JSONSchema,
  options: {
    base?: Cell<any>;
    baseSpace?: MemorySpace;
    includeSchema?: boolean;
    overwrite?: "redirect" | "this"; // default is "this"
  } = {},
): SigilLink {
  // Create the base structure
  const sigil: SigilLink = {
    "/": {
      [LINK_V1_TAG]: {
        path: path.map((p) => p.toString()),
      },
    },
  };

  const reference = sigil["/"][LINK_V1_TAG];

  // Handle base cell for relative references
  if (options.base) {
    const baseDoc = options.base.getDoc();

    // Only include id if it's different from base
    if (getEntityId(doc)!["/"] !== getEntityId(baseDoc)?.["/"]) {
      reference.id = toURI(doc.entityId);
    }

    // Only include space if it's different from base
    if (doc.space && doc.space !== baseDoc.space) reference.space = doc.space;
  } else {
    reference.id = toURI(doc.entityId);

    // Handle baseSpace option - only include space if different from baseSpace
    if (doc.space !== options.baseSpace) reference.space = doc.space;
  }

  // Include schema if requested
  if (options.includeSchema && schema) {
    reference.schema = schema;
    reference.rootSchema = rootSchema;
  }

  // Include overwrite if present and it's a redirect
  if (options.overwrite && options.overwrite !== "this") {
    reference.overwrite = "redirect";
  }

  return sigil;
}

/**
 * Check if value is a simple cell.
 *
 * @param {any} value - The value to check.
 * @returns {boolean}
 */
export function isCell(value: any): value is Cell<any> {
  return isRecord(value) && value[isCellMarker] === true;
}

const isCellMarker = Symbol("isCell");

/**
 * Type guard to check if a value is a Stream.
 * @param value - The value to check
 * @returns True if the value is a Stream
 */
export function isStream(value: any): value is Stream<any> {
  return isRecord(value) && value[isStreamMarker] === true;
}

const isStreamMarker = Symbol("isStream");
