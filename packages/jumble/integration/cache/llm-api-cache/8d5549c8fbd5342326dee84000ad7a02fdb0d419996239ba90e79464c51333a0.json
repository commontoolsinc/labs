{
  "model": "anthropic:claude-3-7-sonnet-20250219",
  "system": "# React Component Builder\n\nCreate an interactive React component that fulfills the user's request. Focus on\ndelivering a clean, useful implementation with appropriate features.\n\n<meta>\n**This task is part of a 2-Phase Process.**\n\n1. First phase (already completed):\n   - Analyzed the user's request\n   - Created a detailed specification\n   - Generated a structured data schema\n\n2. Your job (second phase):\n   - Create a reactive UI component based on the provided specification and\n     schema\n   - Implement the UI exactly according to the specification\n   - Strictly adhere to the data schema provided\n     </meta>\n\n<requirements>\n- Define a title with `const title = 'Your App Name';`\n- Implement both `onLoad` and `onReady` functions\n- Use Tailwind CSS for styling with tasteful defaults\n- Do not write <svg> inline, use emoji for icons\n- Carefully avoid infinite loops and recursion that may cause performance issues\n</requirements>\n\n<code_structure>\n\n- React and ReactDOM are pre-imported - don't import them again\n- All React hooks must be namespaced (e.g., `React.useState`, `React.useEffect`)\n- Follow React hooks rules - never nest or conditionally call hooks\n- For form handling, use `onClick` handlers instead of `onSubmit`\n  </code_structure>\n\n<charm_api>\n\n- **useReactiveCell(keyPath: string[])** - Persistent data storage with reactive\n  updates\n- **generateText({ system, messages })** - Generate text via Large Language\n  Model\n- **generateObject({ system, messages })** - Generate JSON object via Large\n  Language Model\n- **readWebpage(url)** - Fetch and parse external web content\n- **generateImage(prompt)** - Create AI-generated images\n\n  <use_reactive_cell>\n  ## Important Note About useReactiveCell(keyPath: string[])\n  - **useReactiveCell is a React Hook** and must follow all React hook rules\n  - It should only be used for persistent state and must draw from the provided\n    schema\n    - For any ephemeral state, use `React.useState`\n  - Only call useReactiveCell at the top level of your React function components\n    or custom hooks\n  - Do not call useReactiveCell inside loops, conditions, or nested functions\n  - Do not call useReactiveCell directly inside the onReady function - it can\n    only be used inside React components\n  - The onReady function itself is not a React component and cannot use React\n    hooks directly\n  - Example of correct usage:\n    ```jsx\n    function onReady(mount, sourceData, modules) {\n      // This is NOT a React component, so do NOT use hooks here!\n\n      // Create a React component to use hooks properly:\n      function MyApp() {\n        // React hooks can be used here\n        const [data, setData] = useReactiveCell(\"myData\", defaultValue);\n        return <div>{/* your JSX */}</div>;\n      }\n\n      // Render the React component to the mount point\n      const root = ReactDOM.createRoot(mount);\n      root.render(<MyApp />);\n    }\n    ```\n  </use_reactive_cell> </charm_api>\n\n<importing_libraries>\n\n- Request additional libraries in `onLoad` by returning an array of module names\n- Available libraries:\n- imports : [object Object]\n- Only use the explicitly provided libraries </importing_libraries>\n\n<security>\n\n- Do not use browser dialog functions (`prompt()`, `alert()`, `confirm()`)\n- Avoid any methods that could compromise security or user experience\n\n</security>\n\n<schema description=\"The pre-generated schema this Charm operates on.\">\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"board\": {\n      \"type\": \"array\",\n      \"title\": \"Game Board\",\n      \"description\": \"4x4 grid representing the game board\",\n      \"default\": [\n        [\n          0,\n          0,\n          0,\n          0\n        ],\n        [\n          0,\n          0,\n          0,\n          0\n        ],\n        [\n          0,\n          0,\n          0,\n          0\n        ],\n        [\n          0,\n          0,\n          0,\n          0\n        ]\n      ],\n      \"items\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        }\n      }\n    },\n    \"score\": {\n      \"type\": \"integer\",\n      \"title\": \"Current Score\",\n      \"description\": \"Player's current score in the game\",\n      \"default\": 0,\n      \"minimum\": 0\n    },\n    \"bestScore\": {\n      \"type\": \"integer\",\n      \"title\": \"Best Score\",\n      \"description\": \"Highest score achieved\",\n      \"default\": 0,\n      \"minimum\": 0\n    },\n    \"gameState\": {\n      \"type\": \"string\",\n      \"title\": \"Game State\",\n      \"description\": \"Current state of the game\",\n      \"enum\": [\n        \"playing\",\n        \"won\",\n        \"lost\"\n      ],\n      \"default\": \"playing\"\n    },\n    \"highestTile\": {\n      \"type\": \"integer\",\n      \"title\": \"Highest Tile\",\n      \"description\": \"Value of the highest tile on the board\",\n      \"default\": 2,\n      \"minimum\": 2\n    }\n  },\n  \"title\": \"2048 Game Board\",\n  \"description\": \"A game charm to play the classic 2048 sliding tile puzzle.\"\n}\n</schema>\n\n<guide>\n# SDK Usage Guide\n\n<persistent-reactive-state>\n## 1. `useReactiveCell` Hook\n\nThe `useReactiveCell` hook binds to a reactive cell given a key path and returns\na tuple `[doc, setDoc]`:\n\nAny keys from the view-model-schema are valid for useReactiveCell, any other\nkeys will fail. Provide a default as the second argument, **do not set an\ninitial value explicitly**.\n\nFor this schema:\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"counter\": {\n      \"type\": \"number\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"default\": \"My Counter App\"\n    }\n  }\n}\n```\n\n```jsx\nfunction CounterComponent() {\n  // Correct: useReactiveCell called at top level of component\n  const [counter, setCounter] = useReactiveCell(\"counter\");\n  const [maxValue, setMaxValue] = useReactiveCell([\"settings\", \"maxValue\"]);\n\n  const onIncrement = useCallback(() => {\n    // writing to the cell automatically triggers a re-render\n    setCounter(counter + 1);\n  }, [counter]);\n\n  return (\n    <button onClick={onIncrement}>\n      Increment\n    </button>\n  );\n}\n```\n\n</persistent-reactive-state>\n\n<generating_content> Several APIs exist for generating text, JSON or image urls.\n\n<text>\n`generateText({ system, messages}): Promise<string>`\n\n```jsx\nasync function fetchLLMResponse() {\n  const result = await generateText({\n    system: \"Translate all the messages to emojis, reply in JSON.\",\n    messages: [\"Hi\", \"How can I help you today?\", \"tell me a joke\"],\n  });\n  console.log(\"LLM responded:\", result);\n}\n```\n\n</text>\n\n<json>\n\n`window.generateObject({ system, messages }): Promise<object>`\n\nYou must give the exact schema of the response in the prompt.\n\nFor example: \"Generate a traditional Vietnamese recipe in JSON format, with the\nfollowing properties: name (string), ingredients (array of strings),\ninstructions (array of strings)\"\n\n`generateObject` returns a parsed object already, or `undefined`. Be defensive\nworking with the response, the LLM may make mistakes.\n\n<example>\n```jsx\nconst promptPayload = ;\nconst result = await generateObject({\n  system: 'Translate all the messages to emojis, reply in JSON with the following properties: an array of objects, each with original_text (string), emoji_translation (string)',\n  messages: ['Hi', 'How can I help you today?', 'tell me a joke'],\n});\nconsole.log('JSON response from llm:', result);\n\n// [ // { // \"original_text\": \"Hi\", // \"emoji_translation\": \"üëã\" // }, // { //\n\"original_text\": \"How can I help you today?\", // \"emoji_translation\":\n\"ü§î‚ùìüôã‚Äç‚ôÇÔ∏èüìÖ\" // }, // { // \"original_text\": \"tell me a joke\", //\n\"emoji_translation\": \"üó£Ô∏èüëâüòÇ\" // } // ]\n\n````\n</example>\n\n<example>\nNOTE: Language model requests are globally cached based on your prompt.\nThis means that identical requests will return the same result. If your llm use\nrequires unique results on every request, make sure to introduce a cache-breaking\nstring such as a timestamp or incrementing number/id.\n\n```jsx\n// To avoid the cache we'll use a cache-busting string.\nconst cacheBreaker = Date.now();\n\nconst result = await generateObject({\n  system: \"You are a professional chef specializing in Mexican cuisine. Generate a detailed, authentic Mexican recipe in JSON format with the following properties: title (string), ingredients (array of strings), instructions (array of strings), prepTime (integer in minutes), cookTime (integer in minutes)\",\n  messages: [\"give me something spicy!\" + \" \" + cacheBreaker],\n});\nconsole.log('JSON response from llm:', result);\n\n// {\n//     \"title\": \"Camarones a la Diabla (Devil Shrimp)\",\n//     \"ingredients\": [\n//         \"1.5 lbs Large Shrimp, peeled and deveined\",\n//         \"4 tbsp Olive Oil\",\n//         \"1 medium White Onion, finely chopped\",\n//         \"4 cloves Garlic, minced\",\n//         \"2-3 Habanero Peppers, finely chopped (adjust to your spice preference, remove seeds for less heat)\",\n//         \"1 (28 oz) can Crushed Tomatoes\",\n//         \"1/2 cup Chicken Broth\",\n//         \"2 tbsp Tomato Paste\",\n//         \"1 tbsp Apple Cider Vinegar\",\n//         \"1 tbsp Dried Oregano\",\n//         \"1 tsp Cumin\",\n//         \"1/2 tsp Smoked Paprika\",\n//         \"1/4 tsp Ground Cloves\",\n//         \"Salt and Black Pepper to taste\",\n//         \"Fresh Cilantro, chopped, for garnish\",\n//         \"Lime wedges, for serving\"\n//     ],\n//     \"instructions\": [\n//         \"In a large bowl, toss the shrimp with salt and pepper.\",\n//         \"Heat the olive oil in a large skillet or Dutch oven over medium-high heat.\",\n//         \"Add the onion and cook until softened, about 5 minutes.\",\n//         \"Add the garlic and habanero peppers and cook for 1 minute more, until fragrant.\",\n//         \"Stir in the crushed tomatoes, chicken broth, tomato paste, apple cider vinegar, oregano, cumin, smoked paprika, and cloves.\",\n//         \"Bring the sauce to a simmer and cook for 15 minutes, stirring occasionally, until slightly thickened.\",\n//         \"Add the shrimp to the sauce and cook for 3-5 minutes, or until the shrimp are pink and cooked through.\",\n//         \"Taste and adjust seasoning with salt and pepper as needed.\",\n//         \"Garnish with fresh cilantro and serve immediately with lime wedges. Serve with rice or tortillas.\"\n//     ],\n//     \"prepTime\": 20,\n//     \"cookTime\": 30\n// }\n````\n\n</example>\n\n</json>\n\n<images>\n\nSynchronous, generates a URL that will load the image.\n\n```jsx\nfunction ImageComponent() {\n  return (\n    <img\n      src={generateImageUrl(\"A beautiful sunset over mountains\")}\n      alt=\"Generated landscape\"\n    />\n  );\n}\n```\n\n</images>\n</generating_content>\n\n<fetching_content> `readWebpage(url: string): Promise<string>` Returns markdown\nformat.\n\n```jsx\nasync function fetchFromUrl() {\n  const url = \"https://twopm.studio\";\n  const result = await readWebpage(url);\n  console.log(\"Markdown:\", result.content);\n}\n```\n\n</fetching_content>\n\n<code_structure> All generated code must follow this pattern:\n\n```jsx\n// Import from modern ESM libraries:\n////   - react\n//   - react-dom\n//   - react-dom/client\n//   - d3\n//   - moment\n//   - marked\n//   - @react-spring/web\n//   - @use-gesture/react\n//   - uuid\n//   - tone\nfunction onLoad() {\n  return [\"@react-spring/web\"]; // Request the modules you need\n}\n\nconst title = \"My ESM App\";\nfunction ImageComponent({ url }) {\n  return <img src={url} alt=\"Generated landscape\" />;\n}\n\nfunction MyComponent({ label, description }) {\n  return (\n    <div>\n      <h2>{label}</h2>\n      <p>{description}</p>\n      <ImageComponent\n        url={generateImage(\"A beautiful sunset over mountains\")}\n      />\n    </div>\n  );\n}\n\nfunction TodoItem({ todo, onToggle, onDelete }) {\n  return (\n    <div className=\"flex items-center p-2 border-b\">\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={onToggle}\n        className=\"mr-2\"\n      />\n      <span\n        className={`flex-grow \\${todo.completed ? 'line-through text-gray-500' : ''}`}\n      >\n        {todo.text}\n      </span>\n      <button\n        onClick={onDelete}\n        className=\"px-2 py-1 bg-red-500 text-white rounded\"\n      >\n        Delete\n      </button>\n    </div>\n  );\n}\n\nfunction TodoList({ todo, setTodos }) {\n  const [newTodo, setNewTodo] = React.useState(\"\");\n\n  const addTodo = () => {\n    if (newTodo.trim() === \"\") return;\n\n    const newTodoItem = {\n      id: Date.now(),\n      text: newTodo,\n      completed: false,\n    };\n\n    setTodos([...todos, newTodoItem]);\n    setNewTodo(\"\");\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(\n      todos.map((todo) =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      ),\n    );\n  };\n\n  const deleteTodo = (id) => {\n    setTodos(todos.filter((todo) => todo.id !== id));\n  };\n\n  return (\n    <div className=\"max-w-md mx-auto mt-4 p-4 bg-white rounded shadow\">\n      <h2 className=\"text-xl font-bold mb-4\">Todo List</h2>\n\n      <div className=\"flex mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          placeholder=\"Add a new todo\"\n          className=\"flex-grow p-2 border rounded-l\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded-r\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"border rounded\">\n        {todos.length > 0\n          ? (\n            todos.map((todo) => (\n              <TodoItem\n                key={todo.id}\n                todo={todo}\n                onToggle={() => toggleTodo(todo.id)}\n                onDelete={() => deleteTodo(todo.id)}\n              />\n            ))\n          )\n          : <p className=\"p-2 text-center text-gray-500\">No todos yet!</p>}\n      </div>\n    </div>\n  );\n}\n\n// Main application code with modules passed as third parameter\nfunction onReady(mount, sourceData, libs) {\n  const { useState, useEffect } = React; // React is available globally\n  const { useSpring, animated } = libs[\"@react-spring/web\"]; // Access imported module\n\n  function MyApp() {\n    const [count, setCount] = useReactiveCell(\"count\");\n    const [todos, setTodos] = useReactiveCell(\"todos\");\n\n    const props = useSpring({\n      from: { opacity: 0 },\n      to: { opacity: 1 },\n    });\n\n    return (\n      <div className=\"p-4\">\n        <animated.div style={props}>\n          <button\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded\"\n            onClick={() => setCount(count + 1)}\n          >\n            Clicks: {count}\n          </button>\n        </animated.div>\n        <TodoList todos={todos} setTodos={setTodos} />\n      </div>\n    );\n  }\n\n  // Use the client API for React 18\n  const root = ReactDOM.createRoot(mount);\n  root.render(<MyApp />);\n}\n```\n\n</guide>\n",
  "messages": [
    {
      "role": "user",
      "content": "The user asked you to create the source code with the following specification:\n```\n<REQUEST>\n<goal>2048 game</goal>\n\n<description>Create a üéÆ 2048 game charm with a grid-based UI, sliding tile mechanics, and score tracking. The charm will need a game board, tile merging logic, and win/lose conditions. Could add üèÜ high score tracking and üîÑ game reset functionality.</description>\n</REQUEST>\n<PLAN>1. Implement the game board representation and basic game state tracking\n2. Create the tile movement and merging logic for all four directions\n3. Add score calculation, win/lose condition detection, and game reset functionality</PLAN>\n<SPEC>The 2048 game uses a 4x4 grid where tiles with the same number merge when slid together, doubling their value. Players slide tiles in four directions (up, down, left, right) with the goal of creating a tile with the value 2048. The game tracks the current score, which increases whenever tiles merge, and ends when no more moves are possible or when the 2048 tile is created.</SPEC>\n```"
    },
    {
      "role": "assistant",
      "content": "\nfunction onLoad() {\n  return [\"@react-spring/web\"];\n}\n\nconst title = '2048 Game';\n\n// Game logic utilities\nconst getEmptyPositions = (board) => {\n  const positions = [];\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      if (board[i][j] === 0) {\n        positions.push({ row: i, col: j });\n      }\n    }\n  }\n  return positions;\n};\n\nconst addRandomTile = (board) => {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const emptyPositions = getEmptyPositions(newBoard);\n  \n  if (emptyPositions.length === 0) return newBoard;\n  \n  const { row, col } = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];\n  newBoard[row][col] = Math.random() < 0.9 ? 2 : 4;\n  \n  return newBoard;\n};\n\nconst rotateBoard = (board, times = 1) => {\n  let newBoard = JSON.parse(JSON.stringify(board));\n  for (let i = 0; i < times; i++) {\n    const rotated = Array(4).fill().map(() => Array(4).fill(0));\n    for (let r = 0; r < 4; r++) {\n      for (let c = 0; c < 4; c++) {\n        rotated[c][3 - r] = newBoard[r][c];\n      }\n    }\n    newBoard = rotated;\n  }\n  return newBoard;\n};\n\nconst moveLeft = (board) => {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  let score = 0;\n  let moved = false;\n\n  for (let r = 0; r < 4; r++) {\n    let row = newBoard[r].filter(val => val !== 0);\n    let resultRow = [];\n    \n    for (let i = 0; i < row.length; i++) {\n      if (i < row.length - 1 && row[i] === row[i + 1]) {\n        const mergedValue = row[i] * 2;\n        resultRow.push(mergedValue);\n        score += mergedValue;\n        i++;\n        moved = true;\n      } else {\n        resultRow.push(row[i]);\n      }\n    }\n    \n    // Fill with zeros\n    while (resultRow.length < 4) {\n      resultRow.push(0);\n    }\n    \n    // Check if the row changed\n    if (!moved && JSON.stringify(newBoard[r]) !== JSON.stringify(resultRow)) {\n      moved = true;\n    }\n    \n    newBoard[r] = resultRow;\n  }\n  \n  return { board: newBoard, score, moved };\n};\n\nconst move = (board, direction) => {\n  // 0: left, 1: up, 2: right, 3: down\n  let rotatedBoard = board;\n  \n  if (direction > 0) {\n    rotatedBoard = rotateBoard(board, 4 - direction);\n  }\n  \n  const { board: movedBoard, score, moved } = moveLeft(rotatedBoard);\n  \n  let resultBoard = movedBoard;\n  if (direction > 0) {\n    resultBoard = rotateBoard(movedBoard, direction);\n  }\n  \n  return { board: resultBoard, score, moved };\n};\n\nconst isGameOver = (board) => {\n  // Check if there are any empty cells\n  if (getEmptyPositions(board).length > 0) return false;\n  \n  // Check if any adjacent tiles can be merged\n  for (let r = 0; r < 4; r++) {\n    for (let c = 0; c < 4; c++) {\n      const current = board[r][c];\n      \n      // Check right\n      if (c < 3 && current === board[r][c + 1]) return false;\n      \n      // Check down\n      if (r < 3 && current === board[r + 1][c]) return false;\n    }\n  }\n  \n  return true;\n};\n\nconst hasWon = (board, targetValue = 2048) => {\n  for (let r = 0; r < 4; r++) {\n    for (let c = 0; c < 4; c++) {\n      if (board[r][c] >= targetValue) return true;\n    }\n  }\n  return false;\n};\n\nconst getHighestTile = (board) => {\n  let highest = 0;\n  for (let r = 0; r < 4; r++) {\n    for (let c = 0; c < 4; c++) {\n      highest = Math.max(highest, board[r][c]);\n    }\n  }\n  return highest;\n};\n\n// Color mapping for tiles\nconst getTileColor = (value) => {\n  const colors = {\n    0: 'bg-gray-200',\n    2: 'bg-amber-100 text-gray-800',\n    4: 'bg-amber-200 text-gray-800',\n    8: 'bg-orange-300 text-white',\n    16: 'bg-orange-400 text-white',\n    32: 'bg-orange-500 text-white',\n    64: 'bg-orange-600 text-white',\n    128: 'bg-yellow-300 text-white',\n    256: 'bg-yellow-400 text-white',\n    512: 'bg-yellow-500 text-white',\n    1024: 'bg-yellow-600 text-white',\n    2048: 'bg-yellow-700 text-white',\n  };\n  \n  return colors[value] || 'bg-red-600 text-white';\n};\n\nconst getFontSize = (value) => {\n  if (value < 100) return 'text-4xl';\n  if (value < 1000) return 'text-3xl';\n  return 'text-2xl';\n};\n\n// Game components\nfunction Tile({ value, animation }) {\n  const { animated } = window.libs[\"@react-spring/web\"];\n  \n  return (\n    <animated.div \n      style={animation}\n      className={`flex items-center justify-center w-16 h-16 rounded-md shadow-md \n                 ${getTileColor(value)} ${getFontSize(value)} font-bold`}\n    >\n      {value !== 0 ? value : ''}\n    </animated.div>\n  );\n}\n\nfunction GameBoard({ board, highestTile }) {\n  const { useSpring } = window.libs[\"@react-spring/web\"];\n  \n  // Animation for new tiles\n  const tileAnimation = useSpring({\n    from: { opacity: 0, scale: 0.5 },\n    to: { opacity: 1, scale: 1 },\n    config: { tension: 300, friction: 20 }\n  });\n\n  return (\n    <div className=\"bg-gray-300 p-3 rounded-lg shadow-lg\">\n      <div className=\"grid grid-cols-4 gap-3\">\n        {board.flat().map((value, index) => (\n          <Tile \n            key={index} \n            value={value} \n            animation={value ? tileAnimation : {}} \n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\nfunction ScoreBoard({ score, bestScore }) {\n  return (\n    <div className=\"flex justify-between mb-4\">\n      <div className=\"bg-gray-700 text-white p-3 rounded-md shadow\">\n        <div className=\"text-sm font-semibold\">SCORE</div>\n        <div className=\"text-2xl font-bold\">{score}</div>\n      </div>\n      <div className=\"bg-gray-700 text-white p-3 rounded-md shadow\">\n        <div className=\"text-sm font-semibold\">BEST</div>\n        <div className=\"text-2xl font-bold\">{bestScore}</div>\n      </div>\n    </div>\n  );\n}\n\nfunction GameOverModal({ gameState, score, onRestart }) {\n  if (gameState === 'playing') return null;\n  \n  return (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-50\">\n      <div className=\"bg-white p-6 rounded-lg shadow-lg text-center\">\n        <h2 className=\"text-2xl font-bold mb-4\">\n          {gameState === 'won' ? 'üéâ You Won!' : 'üò¢ Game Over!'}\n        </h2>\n        <p className=\"text-xl mb-4\">Your score: {score}</p>\n        <button \n          onClick={onRestart}\n          className=\"bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded\"\n        >\n          Play Again\n        </button>\n      </div>\n    </div>\n  );\n}\n\nfunction Game2048() {\n  const [board, setBoard] = useReactiveCell(['board']);\n  const [score, setScore] = useReactiveCell(['score']);\n  const [bestScore, setBestScore] = useReactiveCell(['bestScore']);\n  const [gameState, setGameState] = useReactiveCell(['gameState']);\n  const [highestTile, setHighestTile] = useReactiveCell(['highestTile']);\n  \n  const handleKeyDown = React.useCallback((e) => {\n    if (gameState !== 'playing') return;\n    \n    let direction;\n    switch (e.key) {\n      case 'ArrowLeft': direction = 0; break;\n      case 'ArrowUp': direction = 1; break;\n      case 'ArrowRight': direction = 2; break;\n      case 'ArrowDown': direction = 3; break;\n      default: return;\n    }\n    \n    const { board: newBoard, score: addedScore, moved } = move(board, direction);\n    \n    if (moved) {\n      const boardWithNewTile = addRandomTile(newBoard);\n      setBoard(boardWithNewTile);\n      \n      const newScore = score + addedScore;\n      setScore(newScore);\n      \n      if (newScore > bestScore) {\n        setBestScore(newScore);\n      }\n      \n      const currentHighestTile = getHighestTile(boardWithNewTile);\n      if (currentHighestTile > highestTile) {\n        setHighestTile(currentHighestTile);\n      }\n      \n      // Check win/lose conditions\n      if (hasWon(boardWithNewTile)) {\n        setGameState('won');\n      } else if (isGameOver(boardWithNewTile)) {\n        setGameState('lost');\n      }\n    }\n  }, [board, score, bestScore, gameState, highestTile]);\n  \n  React.useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n  \n  const handleSwipe = React.useCallback((direction) => {\n    if (gameState === 'playing') {\n      handleKeyDown({ key: direction });\n    }\n  }, [gameState, handleKeyDown]);\n  \n  const restartGame = () => {\n    const emptyBoard = Array(4).fill().map(() => Array(4).fill(0));\n    const initialBoard = addRandomTile(addRandomTile(emptyBoard));\n    setBoard(initialBoard);\n    setScore(0);\n    setGameState('playing');\n    setHighestTile(getHighestTile(initialBoard));\n  };\n  \n  return (\n    <div className=\"max-w-md mx-auto p-4 relative\">\n      <div className=\"flex justify-between items-center mb-4\">\n        <h1 className=\"text-4xl font-bold text-gray-800\">2048</h1>\n        <button \n          onClick={restartGame}\n          className=\"bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded\"\n        >\n          New Game\n        </button>\n      </div>\n      \n      <ScoreBoard score={score} bestScore={bestScore} />\n      \n      <div className=\"mb-4 text-gray-600\">\n        <p>Join the tiles, get to <strong>2048</strong>!</p>\n        <p className=\"text-sm\">Use arrow keys to move tiles.</p>\n      </div>\n      \n      <div className=\"relative\">\n        <GameBoard board={board} highestTile={highestTile} />\n        <GameOverModal \n          gameState={gameState} \n          score={score} \n          onRestart={restartGame} \n        />\n      </div>\n      \n      {/* Mobile controls */}\n      <div className=\"mt-6 grid grid-cols-3 gap-2\">\n        <div></div>\n        <button \n          onClick={() => handleSwipe('ArrowUp')}\n          className=\"bg-gray-300 hover:bg-gray-400 p-3 rounded text-2xl\"\n        >\n          ‚¨ÜÔ∏è\n        </button>\n        <div></div>\n        \n        <button \n          onClick={() => handleSwipe('ArrowLeft')}\n          className=\"bg-gray-300 hover:bg-gray-400 p-3 rounded text-2xl\"\n        >\n          ‚¨ÖÔ∏è\n        </button>\n        <button \n          onClick={() => handleSwipe('ArrowDown')}\n          className=\"bg-gray-300 hover:bg-gray-400 p-3 rounded text-2xl\"\n        >\n          ‚¨áÔ∏è\n        </button>\n        <button \n          onClick={() => handleSwipe('ArrowRight')}\n          className=\"bg-gray-300 hover:bg-gray-400 p-3 rounded text-2xl\"\n        >\n          ‚û°Ô∏è\n        </button>\n      </div>\n      \n      <div className=\"mt-4 text-sm text-gray-500\">\n        <p>HOW TO PLAY: Use your arrow keys to move the tiles. When two tiles with the same number touch, they merge into one!</p>\n      </div>\n    </div>\n  );\n}\n\nfunction onReady(mount, sourceData, libs) {\n  // Initialize the game\n  function initializeGame() {\n    const emptyBoard = Array(4).fill().map(() => Array(4).fill(0));\n    const initialBoard = addRandomTile(addRandomTile(emptyBoard));\n    return initialBoard;\n  }\n  \n  function App() {\n    const [board, setBoard] = useReactiveCell(['board']);\n    \n    // Initialize the board if it's empty\n    React.useEffect(() => {\n      if (board.flat().every(cell => cell === 0)) {\n        setBoard(initializeGame());\n      }\n    }, [board]);\n    \n    return <Game2048 />;\n  }\n  \n  const root = ReactDOM.createRoot(mount);\n  root.render(<App />);\n}\n```"
    }
  ],
  "stop": "\n```",
  "maxTokens": 64000
}