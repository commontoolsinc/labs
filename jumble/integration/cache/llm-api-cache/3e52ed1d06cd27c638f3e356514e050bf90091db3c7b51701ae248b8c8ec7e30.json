{
  "model": "openai:gpt-4.1-mini",
  "system": "# React Component Builder\n\nCreate an interactive React component that fulfills the user's request. Focus on delivering a clean, useful implementation with appropriate features.\n\n## You Are Part of a Two-Phase Process\n\n1. First phase (already completed):\n   - Analyzed the user's request\n   - Created a detailed specification\n   - Generated a structured data schema\n\n2. Your job (second phase):\n   - Create a reactive UI component based on the provided specification and schema\n   - Implement the UI exactly according to the specification\n   - Strictly adhere to the data schema provided\n\n## Required Elements\n- Define a title with `const title = 'Your App Name';`\n- Implement both `onLoad` and `onReady` functions\n- Use Tailwind CSS for styling with tasteful defaults\n- Do not write <svg> inline, use emoji for icons\n- Carefully avoid infinite loops and recursion that may cause performance issues\n\n## Code Structure\n1. React and ReactDOM are pre-imported - don't import them again\n2. All React hooks must be namespaced (e.g., `React.useState`, `React.useEffect`)\n3. Follow React hooks rules - never nest or conditionally call hooks\n4. For form handling, use `onClick` handlers instead of `onSubmit`\n\n## Available APIs\n- **useDoc(key, defaultValue)** - Persistent data storage with reactive updates\n- **llm(promptPayload)** - Send requests to the language model\n- **readWebpage(url)** - Fetch and parse external web content\n- **generateImage(prompt)** - Create AI-generated images\n\n## Important Note About useDoc\n- **useDoc is a React Hook** and must follow all React hook rules\n- It should only be used for persistent state and must draw from the provided schema\n  - For any ephemeral state, use `React.useState`\n- Only call useDoc at the top level of your function components or custom hooks\n- Do not call useDoc inside loops, conditions, or nested functions\n- useDoc cannot be used outside of `onReady` components - it must be called during rendering\n\n## Library Usage\n- Request additional libraries in `onLoad` by returning an array of module names\n- Available libraries:\n  - imports : [object Object]\n- Only use the explicitly provided libraries\n\n## Security Restrictions\n- Do not use browser dialog functions (`prompt()`, `alert()`, `confirm()`)\n- Avoid any methods that could compromise security or user experience\n\n\n<view-model-schema>\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"title\": {\n      \"type\": \"string\",\n      \"title\": \"Title\",\n      \"description\": \"Title of the task\",\n      \"default\": \"New Task\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"title\": \"Description\",\n      \"description\": \"Details about the task\",\n      \"default\": \"\"\n    },\n    \"doomLevel\": {\n      \"type\": \"integer\",\n      \"title\": \"Doom Level\",\n      \"description\": \"Severity or consequence level of the task\",\n      \"default\": 1,\n      \"minimum\": 1\n    },\n    \"completed\": {\n      \"type\": \"boolean\",\n      \"title\": \"Completed\",\n      \"description\": \"Whether the task is completed\",\n      \"default\": false\n    }\n  },\n  \"title\": \"Todo List of Doom\",\n  \"description\": \"A todo list to manage tasks with a darkly themed \\\"doom level\\\" that emphasizes urgency and consequences.\"\n}\n</view-model-schema>\n\n<guide>\n# SDK Usage Guide\n\n## 1. `useDoc` Hook\n\nThe `useDoc` hook binds to a reactive cell given key and returns a tuple `[doc, setDoc]`:\n\nAny keys from the view-model-schema are valid for useDoc, any other keys will fail. Provide a default as the second argument, **do not set an initial value explicitly**.\n\nFor this schema:\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"counter\": {\n      \"type\": \"number\",\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"default\": \"My Counter App\"\n    }\n  }\n}\n```\n\n```jsx\nfunction CounterComponent() {\n  // Correct: useDoc called at top level of component\n  const [counter, setCounter] = useDoc(\"counter\", -1); // default\n\n  // Incorrect: would cause errors\n  // if(something) {\n  //   const [data, setData] = useDoc(\"data\", {}); // Never do this!\n  // }\n\n  const onIncrement = useCallback(() => {\n    // writing to the cell automatically triggers a re-render\n    setCounter(counter + 1);\n  }, [counter]);\n\n  return (\n    <button onClick={onIncrement}>\n      Increment\n    </button>\n  );\n}\n```\n\n## 2. llm Function\n\n```jsx\nasync function fetchLLMResponse() {\n  // place user-level requirements in system prompt\n  const promptPayload = {\n    system: 'Translate all the messages to emojis, reply in JSON.',\n    messages: ['Hi', 'How can I help you today?', 'tell me a joke']\n  };\n  const result = await llm(promptPayload)\n  console.log('LLM responded:', result);\n}\n```\n\n\n## 3. llm Function with JSON\n\nIf you need JSON to be returned from the LLM, you can enable the `mode: 'json'`\nin the `promptPayload`. However, if you do this, you'll need to make sure you\ndefine the schema you expect from the JSON response. Do this as plain english.\n\nFor example: \"Generate a traditional Vietnamese recipe in JSON format, with the\nfollowing properties: name (string), ingredients (array of strings),\ninstructions (array of strings)\"\n\nNOTE: You'll need to parse the result string into an object using `JSON.parse()`.\n\nANOTHER NOTE: Language model requests are globally cached based on your prompt.\nThis means that identical requests will return the same result. If your llm use\nrequires unique results on every request, make sure to introduce a cache-breaking\nstring such as a timestamp or incrementing number/id.\n\n```jsx\nconst promptPayload = {\n  system: 'Translate all the messages to emojis, reply in JSON with the following properties: an array of objects, each with original_text (string), emoji_translation (string)',\n  messages: ['Hi', 'How can I help you today?', 'tell me a joke'],\n  mode: 'json'\n};\nconst result = await llm(promptPayload);\nconsole.log('JSON response from llm:', JSON.parse(result));\n```\n\nThis `result` variable will be a stringified JSON object. Once you JSON.parse() it, you'll get the following object:\n\n[\n    {\n        \"original_text\": \"Hi\",\n        \"emoji_translation\": \"üëã\"\n    },\n    {\n        \"original_text\": \"How can I help you today?\",\n        \"emoji_translation\": \"ü§î‚ùìüôã‚Äç‚ôÇÔ∏èüìÖ\"\n    },\n    {\n        \"original_text\": \"tell me a joke\",\n        \"emoji_translation\": \"üó£Ô∏èüëâüòÇ\"\n    }\n]\n\nAnother example:\n\n```jsx\n// Every time we run this prompt, we want a unique result, so we'll use a cache-breaking string.\nconst cacheBreaker = Date.now();\n\nconst promptPayload = {\n  system: \"You are a professional chef specializing in Mexican cuisine. Generate a detailed, authentic Mexican recipe in JSON format with the following properties: title (string), ingredients (array of strings), instructions (array of strings), prepTime (integer in minutes), cookTime (integer in minutes)\",\n  messages :[\"give me something spicy!\" + \" \" + cacheBreaker],\n  mode: \"json\",\n};\nconst result = await llm(promptPayload);\nconsole.log('JSON response from llm:', JSON.parse(result));\n```\n\nThe `result` variable will be a stringified JSON object. Once you JSON.parse() it, you'll get the following object:\n\n{\n    \"title\": \"Camarones a la Diabla (Devil Shrimp)\",\n    \"ingredients\": [\n        \"1.5 lbs Large Shrimp, peeled and deveined\",\n        \"4 tbsp Olive Oil\",\n        \"1 medium White Onion, finely chopped\",\n        \"4 cloves Garlic, minced\",\n        \"2-3 Habanero Peppers, finely chopped (adjust to your spice preference, remove seeds for less heat)\",\n        \"1 (28 oz) can Crushed Tomatoes\",\n        \"1/2 cup Chicken Broth\",\n        \"2 tbsp Tomato Paste\",\n        \"1 tbsp Apple Cider Vinegar\",\n        \"1 tbsp Dried Oregano\",\n        \"1 tsp Cumin\",\n        \"1/2 tsp Smoked Paprika\",\n        \"1/4 tsp Ground Cloves\",\n        \"Salt and Black Pepper to taste\",\n        \"Fresh Cilantro, chopped, for garnish\",\n        \"Lime wedges, for serving\"\n    ],\n    \"instructions\": [\n        \"In a large bowl, toss the shrimp with salt and pepper.\",\n        \"Heat the olive oil in a large skillet or Dutch oven over medium-high heat.\",\n        \"Add the onion and cook until softened, about 5 minutes.\",\n        \"Add the garlic and habanero peppers and cook for 1 minute more, until fragrant.\",\n        \"Stir in the crushed tomatoes, chicken broth, tomato paste, apple cider vinegar, oregano, cumin, smoked paprika, and cloves.\",\n        \"Bring the sauce to a simmer and cook for 15 minutes, stirring occasionally, until slightly thickened.\",\n        \"Add the shrimp to the sauce and cook for 3-5 minutes, or until the shrimp are pink and cooked through.\",\n        \"Taste and adjust seasoning with salt and pepper as needed.\",\n        \"Garnish with fresh cilantro and serve immediately with lime wedges. Serve with rice or tortillas.\"\n    ],\n    \"prepTime\": 20,\n    \"cookTime\": 30\n}\n\n## 4. readWebpage Function\n\n```jsx\nasync function fetchFromUrl() {\n  const url = 'https://twopm.studio';\n  const result = await readWebpage(url);\n  console.log('Markdown:', result.content);\n}\n```\n\n## 5. generateImage Function\n\n```jsx\nfunction ImageComponent() {\n  return <img src={generateImage(\"A beautiful sunset over mountains\")} alt=\"Generated landscape\" />;\n}\n\n```\n## 6. Using the Interface Functions\n\n```javascript\n// Import from modern ESM libraries:\n//   - react\n//   - react-dom\n//   - react-dom/client\n//   - d3\n//   - moment\n//   - marked\n//   - @react-spring/web\n//   - @use-gesture/react\n//   - uuid\n//   - tone\nfunction onLoad() {\n  return ['@react-spring/web']; // Request the modules you need\n}\n\nconst title = 'My ESM App';\nfunction ImageComponent({ url }) {\n  return <img src={url} alt=\"Generated landscape\" />;\n}\n\nfunction MyComponent({ label, description }) {\n  return (\n    <div>\n      <h2>{label}</h2>\n      <p>{description}</p>\n      <ImageComponent url={generateImage(\"A beautiful sunset over mountains\")} />\n    </div>\n  );\n}\n\nfunction TodoItem({ todo, onToggle, onDelete }) {\n  return (\n    <div className=\"flex items-center p-2 border-b\">\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={onToggle}\n        className=\"mr-2\"\n      />\n      <span className={`flex-grow ${todo.completed ? 'line-through text-gray-500' : ''}`}>\n        {todo.text}\n      </span>\n      <button\n        onClick={onDelete}\n        className=\"px-2 py-1 bg-red-500 text-white rounded\"\n      >\n        Delete\n      </button>\n    </div>\n  );\n}\n\nfunction TodoList({ todo, setTodos}) {\n  const [newTodo, setNewTodo] = React.useState('');\n\n  const addTodo = () => {\n    if (newTodo.trim() === '') return;\n\n    const newTodoItem = {\n      id: Date.now(),\n      text: newTodo,\n      completed: false\n    };\n\n    setTodos([...todos, newTodoItem]);\n    setNewTodo('');\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(todos.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    ));\n  };\n\n  const deleteTodo = (id) => {\n    setTodos(todos.filter(todo => todo.id !== id));\n  };\n\n  return (\n    <div className=\"max-w-md mx-auto mt-4 p-4 bg-white rounded shadow\">\n      <h2 className=\"text-xl font-bold mb-4\">Todo List</h2>\n\n      <div className=\"flex mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          placeholder=\"Add a new todo\"\n          className=\"flex-grow p-2 border rounded-l\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded-r\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"border rounded\">\n        {todos.length > 0 ? (\n          todos.map(todo => (\n            <TodoItem\n              key={todo.id}\n              todo={todo}\n              onToggle={() => toggleTodo(todo.id)}\n              onDelete={() => deleteTodo(todo.id)}\n            />\n          ))\n        ) : (\n          <p className=\"p-2 text-center text-gray-500\">No todos yet!</p>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Main application code with modules passed as third parameter\nfunction onReady(mount, sourceData, libs) {\n  const { useState, useEffect } = React; // React is available globally\n  const { useSpring, animated } = libs['@react-spring/web']; // Access imported module\n\n  function MyApp() {\n    const [count, setCount] = useDoc('count', 0);\n    const [todos, setTodos] = useDoc('todos', [\n      { id: 1, text: 'Learn React', completed: false },\n      { id: 2, text: 'Build a Todo App', completed: false }\n    ]);\n    const props = useSpring({\n      from: { opacity: 0 },\n      to: { opacity: 1 }\n    });\n\n    return (\n      <div className=\"p-4\">\n        <animated.div style={props}>\n          <button\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded\"\n            onClick={() => setCount(count + 1)}\n          >\n            Clicks: {count}\n          </button>\n        </animated.div>\n        <TodoList todos={todos} setTodos={setTodos} />\n      </div>\n    );\n  }\n\n  // Use the client API for React 18\n  const root = ReactDOM.createRoot(mount);\n  root.render(<MyApp />);\n}\n```\n</guide>\n",
  "messages": [
    {
      "role": "user",
      "content": "The user asked you to create the source code with the following specification:\n```\n<REQUEST>\n<goal>todo list of doom</goal>\n<plan><step>Define the core concept and theme of the \"todo list of doom,\" emphasizing a dark, humorous, or challenging twist on a traditional todo list.</step>\n<step>Design the data model to include tasks with attributes such as title, description, priority, and a \"doom level\" or consequence indicator to reflect the severity or difficulty of each task.</step>\n<step>Implement functionality to add, edit, and delete tasks, ensuring that the \"doom level\" influences task presentation or behavior (e.g., visual styling, reminders, or penalties for overdue tasks).</step>\n<step>Create a user interface that visually reinforces the \"doom\" theme, using appropriate colors, fonts, and icons to enhance user engagement and convey the mood.</step>\n<step>Add features that increase the challenge or stakes of task completion, such as countdown timers, escalating consequences for missed tasks, or gamified elements that reward or punish based on task status.</step></plan>\n<description>The \"todo list of doom\" charm is a task management tool designed to transform the traditional todo list experience into a darkly themed, engaging, and challenging productivity aid. It allows users to create and manage tasks with an added \"doom level\" attribute that signifies the severity or consequences of not completing a task on time. This charm visually and functionally emphasizes the urgency and stakes of each task, using thematic design elements and interactive features to motivate users. By integrating countdowns, escalating penalties, and gamification, it helps users prioritize and complete tasks more effectively while enjoying a unique, immersive experience. This charm is built from scratch to provide a novel take on task management, differing from standard todo lists by focusing on the emotional and motivational impact of task consequences.</description>\n<data>\"add(title: string, description: string, doomLevel: integer) -> TodoItem(title, description, doomLevel, completed: boolean)\\nedit(item: TodoItem, { title?: string, description?: string, doomLevel?: integer, completed?: boolean }) -> TodoItem\\ndelete(item: TodoItem) -> void\\nlist() -> TodoItem[]\\nmarkCompleted(item: TodoItem) -> TodoItem(completed: true)\\n\\nThe charm uses the doomLevel property to influence task urgency, visual styling, and consequence mechanics.\"</data>\n</REQUEST>\n<PLAN>1. Define the TodoItem data model with properties: title, description, doomLevel, and completed status.  \n2. Implement basic CRUD operations: add, edit, delete, and mark tasks as completed, using the doomLevel to influence task ordering or styling.  \n3. Create a simple UI that lists tasks with visual emphasis on doomLevel (e.g., color intensity) and allows users to manage tasks easily.</PLAN>\n<SPEC>This todo list allows users to add, edit, and delete tasks, each with a title, optional description, and a numeric doom level indicating the severity or consequence of not completing the task. Tasks can be marked as completed. The doom level influences how tasks are presented, prioritizing higher doom levels visually or functionally. The minimal data model captures task title, description, doom level, and completion status to support core functionality and future thematic enhancements.</SPEC>\n```\n\nby following the following steps:\n1. Define the core concept and theme of the \"todo list of doom,\" emphasizing a dark, humorous, or challenging twist on a traditional todo list.\n2. Design the data model to include tasks with attributes such as title, description, priority, and a \"doom level\" or consequence indicator to reflect the severity or difficulty of each task.\n3. Implement functionality to add, edit, and delete tasks, ensuring that the \"doom level\" influences task presentation or behavior (e.g., visual styling, reminders, or penalties for overdue tasks).\n4. Create a user interface that visually reinforces the \"doom\" theme, using appropriate colors, fonts, and icons to enhance user engagement and convey the mood.\n5. Add features that increase the challenge or stakes of task completion, such as countdown timers, escalating consequences for missed tasks, or gamified elements that reward or punish based on task status."
    },
    {
      "role": "assistant",
      "content": "function onLoad() {\n  // No external libraries needed for this implementation\n  return [];\n}\n\nconst title = 'Todo List of Doom';\n\nfunction DoomLevelIndicator({ level }) {\n  // Show skull emojis to represent doom level (max 5 shown)\n  const count = Math.min(level, 5);\n  return (\n    <span aria-label={`Doom level ${level}`} title={`Doom level ${level}`}>\n      {'üíÄ'.repeat(count)}\n    </span>\n  );\n}\n\nfunction TaskItem({ task, onToggleComplete, onEdit, onDelete }) {\n  // Determine styling based on doomLevel and completion\n  // Higher doomLevel => more intense red background\n  // Completed tasks are grayed out with line-through\n  const baseRedIntensity = Math.min(task.doomLevel * 40, 200);\n  const bgColor = task.completed\n    ? 'bg-gray-800 text-gray-400 line-through'\n    : `bg-red-${baseRedIntensity} text-white`;\n\n  // Tailwind doesn't support dynamic class names for colors,\n  // so we use inline style for background color with a red shade\n  // We'll map doomLevel 1-10 to a red shade from light to dark\n  const redShade = 255 - Math.min(task.doomLevel * 20, 200);\n  const style = task.completed\n    ? { backgroundColor: '#2d2d2d', color: '#9ca3af', textDecoration: 'line-through' }\n    : { backgroundColor: `rgb(255,${redShade},${redShade})`, color: '#330000' };\n\n  return (\n    <div\n      className=\"flex flex-col md:flex-row md:items-center justify-between p-3 mb-2 rounded shadow-md\"\n      style={style}\n    >\n      <div className=\"flex flex-col flex-grow min-w-0\">\n        <div className=\"flex items-center space-x-2\">\n          <input\n            type=\"checkbox\"\n            checked={task.completed}\n            onChange={onToggleComplete}\n            className=\"w-5 h-5 cursor-pointer\"\n            aria-label={`Mark task \"${task.title}\" as completed`}\n          />\n          <h3 className=\"font-bold truncate\">{task.title}</h3>\n          <DoomLevelIndicator level={task.doomLevel} />\n        </div>\n        {task.description && (\n          <p className=\"text-sm mt-1 truncate whitespace-pre-wrap\">{task.description}</p>\n        )}\n      </div>\n      <div className=\"flex space-x-2 mt-2 md:mt-0 md:ml-4\">\n        <button\n          onClick={onEdit}\n          className=\"px-2 py-1 bg-yellow-600 hover:bg-yellow-700 rounded text-sm font-semibold\"\n          aria-label={`Edit task \"${task.title}\"`}\n          type=\"button\"\n        >\n          ‚úèÔ∏è Edit\n        </button>\n        <button\n          onClick={onDelete}\n          className=\"px-2 py-1 bg-gray-900 hover:bg-gray-800 rounded text-sm font-semibold\"\n          aria-label={`Delete task \"${task.title}\"`}\n          type=\"button\"\n        >\n          üóëÔ∏è Delete\n        </button>\n      </div>\n    </div>\n  );\n}\n\nfunction TaskForm({ onSave, onCancel, initial }) {\n  // initial: { title, description, doomLevel }\n  const [title, setTitle] = React.useState(initial?.title || '');\n  const [description, setDescription] = React.useState(initial?.description || '');\n  const [doomLevel, setDoomLevel] = React.useState(initial?.doomLevel || 1);\n\n  // Validate title non-empty and doomLevel >=1\n  const canSave = title.trim() !== '' && doomLevel >= 1;\n\n  return (\n    <form\n      onClick={e => e.stopPropagation()}\n      className=\"bg-gray-900 p-4 rounded shadow-lg max-w-md mx-auto\"\n      onSubmit={e => e.preventDefault()}\n      aria-label={initial ? 'Edit task form' : 'Add new task form'}\n    >\n      <div className=\"mb-3\">\n        <label htmlFor=\"title\" className=\"block font-semibold mb-1\">\n          Task Title <span className=\"text-red-500\">*</span>\n        </label>\n        <input\n          id=\"title\"\n          type=\"text\"\n          value={title}\n          onChange={e => setTitle(e.target.value)}\n          className=\"w-full p-2 rounded bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-red-600\"\n          placeholder=\"Enter task title\"\n          required\n          maxLength={100}\n          autoFocus\n        />\n      </div>\n      <div className=\"mb-3\">\n        <label htmlFor=\"description\" className=\"block font-semibold mb-1\">\n          Description\n        </label>\n        <textarea\n          id=\"description\"\n          value={description}\n          onChange={e => setDescription(e.target.value)}\n          className=\"w-full p-2 rounded bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-red-600\"\n          placeholder=\"Optional details about the task\"\n          rows={3}\n          maxLength={500}\n        />\n      </div>\n      <div className=\"mb-4\">\n        <label htmlFor=\"doomLevel\" className=\"block font-semibold mb-1\">\n          Doom Level (Severity) <span className=\"text-red-500\">*</span>\n        </label>\n        <input\n          id=\"doomLevel\"\n          type=\"number\"\n          min={1}\n          max={10}\n          value={doomLevel}\n          onChange={e => {\n            const val = Number(e.target.value);\n            if (val >= 1 && val <= 10) setDoomLevel(val);\n          }}\n          className=\"w-20 p-2 rounded bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-red-600\"\n          aria-describedby=\"doomLevelHelp\"\n          required\n        />\n        <small id=\"doomLevelHelp\" className=\"text-gray-400\">\n          1 (low doom) to 10 (maximum doom)\n        </small>\n      </div>\n      <div className=\"flex justify-end space-x-2\">\n        <button\n          type=\"button\"\n          onClick={onCancel}\n          className=\"px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded\"\n        >\n          Cancel\n        </button>\n        <button\n          type=\"button\"\n          onClick={() => onSave({ title: title.trim(), description: description.trim(), doomLevel })}\n          disabled={!canSave}\n          className={`px-4 py-2 rounded font-semibold ${\n            canSave ? 'bg-red-700 hover:bg-red-800 text-white' : 'bg-red-900 text-gray-600 cursor-not-allowed'\n          }`}\n        >\n          {initial ? 'Save Changes' : 'Add Task'}\n        </button>\n      </div>\n    </form>\n  );\n}\n\nfunction CountdownTimer({ secondsLeft, onExpire }) {\n  // Show countdown in mm:ss format\n  const [timeLeft, setTimeLeft] = React.useState(secondsLeft);\n\n  React.useEffect(() => {\n    if (timeLeft <= 0) {\n      onExpire();\n      return;\n    }\n    const timerId = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);\n    return () => clearTimeout(timerId);\n  }, [timeLeft, onExpire]);\n\n  const minutes = Math.floor(timeLeft / 60);\n  const seconds = timeLeft % 60;\n\n  return (\n    <span className=\"font-mono text-sm text-yellow-300\" aria-live=\"polite\" aria-atomic=\"true\">\n      ‚è≥ {minutes}:{seconds.toString().padStart(2, '0')}\n    </span>\n  );\n}\n\nfunction DoomListApp() {\n  // Use useDoc for persistent state per schema keys\n  // We'll store tasks as an array of objects with properties:\n  // title, description, doomLevel, completed, id, createdAt, dueAt (optional)\n  // The schema only defines title, description, doomLevel, completed,\n  // so we store tasks as an array in a single doc key \"tasks\"\n  // But schema does not define \"tasks\" key, so we must store each task separately?\n  // The schema only defines title, description, doomLevel, completed as keys,\n  // but those are for a single task. We need to store multiple tasks.\n  // The instructions say useDoc only for keys in schema.\n  // So we must store tasks as an array in a single key \"tasks\" is not allowed.\n  // We'll store tasks in a single key \"tasks\" anyway, but since schema doesn't allow,\n  // we must store tasks in React state only (ephemeral).\n  // But the instructions say useDoc only for persistent state and must draw from schema.\n  // The schema is for a single task, so we can store the current editing task in useDoc,\n  // but the list of tasks must be ephemeral state.\n  // We'll store tasks in React.useState (ephemeral).\n  // For persistence, we can store tasks in localStorage or not persist at all.\n  // The instructions do not mention persistence beyond useDoc.\n  // So we implement ephemeral task list in React state.\n\n  // We'll keep a list of tasks in React state.\n  // Each task: { id, title, description, doomLevel, completed, createdAt, dueAt, penaltyCount }\n  // We'll add a dueAt time for countdown challenge: tasks must be completed within 5 minutes of creation.\n  // Penalty count increments each time task expires uncompleted.\n\n  const [tasks, setTasks] = React.useState(() => {\n    // Initialize empty list\n    return [];\n  });\n\n  // For editing, store the task being edited or null\n  const [editingTask, setEditingTask] = React.useState(null);\n  // For adding new task, show form or not\n  const [adding, setAdding] = React.useState(false);\n\n  // Sort tasks by doomLevel descending, then by createdAt ascending\n  const sortedTasks = React.useMemo(() => {\n    return [...tasks].sort((a, b) => {\n      if (b.doomLevel !== a.doomLevel) return b.doomLevel - a.doomLevel;\n      return a.createdAt - b.createdAt;\n    });\n  }, [tasks]);\n\n  // Add new task handler\n  function addTask({ title, description, doomLevel }) {\n    const now = Date.now();\n    const newTask = {\n      id: now,\n      title,\n      description,\n      doomLevel,\n      completed: false,\n      createdAt: now,\n      dueAt: now + 5 * 60 * 1000, // 5 minutes from creation\n      penaltyCount: 0,\n    };\n    setTasks(prev => [...prev, newTask]);\n    setAdding(false);\n  }\n\n  // Edit existing task handler\n  function editTask(id, updates) {\n    setTasks(prev =>\n      prev.map(t => (t.id === id ? { ...t, ...updates } : t))\n    );\n    setEditingTask(null);\n  }\n\n  // Delete task handler\n  function deleteTask(id) {\n    setTasks(prev => prev.filter(t => t.id !== id));\n  }\n\n  // Toggle completed status\n  function toggleCompleted(id) {\n    setTasks(prev =>\n      prev.map(t =>\n        t.id === id\n          ? {\n              ...t,\n              completed: !t.completed,\n              // If marking completed, reset penaltyCount\n              penaltyCount: !t.completed ? 0 : t.penaltyCount,\n            }\n          : t\n      )\n    );\n  }\n\n  // Handle countdown expiration for a task\n  function onTaskExpire(id) {\n    setTasks(prev =>\n      prev.map(t => {\n        if (t.id === id && !t.completed) {\n          // Increase penalty count and extend dueAt by 2 minutes\n          const newPenalty = (t.penaltyCount || 0) + 1;\n          const newDueAt = Date.now() + 2 * 60 * 1000;\n          return { ...t, penaltyCount: newPenalty, dueAt: newDueAt };\n        }\n        return t;\n      })\n    );\n  }\n\n  // Visual penalty effect: tasks with penaltyCount > 0 get a shaking animation or warning text\n  // We'll add a red blinking border for penaltyCount >=1\n\n  return (\n    <main className=\"min-h-screen bg-gradient-to-b from-black via-gray-900 to-black text-white p-6 font-sans select-none\">\n      <header className=\"max-w-3xl mx-auto mb-6 text-center\">\n        <h1 className=\"text-4xl font-extrabold mb-2 tracking-wide\">\n          ‚ò†Ô∏è Todo List of Doom ‚ò†Ô∏è\n        </h1>\n        <p className=\"text-gray-400 max-w-xl mx-auto\">\n          Manage your tasks with a dark twist. Beware the doom level and the ticking clock!\n        </p>\n      </header>\n\n      <section className=\"max-w-3xl mx-auto\">\n        {!adding && !editingTask && (\n          <div className=\"flex justify-center mb-6\">\n            <button\n              onClick={() => setAdding(true)}\n              className=\"px-6 py-3 bg-red-800 hover:bg-red-900 rounded font-bold text-lg tracking-wide shadow-lg\"\n              type=\"button\"\n              aria-label=\"Add new doom task\"\n            >\n              + Add Doom Task\n            </button>\n          </div>\n        )}\n\n        {(adding || editingTask) && (\n          <TaskForm\n            initial={editingTask}\n            onCancel={() => {\n              setAdding(false);\n              setEditingTask(null);\n            }}\n            onSave={data => {\n              if (editingTask) {\n                editTask(editingTask.id, data);\n              } else {\n                addTask(data);\n              }\n            }}\n          />\n        )}\n\n        {sortedTasks.length === 0 && !adding && !editingTask && (\n          <p className=\"text-center text-gray-500 italic mt-12\">\n            No doom tasks yet. Add one and face your fate!\n          </p>\n        )}\n\n        <div className=\"space-y-3\">\n          {sortedTasks.map(task => {\n            const now = Date.now();\n            const timeLeftSeconds = Math.max(0, Math.floor((task.dueAt - now) / 1000));\n            const isExpired = timeLeftSeconds === 0 && !task.completed;\n\n            return (\n              <div\n                key={task.id}\n                className={`rounded-md shadow-md ${\n                  task.penaltyCount > 0 && !task.completed\n                    ? 'ring-4 ring-red-600 animate-pulse'\n                    : ''\n                }`}\n                aria-live=\"polite\"\n              >\n                <TaskItem\n                  task={task}\n                  onToggleComplete={() => toggleCompleted(task.id)}\n                  onEdit={() => setEditingTask(task)}\n                  onDelete={() => deleteTask(task.id)}\n                />\n                {!task.completed && (\n                  <div className=\"flex justify-between items-center px-4 pb-2 text-yellow-300 font-mono text-sm select-text\">\n                    {isExpired ? (\n                      <span role=\"alert\" aria-live=\"assertive\" className=\"font-bold\">\n                        ‚ö†Ô∏è Doom timer expired! Penalty increased: {task.penaltyCount}\n                      </span>\n                    ) : (\n                      <CountdownTimer\n                        secondsLeft={timeLeftSeconds}\n                        onExpire={() => onTaskExpire(task.id)}\n                      />\n                    )}\n                    <span className=\"italic text-xs text-gray-400 select-none\">\n                      Created: {new Date(task.createdAt).toLocaleTimeString()}\n                    </span>\n                  </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      </section>\n\n      <footer className=\"max-w-3xl mx-auto mt-12 text-center text-gray-600 text-xs select-none\">\n        <p>\n          Made with dark humor and a pinch of doom. Complete your tasks before they complete you.\n        </p>\n      </footer>\n    </main>\n  );\n}\n\nfunction onReady(mount, sourceData, libs) {\n  const root = ReactDOM.createRoot(mount);\n  root.render(<DoomListApp />);\n}\n```"
    }
  ],
  "stop": "\n```",
  "maxTokens": 32767
}