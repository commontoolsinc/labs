{
  "model": "anthropic:claude-3-7-sonnet-latest",
  "system": "# React Component Builder\n\nCreate an interactive React component that fulfills the user's request. Focus on delivering a clean, useful implementation with appropriate features.\n\n## You Are Part of a Two-Phase Process\n\n1. First phase (already completed):\n   - Analyzed the user's request\n   - Created a detailed specification\n   - Generated a structured data schema\n\n2. Your job (second phase):\n   - Create a reactive UI component based on the provided specification and schema\n   - Implement the UI exactly according to the specification\n   - Strictly adhere to the data schema provided\n\n## Required Elements\n- Define a title with `const title = 'Your App Name';`\n- Implement both `onLoad` and `onReady` functions\n- Use Tailwind CSS for styling with tasteful defaults\n- Do not write <svg> inline, use emoji for icons\n- Carefully avoid infinite loops and recursion that may cause performance issues\n\n## Code Structure\n1. React and ReactDOM are pre-imported - don't import them again\n2. All React hooks must be namespaced (e.g., `React.useState`, `React.useEffect`)\n3. Follow React hooks rules - never nest or conditionally call hooks\n4. For form handling, use `onClick` handlers instead of `onSubmit`\n\n## Available APIs\n- **useDoc(key, defaultValue)** - Persistent data storage with reactive updates\n- **llm(promptPayload)** - Send requests to the language model\n- **readWebpage(url)** - Fetch and parse external web content\n- **generateImage(prompt)** - Create AI-generated images\n\n## Important Note About useDoc\n- **useDoc is a React Hook** and must follow all React hook rules\n- It should only be used for persistent state and must draw from the provided schema\n  - For any ephemeral state, use `React.useState`\n- Only call useDoc at the top level of your function components or custom hooks\n- Do not call useDoc inside loops, conditions, or nested functions\n- useDoc cannot be used outside of `onReady` components - it must be called during rendering\n\n## Library Usage\n- Request additional libraries in `onLoad` by returning an array of module names\n- Available libraries:\n  - imports : [object Object]\n- Only use the explicitly provided libraries\n\n## Security Restrictions\n- Do not use browser dialog functions (`prompt()`, `alert()`, `confirm()`)\n- Avoid any methods that could compromise security or user experience\n\n\n<view-model-schema>\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"values\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"count\": {\n      \"type\": \"integer\",\n      \"title\": \"Count\",\n      \"description\": \"Number of elements counted in the input\",\n      \"default\": 0\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"title\": \"Data Type\",\n      \"description\": \"Type of the input data that was counted\",\n      \"enum\": [\n        \"array\",\n        \"object\",\n        \"string\",\n        \"number\",\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"source\": {\n      \"type\": \"string\",\n      \"title\": \"Source\",\n      \"description\": \"Description of what was counted\",\n      \"default\": \"values\"\n    },\n    \"details\": {\n      \"type\": \"object\",\n      \"title\": \"Count Details\",\n      \"description\": \"Additional details about the count operation\",\n      \"properties\": {\n        \"isEmpty\": {\n          \"type\": \"boolean\",\n          \"title\": \"Is Empty\",\n          \"description\": \"Whether the input contains no elements\"\n        }\n      }\n    }\n  },\n  \"title\": \"Value Counter Charm\",\n  \"description\": \"A charm to count elements in the current data structure.\"\n}\n</view-model-schema>\n\n<guide>\n# SDK Usage Guide\n\n## 1. `useDoc` Hook\n\nThe `useDoc` hook binds to a reactive cell given key and returns a tuple `[doc, setDoc]`:\n\nAny keys from the view-model-schema are valid for useDoc, any other keys will fail. Provide a default as the second argument, **do not set an initial value explicitly**.\n\nFor this schema:\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"counter\": {\n      \"type\": \"number\",\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"default\": \"My Counter App\"\n    }\n  }\n}\n```\n\n```jsx\nfunction CounterComponent() {\n  // Correct: useDoc called at top level of component\n  const [counter, setCounter] = useDoc(\"counter\", -1); // default\n\n  // Incorrect: would cause errors\n  // if(something) {\n  //   const [data, setData] = useDoc(\"data\", {}); // Never do this!\n  // }\n\n  const onIncrement = useCallback(() => {\n    // writing to the cell automatically triggers a re-render\n    setCounter(counter + 1);\n  }, [counter]);\n\n  return (\n    <button onClick={onIncrement}>\n      Increment\n    </button>\n  );\n}\n```\n\n## 2. llm Function\n\n```jsx\nasync function fetchLLMResponse() {\n  // place user-level requirements in system prompt\n  const promptPayload = {\n    system: 'Translate all the messages to emojis, reply in JSON.',\n    messages: ['Hi', 'How can I help you today?', 'tell me a joke']\n  };\n  const result = await llm(promptPayload)\n  console.log('LLM responded:', result);\n}\n```\n\nIf you need JSON to be returned from the LLM, you can enable the `mode: 'json'` in the `promptPayload`.\n\n```jsx\nconst promptPayload = {\n  system: 'Translate all the messages to emojis, reply in JSON.',\n  messages: ['Hi', 'How can I help you today?', 'tell me a joke'],\n  mode: 'json'\n};\nconst result = await llm(promptPayload);\nconsole.log('JSON response from llm:', result);\n```\n\n## 3. readWebpage Function\n\n```jsx\nasync function fetchFromUrl() {\n  const url = 'https://twopm.studio';\n  const result = await readWebpage(url);\n  console.log('Markdown:', result.content);\n}\n```\n\n## 4. generateImage Function\n\n```jsx\nfunction ImageComponent() {\n  return <img src={generateImage(\"A beautiful sunset over mountains\")} alt=\"Generated landscape\" />;\n}\n\n```\n## 5. Using the Interface Functions\n\n```javascript\n// Import from modern ESM libraries:\n//   - react\n//   - react-dom\n//   - react-dom/client\n//   - d3\n//   - moment\n//   - marked\n//   - @react-spring/web\n//   - @use-gesture/react\n//   - uuid\n//   - tone\nfunction onLoad() {\n  return ['@react-spring/web']; // Request the modules you need\n}\n\nconst title = 'My ESM App';\nfunction ImageComponent({ url }) {\n  return <img src={url} alt=\"Generated landscape\" />;\n}\n\nfunction MyComponent({ label, description }) {\n  return (\n    <div>\n      <h2>{label}</h2>\n      <p>{description}</p>\n      <ImageComponent url={generateImage(\"A beautiful sunset over mountains\")} />\n    </div>\n  );\n}\n\nfunction TodoItem({ todo, onToggle, onDelete }) {\n  return (\n    <div className=\"flex items-center p-2 border-b\">\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={onToggle}\n        className=\"mr-2\"\n      />\n      <span className={`flex-grow ${todo.completed ? 'line-through text-gray-500' : ''}`}>\n        {todo.text}\n      </span>\n      <button\n        onClick={onDelete}\n        className=\"px-2 py-1 bg-red-500 text-white rounded\"\n      >\n        Delete\n      </button>\n    </div>\n  );\n}\n\nfunction TodoList({ todo, setTodos}) {\n  const [newTodo, setNewTodo] = React.useState('');\n\n  const addTodo = () => {\n    if (newTodo.trim() === '') return;\n\n    const newTodoItem = {\n      id: Date.now(),\n      text: newTodo,\n      completed: false\n    };\n\n    setTodos([...todos, newTodoItem]);\n    setNewTodo('');\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(todos.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    ));\n  };\n\n  const deleteTodo = (id) => {\n    setTodos(todos.filter(todo => todo.id !== id));\n  };\n\n  return (\n    <div className=\"max-w-md mx-auto mt-4 p-4 bg-white rounded shadow\">\n      <h2 className=\"text-xl font-bold mb-4\">Todo List</h2>\n\n      <div className=\"flex mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          placeholder=\"Add a new todo\"\n          className=\"flex-grow p-2 border rounded-l\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded-r\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"border rounded\">\n        {todos.length > 0 ? (\n          todos.map(todo => (\n            <TodoItem\n              key={todo.id}\n              todo={todo}\n              onToggle={() => toggleTodo(todo.id)}\n              onDelete={() => deleteTodo(todo.id)}\n            />\n          ))\n        ) : (\n          <p className=\"p-2 text-center text-gray-500\">No todos yet!</p>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Main application code with modules passed as third parameter\nfunction onReady(mount, sourceData, libs) {\n  const { useState, useEffect } = React; // React is available globally\n  const { useSpring, animated } = libs['@react-spring/web']; // Access imported module\n\n  function MyApp() {\n    const [count, setCount] = useDoc('count', 0);\n    const [todos, setTodos] = useDoc('todos', [\n      { id: 1, text: 'Learn React', completed: false },\n      { id: 2, text: 'Build a Todo App', completed: false }\n    ]);\n    const props = useSpring({\n      from: { opacity: 0 },\n      to: { opacity: 1 }\n    });\n\n    return (\n      <div className=\"p-4\">\n        <animated.div style={props}>\n          <button\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded\"\n            onClick={() => setCount(count + 1)}\n          >\n            Clicks: {count}\n          </button>\n        </animated.div>\n        <TodoList todos={todos} setTodos={setTodos} />\n      </div>\n    );\n  }\n\n  // Use the client API for React 18\n  const root = ReactDOM.createRoot(mount);\n  root.render(<MyApp />);\n}\n```\n</guide>\n",
  "messages": [
    {
      "role": "user",
      "content": "The user asked you to create the source code with the following specification:\n```\n<REQUEST>\n<goal>count the values in current</goal>\n<plan><step>Analyze the user's request to understand what \"count the values in current\" means in this context</step>\n<step>Design a simple charm that can count values in an array or object</step>\n<step>Implement the core counting logic to handle different data types (arrays, objects, strings)</step>\n<step>Create a user-friendly output format that displays the count results</step>\n<step>Add error handling for invalid inputs and edge cases</step></plan>\n<description>This charm counts the values in the provided input data. It analyzes the input and returns a count of elements based on the data type. For arrays, it counts the number of elements. For objects, it counts the number of key-value pairs. For strings, it counts the number of characters. For numbers, it simply returns 1 (as a single value). The charm provides a simple way to get a quick count of elements in any data structure, which is useful for data analysis, validation, or debugging purposes. The output includes both the count and the type of data that was counted to provide context.</description>\n<data>\"Input: Any → can be array, object, string, number, boolean, or null\\nProcess: Input → analyze type → count elements → format output\\nOutput: { count: number, type: string, [details]: object }\\n\\nThe charm processes data by:\\n1. Determining the type of the input data\\n2. Counting elements based on the type:\\n   - Arrays: number of elements\\n   - Objects: number of key-value pairs\\n   - Strings: number of characters\\n   - Other primitives: count as 1\\n3. Returning a structured result with the count and type information\\n\\nFor complex nested structures, the charm can optionally provide detailed counts of nested elements.\"</data>\n</REQUEST>\n<PLAN>1. Analyze the input data to determine its type (array, object, string, or primitive)\n2. Count the elements based on the identified type using the existing schema structure\n3. Return a formatted result with the count, type, and optional details</PLAN>\n<SPEC>This charm analyzes the input data and returns the count of elements based on the data type. It will count the number of elements in arrays, key-value pairs in objects, characters in strings, or return 1 for primitive values. The charm will work with the existing schema that contains a \"values\" array property, and will provide a simple count result with type information.</SPEC>\n```"
    },
    {
      "role": "assistant",
      "content": "\nfunction onLoad() {\n  return []; // No additional libraries needed\n}\n\nconst title = 'Value Counter Charm';\n\nfunction onReady(mount, sourceData) {\n  function ValueCounter() {\n    // State management using the schema\n    const [values, setValues] = React.useState([]);\n    const [count, setCount] = useDoc('count', 0);\n    const [type, setType] = useDoc('type', '');\n    const [source, setSource] = useDoc('source', 'values');\n    const [details, setDetails] = useDoc('details', { isEmpty: true });\n    \n    // Input state\n    const [inputValue, setInputValue] = React.useState('');\n    const [error, setError] = React.useState('');\n\n    // Function to count values based on input type\n    const countValues = (input) => {\n      try {\n        let parsedInput;\n        \n        // Try to parse as JSON if it's a string\n        if (typeof input === 'string' && (input.startsWith('[') || input.startsWith('{'))) {\n          try {\n            parsedInput = JSON.parse(input);\n          } catch (e) {\n            // If parsing fails, treat as regular string\n            parsedInput = input;\n          }\n        } else {\n          parsedInput = input;\n        }\n        \n        // Determine type and count\n        let countResult = 0;\n        let typeResult = '';\n        let sourceDesc = '';\n        let isEmpty = false;\n        \n        if (Array.isArray(parsedInput)) {\n          countResult = parsedInput.length;\n          typeResult = 'array';\n          sourceDesc = 'array elements';\n          isEmpty = countResult === 0;\n          setValues(parsedInput.map(item => JSON.stringify(item)));\n        } else if (parsedInput !== null && typeof parsedInput === 'object') {\n          const keys = Object.keys(parsedInput);\n          countResult = keys.length;\n          typeResult = 'object';\n          sourceDesc = 'object properties';\n          isEmpty = countResult === 0;\n          setValues(keys.map(key => `${key}: ${JSON.stringify(parsedInput[key])}`));\n        } else if (typeof parsedInput === 'string') {\n          countResult = parsedInput.length;\n          typeResult = 'string';\n          sourceDesc = 'characters';\n          isEmpty = countResult === 0;\n          setValues([...parsedInput].map(char => char));\n        } else if (typeof parsedInput === 'number') {\n          countResult = 1;\n          typeResult = 'number';\n          sourceDesc = 'numeric value';\n          isEmpty = false;\n          setValues([parsedInput.toString()]);\n        } else if (typeof parsedInput === 'boolean') {\n          countResult = 1;\n          typeResult = 'boolean';\n          sourceDesc = 'boolean value';\n          isEmpty = false;\n          setValues([parsedInput.toString()]);\n        } else if (parsedInput === null) {\n          countResult = 0;\n          typeResult = 'null';\n          sourceDesc = 'null value';\n          isEmpty = true;\n          setValues([]);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        \n        // Update state with results\n        setCount(countResult);\n        setType(typeResult);\n        setSource(sourceDesc);\n        setDetails({ isEmpty });\n        setError('');\n      } catch (err) {\n        setError(`Error processing input: ${err.message}`);\n      }\n    };\n\n    // Handle form submission\n    const handleSubmit = () => {\n      if (!inputValue.trim()) {\n        setError('Please enter a value to count');\n        return;\n      }\n      \n      countValues(inputValue);\n    };\n\n    // Handle example clicks\n    const handleExampleClick = (example) => {\n      setInputValue(example);\n      countValues(example);\n    };\n\n    return (\n      <div className=\"max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-md\">\n        <h1 className=\"text-2xl font-bold text-gray-800 mb-4\">{title}</h1>\n        <p className=\"text-gray-600 mb-6\">\n          Count elements in different data structures. Enter an array, object, string, or primitive value.\n        </p>\n        \n        {/* Input section */}\n        <div className=\"mb-6\">\n          <label htmlFor=\"input\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n            Enter value to count:\n          </label>\n          <textarea\n            id=\"input\"\n            className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500\"\n            rows=\"4\"\n            value={inputValue}\n            onChange={(e) => setInputValue(e.target.value)}\n            placeholder='Enter a value like [1,2,3] or {\"a\":1,\"b\":2} or \"hello\"'\n          />\n          \n          {error && (\n            <p className=\"mt-2 text-sm text-red-600\">{error}</p>\n          )}\n          \n          <button\n            onClick={handleSubmit}\n            className=\"mt-3 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\"\n          >\n            Count Values\n          </button>\n        </div>\n        \n        {/* Examples */}\n        <div className=\"mb-6\">\n          <h3 className=\"text-sm font-medium text-gray-700 mb-2\">Try examples:</h3>\n          <div className=\"flex flex-wrap gap-2\">\n            <button \n              onClick={() => handleExampleClick('[1, 2, 3, 4, 5]')}\n              className=\"px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md text-sm\"\n            >\n              Array\n            </button>\n            <button \n              onClick={() => handleExampleClick('{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}')}\n              className=\"px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md text-sm\"\n            >\n              Object\n            </button>\n            <button \n              onClick={() => handleExampleClick('Hello World')}\n              className=\"px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md text-sm\"\n            >\n              String\n            </button>\n            <button \n              onClick={() => handleExampleClick('42')}\n              className=\"px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md text-sm\"\n            >\n              Number\n            </button>\n            <button \n              onClick={() => handleExampleClick('true')}\n              className=\"px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md text-sm\"\n            >\n              Boolean\n            </button>\n            <button \n              onClick={() => handleExampleClick('null')}\n              className=\"px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded-md text-sm\"\n            >\n              Null\n            </button>\n          </div>\n        </div>\n        \n        {/* Results section */}\n        {type && (\n          <div className=\"bg-gray-50 p-4 rounded-md border border-gray-200\">\n            <h2 className=\"text-lg font-semibold text-gray-800 mb-3\">Results</h2>\n            \n            <div className=\"grid grid-cols-2 gap-4\">\n              <div className=\"bg-white p-3 rounded shadow-sm\">\n                <h3 className=\"text-sm font-medium text-gray-500\">Count</h3>\n                <p className=\"text-2xl font-bold text-indigo-600\">{count}</p>\n                <p className=\"text-xs text-gray-500\">Number of {source}</p>\n              </div>\n              \n              <div className=\"bg-white p-3 rounded shadow-sm\">\n                <h3 className=\"text-sm font-medium text-gray-500\">Type</h3>\n                <p className=\"text-lg font-semibold text-gray-800\">{type}</p>\n                <p className=\"text-xs text-gray-500\">\n                  {details.isEmpty ? 'Empty' : 'Non-empty'} {type}\n                </p>\n              </div>\n            </div>\n            \n            {values.length > 0 && (\n              <div className=\"mt-4\">\n                <h3 className=\"text-sm font-medium text-gray-700 mb-2\">Values:</h3>\n                <div className=\"bg-white p-3 rounded border border-gray-200 max-h-40 overflow-y-auto\">\n                  {values.map((value, index) => (\n                    <div key={index} className=\"text-sm py-1 border-b border-gray-100 last:border-0\">\n                      {index}: {value}\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Render the component\n  const root = ReactDOM.createRoot(mount);\n  root.render(<ValueCounter />);\n}\n```"
    }
  ],
  "stop": "\n```",
  "stream": false
}