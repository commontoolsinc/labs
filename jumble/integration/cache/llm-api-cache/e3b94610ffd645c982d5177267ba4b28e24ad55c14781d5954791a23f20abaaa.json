{
  "model": "anthropic:claude-3-7-sonnet-latest",
  "system": "# React Component Builder\n\nCreate an interactive React component that fulfills the user's request. Focus on delivering a clean, useful implementation with appropriate features.\n\n## You Are Part of a Two-Phase Process\n\n1. First phase (already completed):\n   - Analyzed the user's request\n   - Created a detailed specification\n   - Generated a structured data schema\n\n2. Your job (second phase):\n   - Create a reactive UI component based on the provided specification and schema\n   - Implement the UI exactly according to the specification\n   - Strictly adhere to the data schema provided\n\n## Required Elements\n- Define a title with `const title = 'Your App Name';`\n- Implement both `onLoad` and `onReady` functions\n- Use Tailwind CSS for styling with tasteful defaults\n- Do not write <svg> inline, use emoji for icons\n- Carefully avoid infinite loops and recursion that may cause performance issues\n\n## Code Structure\n1. React and ReactDOM are pre-imported - don't import them again\n2. All React hooks must be namespaced (e.g., `React.useState`, `React.useEffect`)\n3. Follow React hooks rules - never nest or conditionally call hooks\n4. For form handling, use `onClick` handlers instead of `onSubmit`\n\n## Available APIs\n- **useDoc(key, defaultValue)** - Persistent data storage with reactive updates\n- **llm(promptPayload)** - Send requests to the language model\n- **readWebpage(url)** - Fetch and parse external web content\n- **generateImage(prompt)** - Create AI-generated images\n\n## Important Note About useDoc\n- **useDoc is a React Hook** and must follow all React hook rules\n- It should only be used for persistent state and must draw from the provided schema\n  - For any ephemeral state, use `React.useState`\n- Only call useDoc at the top level of your function components or custom hooks\n- Do not call useDoc inside loops, conditions, or nested functions\n- useDoc cannot be used outside of `onReady` components - it must be called during rendering\n\n## Library Usage\n- Request additional libraries in `onLoad` by returning an array of module names\n- Available libraries:\n  - imports : [object Object]\n- Only use the explicitly provided libraries\n\n## Security Restrictions\n- Do not use browser dialog functions (`prompt()`, `alert()`, `confirm()`)\n- Avoid any methods that could compromise security or user experience\n\n\n<view-model-schema>\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"values\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"count\": {\n      \"type\": \"integer\",\n      \"title\": \"Count\",\n      \"description\": \"Number of values in the array\",\n      \"default\": 0\n    }\n  },\n  \"title\": \"Value Counter Charm\",\n  \"description\": \"A charm to count the number of values in the current data structure.\"\n}\n</view-model-schema>\n\n<guide>\n# SDK Usage Guide\n\n## 1. `useDoc` Hook\n\nThe `useDoc` hook binds to a reactive cell given key and returns a tuple `[doc, setDoc]`:\n\nAny keys from the view-model-schema are valid for useDoc, any other keys will fail. Provide a default as the second argument, **do not set an initial value explicitly**.\n\nFor this schema:\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"counter\": {\n      \"type\": \"number\",\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"default\": \"My Counter App\"\n    }\n  }\n}\n```\n\n```jsx\nfunction CounterComponent() {\n  // Correct: useDoc called at top level of component\n  const [counter, setCounter] = useDoc(\"counter\", -1); // default\n\n  // Incorrect: would cause errors\n  // if(something) {\n  //   const [data, setData] = useDoc(\"data\", {}); // Never do this!\n  // }\n\n  const onIncrement = useCallback(() => {\n    // writing to the cell automatically triggers a re-render\n    setCounter(counter + 1);\n  }, [counter]);\n\n  return (\n    <button onClick={onIncrement}>\n      Increment\n    </button>\n  );\n}\n```\n\n## 2. llm Function\n\n```jsx\nasync function fetchLLMResponse() {\n  // place user-level requirements in system prompt\n  const promptPayload = {\n    system: 'Translate all the messages to emojis, reply in JSON.',\n    messages: ['Hi', 'How can I help you today?', 'tell me a joke']\n  };\n  const result = await llm(promptPayload)\n  console.log('LLM responded:', result);\n}\n```\n\nIf you need JSON to be returned from the LLM, you can enable the `mode: 'json'` in the `promptPayload`.\n\n```jsx\nconst promptPayload = {\n  system: 'Translate all the messages to emojis, reply in JSON.',\n  messages: ['Hi', 'How can I help you today?', 'tell me a joke'],\n  mode: 'json'\n};\nconst result = await llm(promptPayload);\nconsole.log('JSON response from llm:', result);\n```\n\n## 3. readWebpage Function\n\n```jsx\nasync function fetchFromUrl() {\n  const url = 'https://twopm.studio';\n  const result = await readWebpage(url);\n  console.log('Markdown:', result.content);\n}\n```\n\n## 4. generateImage Function\n\n```jsx\nfunction ImageComponent() {\n  return <img src={generateImage(\"A beautiful sunset over mountains\")} alt=\"Generated landscape\" />;\n}\n\n```\n## 5. Using the Interface Functions\n\n```javascript\n// Import from modern ESM libraries:\n//   - react\n//   - react-dom\n//   - react-dom/client\n//   - d3\n//   - moment\n//   - marked\n//   - @react-spring/web\n//   - @use-gesture/react\n//   - uuid\n//   - tone\nfunction onLoad() {\n  return ['@react-spring/web']; // Request the modules you need\n}\n\nconst title = 'My ESM App';\nfunction ImageComponent({ url }) {\n  return <img src={url} alt=\"Generated landscape\" />;\n}\n\nfunction MyComponent({ label, description }) {\n  return (\n    <div>\n      <h2>{label}</h2>\n      <p>{description}</p>\n      <ImageComponent url={generateImage(\"A beautiful sunset over mountains\")} />\n    </div>\n  );\n}\n\nfunction TodoItem({ todo, onToggle, onDelete }) {\n  return (\n    <div className=\"flex items-center p-2 border-b\">\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={onToggle}\n        className=\"mr-2\"\n      />\n      <span className={`flex-grow ${todo.completed ? 'line-through text-gray-500' : ''}`}>\n        {todo.text}\n      </span>\n      <button\n        onClick={onDelete}\n        className=\"px-2 py-1 bg-red-500 text-white rounded\"\n      >\n        Delete\n      </button>\n    </div>\n  );\n}\n\nfunction TodoList({ todo, setTodos}) {\n  const [newTodo, setNewTodo] = React.useState('');\n\n  const addTodo = () => {\n    if (newTodo.trim() === '') return;\n\n    const newTodoItem = {\n      id: Date.now(),\n      text: newTodo,\n      completed: false\n    };\n\n    setTodos([...todos, newTodoItem]);\n    setNewTodo('');\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(todos.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    ));\n  };\n\n  const deleteTodo = (id) => {\n    setTodos(todos.filter(todo => todo.id !== id));\n  };\n\n  return (\n    <div className=\"max-w-md mx-auto mt-4 p-4 bg-white rounded shadow\">\n      <h2 className=\"text-xl font-bold mb-4\">Todo List</h2>\n\n      <div className=\"flex mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          placeholder=\"Add a new todo\"\n          className=\"flex-grow p-2 border rounded-l\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded-r\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"border rounded\">\n        {todos.length > 0 ? (\n          todos.map(todo => (\n            <TodoItem\n              key={todo.id}\n              todo={todo}\n              onToggle={() => toggleTodo(todo.id)}\n              onDelete={() => deleteTodo(todo.id)}\n            />\n          ))\n        ) : (\n          <p className=\"p-2 text-center text-gray-500\">No todos yet!</p>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Main application code with modules passed as third parameter\nfunction onReady(mount, sourceData, libs) {\n  const { useState, useEffect } = React; // React is available globally\n  const { useSpring, animated } = libs['@react-spring/web']; // Access imported module\n\n  function MyApp() {\n    const [count, setCount] = useDoc('count', 0);\n    const [todos, setTodos] = useDoc('todos', [\n      { id: 1, text: 'Learn React', completed: false },\n      { id: 2, text: 'Build a Todo App', completed: false }\n    ]);\n    const props = useSpring({\n      from: { opacity: 0 },\n      to: { opacity: 1 }\n    });\n\n    return (\n      <div className=\"p-4\">\n        <animated.div style={props}>\n          <button\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded\"\n            onClick={() => setCount(count + 1)}\n          >\n            Clicks: {count}\n          </button>\n        </animated.div>\n        <TodoList todos={todos} setTodos={setTodos} />\n      </div>\n    );\n  }\n\n  // Use the client API for React 18\n  const root = ReactDOM.createRoot(mount);\n  root.render(<MyApp />);\n}\n```\n</guide>\n",
  "messages": [
    {
      "role": "user",
      "content": "The user asked you to create the source code with the following specification:\n```\n<REQUEST>\n<goal>count the values in current</goal>\n<plan><step>Analyze the user's request to understand what \"count the values in current\" means in this context</step>\n<step>Design a simple charm that counts values in an array or object</step>\n<step>Define the input/output data model for the charm</step>\n<step>Plan the implementation logic to handle different data types (arrays, objects, etc.)</step>\n<step>Consider edge cases like empty inputs, non-countable inputs, etc.</step></plan>\n<description>This charm will count the values in the input data provided to it. The purpose is to analyze the input and return a count of its elements or properties. For arrays, it will count the number of elements. For objects, it will count the number of properties. For strings, it will count the number of characters. For other primitive values (numbers, booleans, null), it will return 0 or 1 depending on whether the value exists. This charm provides a simple utility function that can be useful in data analysis, validation, or when making decisions based on the size of data structures.</description>\n<data>\"Input: any → can be array, object, string, number, boolean, or null\\nProcess: Count elements/properties/characters based on input type\\nOutput: number → the count of values\\n\\nProcessing flow:\\n- Array input [a, b, c] → Count: 3\\n- Object input {a: 1, b: 2} → Count: 2\\n- String input \\\"hello\\\" → Count: 5\\n- Number input 42 → Count: 1\\n- Boolean input true → Count: 1\\n- Null input null → Count: 0\\n- Undefined input undefined → Count: 0\"</data>\n</REQUEST>\n<PLAN>1. Extract the \"values\" array from the input data\n2. Count the number of elements in the array\n3. Return an object with the count and the original values</PLAN>\n<SPEC>This charm will count the number of elements in the \"values\" array from the existing schema. It will return a simple object containing the count of values and the original values array for reference. The charm handles empty arrays gracefully by returning a count of zero.</SPEC>\n```\n\nby following the following steps:\n1. Analyze the user's request to understand what \"count the values in current\" means in this context\n2. Design a simple charm that counts values in an array or object\n3. Define the input/output data model for the charm\n4. Plan the implementation logic to handle different data types (arrays, objects, etc.)\n5. Consider edge cases like empty inputs, non-countable inputs, etc."
    },
    {
      "role": "assistant",
      "content": "\nfunction onLoad() {\n  return [];\n}\n\nconst title = 'Value Counter Charm';\n\nfunction onReady(mount, sourceData) {\n  function ValueCounter() {\n    // Use the schema-defined properties with appropriate defaults\n    const [values, setValues] = useDoc(\"values\", []);\n    const [count, setCount] = useDoc(\"count\", 0);\n    \n    // Local state for new value input\n    const [newValue, setNewValue] = React.useState(\"\");\n    \n    // Update count whenever values change\n    React.useEffect(() => {\n      setCount(values.length);\n    }, [values, setCount]);\n    \n    // Add a new value to the array\n    const handleAddValue = () => {\n      if (newValue.trim() !== \"\") {\n        setValues([...values, newValue]);\n        setNewValue(\"\");\n      }\n    };\n    \n    // Remove a value from the array\n    const handleRemoveValue = (index) => {\n      const newValues = [...values];\n      newValues.splice(index, 1);\n      setValues(newValues);\n    };\n    \n    // Clear all values\n    const handleClearValues = () => {\n      setValues([]);\n    };\n    \n    return (\n      <div className=\"max-w-md mx-auto p-6 bg-white rounded-lg shadow-lg\">\n        <h1 className=\"text-2xl font-bold text-center mb-6 text-indigo-700\">{title}</h1>\n        \n        <div className=\"mb-6 p-4 bg-indigo-50 rounded-lg\">\n          <div className=\"flex items-center justify-between\">\n            <h2 className=\"text-lg font-semibold text-indigo-800\">Values Count</h2>\n            <span className=\"text-2xl font-bold text-indigo-600 bg-white px-4 py-2 rounded-full shadow-sm\">\n              {count}\n            </span>\n          </div>\n        </div>\n        \n        <div className=\"mb-6\">\n          <div className=\"flex mb-2\">\n            <input\n              type=\"text\"\n              value={newValue}\n              onChange={(e) => setNewValue(e.target.value)}\n              placeholder=\"Add a new value\"\n              className=\"flex-grow p-2 border border-gray-300 rounded-l focus:outline-none focus:ring-2 focus:ring-indigo-500\"\n            />\n            <button\n              onClick={handleAddValue}\n              className=\"bg-indigo-600 text-white px-4 py-2 rounded-r hover:bg-indigo-700 transition-colors\"\n            >\n              Add\n            </button>\n          </div>\n          \n          <button\n            onClick={handleClearValues}\n            className=\"w-full bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-colors\"\n            disabled={values.length === 0}\n          >\n            Clear All\n          </button>\n        </div>\n        \n        <div className=\"border border-gray-200 rounded-lg overflow-hidden\">\n          <h3 className=\"bg-gray-100 px-4 py-2 font-medium\">Values List</h3>\n          \n          {values.length > 0 ? (\n            <ul className=\"divide-y divide-gray-200\">\n              {values.map((value, index) => (\n                <li key={index} className=\"px-4 py-3 flex justify-between items-center\">\n                  <span className=\"text-gray-800\">{value}</span>\n                  <button\n                    onClick={() => handleRemoveValue(index)}\n                    className=\"text-red-500 hover:text-red-700\"\n                  >\n                    🗑️\n                  </button>\n                </li>\n              ))}\n            </ul>\n          ) : (\n            <div className=\"px-4 py-8 text-center text-gray-500\">\n              No values added yet. Add some values to see the count.\n            </div>\n          )}\n        </div>\n        \n        <div className=\"mt-6 text-sm text-gray-600\">\n          <p>This charm counts the number of values in the array. Add or remove values to see the count update automatically.</p>\n        </div>\n      </div>\n    );\n  }\n\n  // Render the component\n  const root = ReactDOM.createRoot(mount);\n  root.render(<ValueCounter />);\n}\n```"
    }
  ],
  "stop": "\n```",
  "stream": false
}