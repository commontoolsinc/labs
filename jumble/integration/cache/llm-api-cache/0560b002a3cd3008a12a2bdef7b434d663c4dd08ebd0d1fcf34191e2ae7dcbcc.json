{
  "system": "You are a helpful AI assistant tasked with planning code generation workflows",
  "messages": [
    {
      "role": "user",
      "content": "\nYou are creating a brief execution plan and specification for a tool to fulfill a user's intent.\nThe user's request has been classified as a IMAGINE operation.\n\nUser's request: \"count the values in `simpleValue2`\"\n\n<current-charm-context>\nNo existing charm context available.\n</current-charm-context>\n\nBased on the workflow type, follow these guidelines:\n\n- FIX workflow:\n  * PURPOSE: Fix bugs without changing functionality\n  * SPEC: Keep existing specification exactly as-is\n  * SCHEMA: No schema changes needed\n  * CODE: Focus solely on fixing the implementation\n\n- EDIT workflow:\n  * PURPOSE: Enhance functionality within existing data structure\n  * SPEC: Build upon the existing specification\n  * SCHEMA: Can add properties but never remove existing ones\n  * CODE: Modify implementation while maintaining backward compatibility\n\n- IMAGINE workflow:\n  * PURPOSE: Create new functionality, possibly using existing charms as sources\n  * SPEC: Write a fresh specification, possibly referencing existing ones\n  * SCHEMA: Will receive combined input schema, generate output schemas\n  * CODE: Create a new implementation that may use data from other charms\n\nPlease create a medium-detail plan with BOTH a step-by-step execution plan AND a clear specification.\nAlways include all XML tags in your response and ensure JSON schemas are correctly formatted.\n\nRespond in the following format:\n\n(include ~5 steps)\n<steps>\n1. First step of the plan\n2. Second step of the plan\n3. ...\n</steps>\n\n(include ~1 paragraph)\n<specification>\nA clear description of what the charm does, its purpose, and functionality.\nInclude a clear explanation of how it works and what problems it solves.\nFor EDIT and IMAGINE, explain how it builds upon or differs from the existing charm.\n</specification>\n\n<data_model>\nList key actions and the data types they affect.\ne.g add(title, description) -> TodoItem(title, description, completed)\nedit(item: TodoItem, { description, title, completed }) -> TodoItem(title, description, completed)\ndelete(item: TodoItem) -> void\n\nInclude how this charm uses any referenced data.\n</data_model>\n\nDO NOT GENERATE A SCHEMA.\n"
    },
    {
      "role": "assistant",
      "content": "<steps>\n1. Analyze the user's request to count values in `simpleValue2`\n2. Design a function that can count values in an array or object\n3. Create a utility that handles different data types (arrays, objects, strings)\n4. Implement error handling for invalid inputs\n5. Format the output to clearly display the count results\n</steps>\n\n<specification>\nThis charm counts the values in a variable named `simpleValue2`. It analyzes the provided data structure and returns a count of its elements. For arrays, it counts the number of items; for objects, it counts the number of properties; for strings, it counts the characters; and for other primitive values, it returns appropriate descriptive information. The charm handles various data types gracefully and provides clear, formatted output with the count results. This is a new utility charm that performs a simple but useful data analysis function.\n</specification>\n\n<data_model>\ncount(simpleValue2: any) -> CountResult\n- If simpleValue2 is an array: Returns the number of elements in the array\n- If simpleValue2 is an object: Returns the number of properties in the object\n- If simpleValue2 is a string: Returns the number of characters in the string\n- If simpleValue2 is a number, boolean, null, or undefined: Returns a description of the value type\n\nThe CountResult will include:\n- count: number (the count of elements/properties/characters)\n- type: string (the data type of simpleValue2)\n- description: string (human-readable description of what was counted)\n</data_model>"
    }
  ],
  "model": "anthropic:claude-3-7-sonnet-latest",
  "maxTokens": 64000
}