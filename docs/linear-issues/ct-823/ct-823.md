# CT-823: Runtime Conflicts During Multi-Tab Chat

## Issue Summary

**Priority:** Urgent  
**Status:** In Progress  
**Assignee:** Ellyse Cedeno  
**Linear Issue:** https://linear.app/common-tools/issue/CT-823/runtime-conflicts-during-multi-tab-chat  
**Git Branch:** ellyse/ct-823-runtime-conflicts-during-multi-tab-chat  

## Problem Description

When users have multiple tabs open with the chat application and alternate sending messages between tabs, the system experiences runtime conflicts that **breaks the recipe functionality** until full browser refresh:
- The recipe stops accepting new inputs after conflicts occur
- Messages randomly disappear from the UI
- Cross-tab synchronization failures where one tab continues updating while others stall
- Frequent ConflictError exceptions being logged
- **Critical:** The charm becomes completely non-functional and requires a page reload

## Reproduction Steps

1. Open Chat State Container and create a User Session
2. Open another tab/window and create another User Session
3. Alternate typing short messages between the two tabs (no usernames needed)
4. Within a few messages, observe conflicts and inconsistent UI updates

## Key Terminology

### Cell
A `Cell<T>` is a reactive data container in CommonTools that provides methods for reading and writing data with automatic synchronization. It supports operations like `get()`, `set()`, `push()` for arrays, and `key()` for nested property access.

### Memory Space
A logical storage boundary that contains facts (data) and manages transactions. Each space maintains its own state and handles synchronization with remote storage.

### Fact
An immutable piece of data stored in a memory space. Facts have addresses, schemas, and values. They form the basis of the content-addressable storage system.

### Transaction
A unit of work that groups multiple read/write operations together. Transactions ensure consistency and can be committed or rolled back as a whole.

### ConflictError
An error thrown when a transaction attempts to modify data that has been changed by another transaction since it was read. Contains information about the expected vs actual state.

### Nursery
A temporary storage area for pending changes that haven't been committed to the remote storage yet. Facts in the nursery are tentative and can be purged if conflicts occur.

## Technical Analysis

### Error Manifestation

The primary error occurs in **packages/runner/src/storage/cache.ts:1105**:

```
[ERROR][storage.cache] Transaction failed ConflictError: The application/json of of:... but it does not exist
```

This error is thrown when the transaction commit process detects a conflict between the expected state and the actual state in the storage system.

### Core Components Involved

#### 1. Chat Recipe Implementation
**File:** `packages/runner/integration/ct-823-chat-rapid-conflicts.tsx`

The test recipe implements a simple message sharing system modified for conflict reproduction:
- **Line 78-86:** `sendMessage` handler pushes 20 messages rapidly to a shared array
- **Line 89-98:** `setUsername` handler updates user names
- **Line 176-182:** Creates user sessions with shared message references

#### 2. Cell Push Operation
**File:** `packages/runner/src/cell.ts`

The `push()` method implementation (lines 506-555):
- **Line 509:** Requires an active transaction
- **Line 513:** Initiates sync if not already synced
- **Line 549-555:** Performs `diffAndUpdate` to append values to the array

#### 3. Storage Cache Layer
**File:** `packages/runner/src/storage/cache.ts`

Transaction commit logic (lines 1080-1129):
- **Line 1081-1086:** Commits changes to remote storage
- **Line 1099-1106:** Handles ConflictError detection and logging
- **Line 1113:** Purges rejected changes from nursery
- **Line 1123-1129:** Notifies subscribers about reverted transactions

#### 4. Conflict Detection
**File:** `packages/memory/error.ts`

ConflictError implementation (lines 43-80):
- **Line 58:** Error when expected fact doesn't exist
- **Line 60-65:** Error when fact exists but with different value than expected

#### 5. Cross-Tab Communication
**File:** `packages/runner/src/storage/inspector.ts`

BroadcastChannel implementation (lines 125-168):
- **Line 137:** Creates BroadcastChannel named "inspector"
- **Line 144-146:** Posts messages to other tabs
- **Line 156-161:** Filters and processes incoming messages

## Root Cause Analysis

### The Real Issue: Recipe Breaking vs. Conflict Handling

ConflictErrors are expected and normally handled gracefully by the CommonTools runtime. Other recipes like `array-in-cell-with-remove-editable.tsx` experience conflicts but continue functioning correctly with eventual consistency. The chat recipe, however, **completely breaks** after conflicts.

### Key Difference: Reactive Cell References in Arrays

**Working Recipe** (`array-in-cell-with-remove-editable.tsx`):
```typescript
// Simple push with self-contained data
state.items.push({ text: event.detail.message });
```

**Broken Recipe** (`chat-user-sessions.tsx`):
```typescript
// Push with cross-Cell reference
messages.push({
  author: user.get(),  // Appears to store reactive reference, not just value
  message: text,
  timestamp: Date.now(),
});
```

### Critical Discovery: Reactive References Are Being Stored

**Evidence of reactivity:**
1. **Retroactive updates**: When a user changes their username, ALL their previous messages in the array update to show the new name
2. **Cross-tab reactivity**: Username changes are reflected in all tabs, for all historical messages
3. **The stored data is reactive**: Despite calling `user.get()`, the system maintains a reactive connection

This means the CommonTools runtime is storing reactive Cell references or bindings in the array, not just static values. This is actually a powerful feature that enables reactive patterns, but it appears to break during conflict resolution.

### Observed Behavior After Conflicts

**What we can observe:**
1. The UI continues to render (existing messages and input fields are visible)
2. Input fields accept typing (the DOM elements are functional)
3. Clicking "Send" or pressing enter does not add new messages to the list
4. The recipe remains in this broken state until a full browser refresh
5. ConflictError logs appear in the console before the breakage

**What appears to be happening (hypotheses):**

1. **Reactive Binding Corruption:** The runtime stores reactive Cell references/bindings in the messages array, and these reactive connections are severed during conflict resolution

2. **Potential failure points after conflict:**
   - **Reactive binding theory:** The reactive connections between the `user` Cell and messages array entries are broken
   - **Transaction rollback theory:** Rolling back transactions with reactive references corrupts the Cell state
   - **Reference restoration theory:** The runtime cannot properly restore complex reactive relationships after conflicts
   - **Event dispatch theory:** The `onmessagesend` event might not be reaching the handler
   - **Handler execution theory:** The handler might be called but failing silently

3. **Why this recipe specifically breaks:**
   - The recipe stores reactive Cell references in an array (via `user.get()` which maintains reactivity)
   - During conflict resolution, these reactive bindings cannot be properly rolled back or restored
   - The `array-in-cell-with-remove-editable.tsx` recipe works because it stores simple, non-reactive values
   - The complex reactive graph created by Cell-in-array patterns exceeds the runtime's conflict recovery capabilities

### Architecture Context

The chat recipe creates a unique situation:
- **Line 174:** Messages Cell is shared across all user sessions
- **Line 175:** User Cell is created locally for each session
- **Lines 78-82:** The handler crosses boundaries between local and shared Cells
- This cross-boundary operation during mutations appears to break the runtime's ability to recover from conflicts

## Affected Modules and Classes

### Primary Components
- **StorageCache** (`packages/runner/src/storage/cache.ts`): Manages transaction commits and conflict resolution
- **Cell** (`packages/runner/src/cell.ts`): Implements reactive data operations including array push
- **StorageTransaction** (`packages/runner/src/storage/transaction.ts`): Handles transaction lifecycle
- **Channel** (`packages/runner/src/storage/inspector.ts`): Manages cross-tab communication via BroadcastChannel

### Secondary Components
- **MemorySpace** (`packages/memory/space.ts`): Validates facts and detects conflicts
- **ConflictError** (`packages/memory/error.ts`): Error representation for conflicts
- **Journal** (`packages/runner/src/storage/transaction/journal.ts`): Tracks transaction changes

## Possible Solutions

### Approach 1: Remove Reactive References (NOT Recommended - Workaround Only)
**Important:** This approach should NOT be the solution as it removes a powerful feature that SHOULD work.

Store static values instead of reactive references to avoid the issue:
```typescript
// Force non-reactive value storage
const currentUser = { ...user.get() };  // Clone to break reactivity
messages.push({
  author: currentUser,  // Static snapshot, loses reactivity
  message: text,
  timestamp: Date.now(),
});
```

**Why this is not ideal:**
- Removes the reactive update feature (username changes won't update historical messages)
- Works around the problem instead of fixing it
- Other developers will encounter this issue when using legitimate reactive patterns
- The system is designed to support reactive Cell references in arrays

**Implementation areas:**
- Modify `ct-823-chat-rapid-conflicts.tsx:78-86` to store static values
- This would be a temporary workaround, not a proper fix

### Approach 2: Debug and Fix the Actual Failure Point
Investigate where exactly the recipe breaks after conflicts:
- Add logging to determine if handlers are being called
- Check if Cell operations are failing silently
- Verify event dispatch is working correctly
- Identify if transactions are being created/rejected

**Implementation areas:**
- Add debug logging to `ct-823-chat-rapid-conflicts.tsx:78-86` handler execution
- Trace `storage/cache.ts:1123-1129` revert notification handling
- Monitor Cell state and transaction creation in `cell.ts:509-555`
- Check event dispatch mechanism for `onmessagesend`

### Approach 3: Fix Reactive Reference Recovery in Conflict Resolution (Recommended)
Enhance the runtime's conflict resolution to properly handle reactive Cell references in arrays:
- Preserve reactive bindings during transaction rollback
- Implement proper restoration of Cell-to-Cell references after conflicts
- Ensure the reactive graph remains intact through conflict resolution

**Implementation areas:**
- Fix conflict handling in `storage/cache.ts:1092-1129` to preserve reactive bindings
- Enhance rollback mechanism to handle complex reactive references
- Add reactive binding validation and recovery logic
- Ensure Cell references in arrays maintain their connections after conflicts

### Approach 4: Create Separate Handler Contexts
Instead of sharing handler instances, create isolated handler contexts for each tab:
- Each tab gets its own handler instance with its own Cell bindings
- Avoid shared handler state that can be corrupted by conflicts
- Implement proper handler lifecycle management

**Implementation areas:**
- Modify recipe instantiation in `ct-823-chat-rapid-conflicts.tsx:101-165`
- Implement handler isolation in the recipe runtime
- Add handler state recovery mechanisms

## Recommended Next Steps

1. **Investigation Priority**: Debug the exact failure point (Approach 2)
   - Add logging to trace where the recipe breaks
   - Determine if it's handler, event, or Cell operation failure
   - Understand how reactive bindings are being corrupted

2. **Proper Fix**: Implement reactive reference recovery in conflict resolution (Approach 3)
   - This is a runtime-level fix that preserves the intended reactive behavior
   - Ensures Cell-in-array patterns work correctly through conflicts
   - Maintains the powerful reactive features of CommonTools

3. **Do NOT**: Simply work around by removing reactivity (Approach 1)
   - This would hide the bug rather than fix it
   - Other developers would hit the same issue
   - The reactive Cell-in-array pattern is a legitimate use case that should be supported

4. **Testing**: Create test cases that specifically check:
   - Reactive Cell references stored in arrays
   - Retroactive updates after Cell value changes
   - Conflict resolution with complex reactive graphs
   - Multi-tab scenarios with reactive Cell dependencies

## Acceptance Criteria Validation

To ensure the fix meets acceptance criteria:
- [ ] Alternating messages across two tabs does not produce ConflictError/unknown-subscription logs 
  - Note: ConflictErrors may still occur but should be handled gracefully without breaking the recipe
- [ ] Messages never disappear; both tabs stay in sync without reloads
- [ ] **Critical:** The recipe continues to function after conflicts occur
- [ ] Handlers remain connected and responsive after conflict resolution
- [ ] Soak test (>= 50 alternating sends) remains stable with no recipe breakage

## Test Plan: Multi-Tab Chat Recipe Bug Reproduction

### Test Overview
This test reproduces the bug where the chat recipe completely breaks after experiencing conflicts in a multi-tab scenario. The test demonstrates that the recipe stops accepting new messages after conflicts occur.

### Key Discovery
The bug requires **rapid consecutive operations** to trigger conflicts. MCP Playwright's synchronous nature (seconds between operations) is too slow. The solution is to modify the recipe's handler to send 20 messages in a loop, creating rapid operations from within the recipe itself.

### Setup
1. **Use the test recipe** located at:
   ```
   packages/runner/integration/ct-823-chat-rapid-conflicts.tsx
   ```
   This recipe is pre-modified to send 20 messages per handler call to trigger conflicts.

2. **Deploy the test recipe**:
   ```bash
   # Deploy to localhost
   deno task ct charm new --identity ./my.key --api-url http://127.0.0.1:8000 --space ct823rapid ./packages/runner/integration/ct-823-chat-rapid-conflicts.tsx
   
   # Note the charm ID returned (e.g., baedreietg5zxjwi3xa7srgbd2wmdimwped3xclwwrjgqfjzcti5thh7r3a)
   ```

3. **Important Login Process for MCP Playwright**:
   - When you see the login page, click **"‚ûï Register"** (not Login)
   - Click **"üìù Use Passphrase"**
   - Click **"üîí I've Saved It - Continue"** to proceed
   - This creates a new identity that works for the session

4. Make sure to close browser so we start off fresh.

5. **Launch MCP Playwright and create two user sessions**:
   - **Tab 0:** Navigate to `https://example.com` (dummy tab - workaround for tab switching)
   - **Tab 1:** Navigate to charm URL ‚Üí Register ‚Üí Generate User Session
   - **Tab 2:** New tab ‚Üí Navigate to charm URL ‚Üí Generate User Session (already logged in)
   
**Critical:** Both tabs must be on their USER SESSION pages (not the parent charm) before testing!

### Test Methodology: Triggering the Bug

#### Step 1: Ensure Both Tabs Are Ready
- Both tabs must be on their respective User Session pages
- Both tabs should show the existing message history
- Console should be clear of errors initially

#### Step 2: Send Message from Tab 1
1. Type any short text (e.g., "TEST")
2. Click Send (this triggers 20 rapid push operations)
3. **Note:** You may not see all 20 messages due to conflicts

#### Step 3: Check Tab 2
1. Switch to Tab 2
2. Messages may or may not sync properly
3. Check console for ConflictErrors

#### Step 4: Reload Pages to Trigger Conflicts
1. **Reload Tab 1** - This often triggers multiple ConflictErrors
2. **Observe:** Messages may show corrupted (only timestamps visible)
3. **Reload Tab 2** - May trigger additional conflicts

#### Step 5: Alternate Sending Between Tabs
1. Send message from Tab 1 (triggers 20 pushes)
2. Switch to Tab 2, send message (triggers 20 pushes)
3. Continue alternating
4. **Reload tabs periodically** - This is crucial for triggering the bug

### Expected Bug Manifestation
1. **Console Errors:**
   ```
   [ERROR][storage.cache] Transaction failed ConflictError: The application/json of of:...
   ```
   Multiple ConflictErrors will appear (10-20+ errors)

2. **UI Corruption:**
   - Messages display only timestamps (e.g., "¬∑ 21:37")
   - Usernames and message content disappear
   - New messages may not appear at all

3. **Recipe Breakage:**
   - After sufficient conflicts, the recipe stops accepting new messages
   - The send button clicks but nothing happens
   - Recipe requires full browser refresh to work again

### Successful Reproduction Indicators
- ‚úÖ Multiple ConflictError messages in console (10+)
- ‚úÖ Messages showing only timestamps, no content
- ‚úÖ New messages fail to send after conflicts
- ‚úÖ Recipe becomes non-functional until page refresh

### Test Implementation
The test will be implemented at: `packages/runner/integration/ct-823-reactive-conflicts.test.ts`

Using MCP Playwright commands:
- `browser_navigate` - Navigate to charm URL
- `browser_tabs` - Manage multiple tabs
- `browser_click` - Click buttons
- `browser_type` - Enter text
- `browser_snapshot` - Verify UI state
- `browser_console_messages` - Check for ConflictError logs

## Debugging Investigation

### Debugging Iteration #1

**Hypothesis:**
After ConflictErrors occur during transaction commits, the recipe appears to still function (handlers execute and new messages are added) but the reactive Cell references stored in the messages array become corrupted. Specifically, when `user.get()` is stored in the array and conflicts occur, the reactive binding between the User Cell and the stored reference is severed, resulting in undefined/null values that display as "Invalid Date" or empty content.

**What I'm testing:**
1. Whether handlers are still being called after conflicts occur
2. Whether Cell push operations succeed or fail silently
3. Whether the `user.get()` value is valid at handler execution time
4. Whether transaction creation/commits are happening for new messages after conflicts
5. The state of Cell values and array contents after conflict resolution

**Logging to add:**
1. `ct-823-chat-rapid-conflicts.tsx:78-86` - Log handler entry, user.get() value, and push operation
2. `packages/runner/src/cell.ts:509-555` - Log push operation start/end and any errors
3. `packages/runner/src/storage/cache.ts:1099-1129` - Log conflict details and revert operations
4. `packages/runner/src/storage/transaction.ts` - Log transaction lifecycle

**What to look for in logs:**
- [CT823-HANDLER] entries showing handler execution after conflicts
- [CT823-CELL-PUSH] entries showing push operations and their success/failure
- [CT823-USER-VALUE] entries showing the user.get() value at push time
- [CT823-CONFLICT] entries showing conflict resolution and what gets reverted
- [CT823-TRANSACTION] entries showing transaction creation and commit status

**Search patterns:**
- `grep "\[CT823-HANDLER\]"` - Track handler executions
- `grep "\[CT823-CELL-PUSH\]"` - Track array push operations  
- `grep "\[CT823-USER-VALUE\]"` - Check user Cell values
- `grep "\[CT823-CONFLICT\]"` - Find conflict occurrences and resolutions
- `grep "ConflictError"` - Find all conflict errors
- `grep "\[CT823-TRANSACTION\]"` - Track transaction lifecycle

## Investigation Update - Iterations 6-10 Analysis

### Key Discovery #1: Missing Stable IDs for Array Elements

**Problem:** The test recipe is missing `[ID]` fields on messages pushed to the array, causing different tabs to generate different VDOM IDs for the same logical elements.

**Evidence:**
```typescript
// Current problematic code in ct-823-chat-rapid-conflicts.tsx:
messages.push({
  author: userValue,
  message: `${i}/${text}`,
  timestamp: Date.now(),
  // Missing: [ID]: stable_id
});
```

**Why this matters:**
- Without stable IDs, each tab generates its own VDOM IDs for array elements
- When tabs sync, they try to create objects with different IDs for the same logical message
- This creates unnecessary conflicts and race conditions

**The [ID] mechanism exists** in the codebase (`packages/runner/src/builder/types.ts`) but isn't being used in the test recipe. Other recipes in `recipes/` and `patterns/` use `[ID]` to provide stable identifiers for array elements.

### Key Discovery #2: Content-Addressed ID Conflicts

**Problem:** When both tabs create the same content (e.g., identical message objects), they generate the same content-addressed ID, leading to "already exists" conflicts.

**Evidence from logs:**
- Tab 1 creates object `of:baedreiejnkib6qxo2fddyn...`
- Tab 2 tries to create the same ID (because it has identical content)
- Conflict: "already exists" error

**This is different from the deletion race condition** - it's about two tabs trying to create the same object simultaneously.

### Key Discovery #3: Two Types of Conflicts Observed

**Type 1: "Already exists" conflicts (4 occurrences in iter10)**
- Both tabs try to create the same object ID
- Happens when content is identical (content-addressed storage)
- Example: `of:baedreiejnkib6qxo2fddyn...` created by Tab 1, Tab 2 fails

**Type 2: "Does not exist" conflicts (120 occurrences in iter10)**
- Actions try to update objects that were deleted during conflict resolution
- Timeline: Objects deleted at 15:48:21.711, actions execute at 15:48:22.474
- This is a deletion race condition

### Key Discovery #4: Transaction Reverts Are Wholesale

**What happens during a revert:**
- When a conflict occurs, the ENTIRE transaction (all 41 changes) gets reverted
- The `beforeValue` in the revert represents what the failed transaction expected
- The `afterValue` represents the current memory state
- If `beforeValue` exists but `afterValue` is undefined, it means the object existed in the transaction but not in current memory

**Example from logs:**
```
[CT823-CONFLICT] First change structure:
- 41 objects existed in the failed transaction
- These objects don't exist in current memory anymore
- The entire transaction gets rolled back
```

### What We Still Don't Know

1. **Which specific doc ID is causing the primary conflict?**
   - We see `of:baedreiejnkib6qxo2fddyn...` in conflicts but need to understand what this object represents
   - Is it a message object? A VDOM node? A recipe result object?
   - Need to inspect the actual content of these conflicting objects

2. **Why does the recipe break after conflicts while others don't?**
   - The conflicts themselves are being handled (reverted)
   - But something about the revert process breaks the recipe's ability to accept new messages
   - Is it the reactive bindings? Event handlers? Cell state corruption?

3. **Tab Creation Pattern:**
   - Do both tabs generate the same IDs for identical content? (Yes, for content-addressed objects)
   - But for VDOM elements without stable IDs, do they generate different IDs? (Likely yes)
   - Need to trace ID creation with tab context to confirm

4. **Object Type Identification:**
   - The conflicting objects could be:
     - Message objects (with author, message, timestamp fields)
     - VDOM/UI elements (with type, name, props fields)
     - Recipe result objects (with messages array, messageCount)
     - Reactive bindings (with cell, path fields)
   - Added logging to identify object types, but need to run tests to see

### Enhanced Logging Added

1. **ID Creation Tracking** (`doc-map.ts:createRef`):
   - Logs when entity IDs are created with source preview and cause
   - Shows timestamp to correlate with conflicts
   - Will help identify which tab creates which IDs

2. **URI Conversion Tracking** (`uri-utils.ts:toURI`):
   - Logs when entity IDs are converted to URIs
   - Helps track the full lifecycle of ID creation

3. **Breakpoint-Ready Revert Logging** (`cache.ts`):
   - Added `[CT823-REVERT-BREAKPOINT]` markers for setting debugger breakpoints
   - Shows full change details during reverts
   - Allows inspection of actual objects being reverted

### Next Steps for Investigation

1. **Run test with new logging** to capture:
   - Which tab creates which IDs
   - What types of objects are conflicting
   - The actual content of conflicting objects

2. **Set breakpoint** at revert location to inspect:
   - The full structure of objects being reverted
   - The state of reactive bindings
   - The transaction context during conflicts

3. **Add [ID] fields** to test recipe messages:
   - This should reduce VDOM-related conflicts
   - May not solve the core issue but will reduce noise

4. **Trace handler execution** after conflicts:
   - Confirm if handlers are still being called
   - Check if Cell operations are succeeding
   - Identify where the recipe "breaks"
