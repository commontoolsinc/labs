# CT-865: Chat List Container Implementation

## Issue Overview

**Title:** Chat list container that creates and launches chats  
**Type:** Feature Request  
**Priority:** Medium  
**Status:** In Progress  
**Linear URL:** https://linear.app/common-tools/issue/CT-865

### Description
The task is to create a container recipe that manages a list of chat instances. This container will:
- Display a list of existing chats with their creation timestamps as labels
- Provide a "New chat" button to create new chat instances
- Navigate between the chat list and individual chats
- Store and manage references to chat recipe instances

### Key Requirements
1. **New file location**: `packages/patterns/chat-launcher.tsx`
2. **Empty state**: Show "No chats yet" or empty list with "New chat" button
3. **Chat creation**: Instantiate `chat.tsx` recipe, label with UTC timestamp, navigate to it
4. **Navigation**: Click chat items to navigate back to them
5. **No auto-creation**: Opening chat-list shows empty state (not auto-creating first chat)
6. **Storage**: Maintain list of chat references in the container's state

### Non-Goals
- No rename/delete functionality for chats
- No computed summaries for chat names
- No `currentChat` state management in v1
- No guaranteed sort order requirement

## Key Terms and Concepts

### Recipe
A **recipe** is a reusable component pattern in CommonTools that defines:
- Input schema (what data it receives)
- Output schema (what data it exposes)
- UI rendering logic
- State management logic

### Cell
A **Cell** is a reactive state container that:
- Holds a value that can change over time
- Automatically triggers updates when the value changes
- Can be passed between recipes and components

### Handler
A **handler** is an event processing function that:
- Receives events from UI components
- Has access to recipe state through typed parameters
- Can modify Cell values to update state

### NavigateTo
The **navigateTo** function enables navigation between recipes by:
- Accepting a recipe instance (Cell reference)
- Triggering the runtime's navigation callback
- Replacing the current view with the target recipe

## Source Code Analysis

### 1. Existing Chat Recipe (`packages/patterns/chat.tsx`)

**Location:** `packages/patterns/chat.tsx:1-139`

The existing chat recipe that will be instantiated:
- **Input Type**: `LLMTestInput` with `title` (default: "LLM Test") and `chat` array of messages
- **Core Functionality**: 
  - Uses `llmDialog` hook for LLM interaction (line 64-67)
  - Renders messages in a scrollable container (line 90-112)
  - Handles message sending via `sendMessage` handler (line 35-42)
  - Clear chat functionality via `clearChat` handler (line 44-57)
- **Key Components**:
  - `<ct-screen>`: Main container component
  - `<ct-chat-message>`: Individual message display
  - `<ct-message-input>`: User input component

### 2. Recipe Instantiation Pattern (`packages/patterns/instantiate-recipe.tsx`)

**Location:** `packages/patterns/instantiate-recipe.tsx:1-99`

Demonstrates the pattern for creating and navigating to recipe instances:
- **Counter Recipe Definition**: Lines 43-61 define a simple counter recipe
- **Factory Pattern**: Lines 81-98 show the factory container
- **Key Handler - `newCounter`** (lines 76-79):
  ```typescript
  const newCounter = handler<InputEvent, Record<string, never>>((_, __) => {
    const charm = Counter({ value: Math.round(Math.random() * 10) });
    return navigateTo(charm);
  });
  ```
  This shows how to:
  1. Create a new recipe instance with initial state
  2. Navigate to the created instance using `navigateTo`

### 3. Charm List Pattern (`packages/static/assets/recipes/charm-list.tsx`)

**Location:** `packages/static/assets/recipes/charm-list.tsx:1-116`

Reference implementation for managing a list of recipe references:
- **Input Schema**: Receives `allCharms` array of charm references (lines 15-25)
- **List Management**:
  - Stores array of charm references as Cells
  - Derives count from the array (line 75)
  - Maps over array to render list items (lines 86-108)
- **Navigation Handler - `visit`** (lines 45-47):
  ```typescript
  const visit = handler<{}, { charm: any }>((_, state) => {
    return navigateTo(state.charm);
  }, { proxy: true });
  ```
- **Remove Handler** (lines 50-69): Shows how to modify the charms array

### 4. Navigation System (`packages/runner/src/builtins/navigate-to.ts`)

**Location:** `packages/runner/src/builtins/navigate-to.ts:1-28`

Core navigation implementation:
- Accepts a Cell reference as input
- Calls runtime's `navigateCallback` with the target (line 24)
- Enables seamless transitions between recipe views

### 5. Recipe Manager (`packages/runner/src/recipe-manager.ts`)

**Location:** `packages/runner/src/recipe-manager.ts:1-200+`

Manages recipe registration and metadata:
- **Recipe Registration**: `registerRecipe` method (lines 125-158)
- **Metadata Storage**: Stores recipe source, spec, and parent information
- **Recipe ID Generation**: Creates unique IDs using content hashing (line 148)

## Implementation Approach

### State Structure
The chat-launcher container will need to manage:
```typescript
interface ChatListInput {
  chats: Default<ChatReference[], []>;  // Array of chat recipe references
}

interface ChatReference {
  instance: Cell<any>;  // The chat recipe instance
  label: string;        // UTC timestamp label
  createdAt: number;    // Timestamp for potential future sorting
}
```

### Key Components Needed

1. **Chat Creation Handler**
   - Instantiate new chat recipe with default values
   - Generate UTC timestamp label using `new Date().toISOString()`
   - Add reference to chats array
   - Navigate to the new chat

2. **Chat Navigation Handler**
   - Accept chat reference from list item click
   - Use `navigateTo` to switch to selected chat

3. **UI Rendering**
   - Empty state check and display
   - List rendering with click handlers
   - "New chat" button placement

### File Structure Alignment
Following the patterns directory conventions:
- Use `/// <cts-enable />` directive at file start
- Import from "commontools" package
- Export default recipe with proper typing
- Use consistent component styling patterns

## Implementation Approach: Incremental Development

### Chosen Strategy: Very Incremental Steps
Build the feature piece by piece, testing each step thoroughly before proceeding to the next. This minimizes risk and ensures each component works correctly in isolation.

### Development Steps

#### Step 1: Basic Button (Console Logging)
- Create `packages/patterns/chat-launcher.tsx` with minimal structure
- Add a single "New chat" button
- Button onClick handler just logs to console
- **Test**: Verify button renders and console.log works
- **Purpose**: Validate basic recipe structure and event handling

#### Step 2: Create & Navigate (No List Yet)
- Modify button handler to instantiate `chat.tsx` recipe
- Use `navigateTo()` to switch to the new chat
- Don't store references yet - just create and navigate
- **Test**: Verify chat creation and navigation works
- **Purpose**: Validate recipe instantiation pattern and navigation

#### Step 3: Store References (No UI)
- Add internal Cell array to store chat references
- When creating chats, push reference to array with timestamp
- Log array contents but don't render list yet
- **Test**: Verify array updates correctly
- **Purpose**: Validate state management without UI complexity

#### Step 4: Render Chat List
- Add UI to display stored chats with timestamps
- Show empty state when no chats exist
- Display count and list items (no navigation yet)
- **Test**: Verify list renders and updates
- **Purpose**: Validate reactive rendering of the list

#### Step 5: Complete Navigation
- Add click handlers to list items
- Implement navigation back to existing chats
- **Test**: Full end-to-end flow
- **Purpose**: Complete the feature with bidirectional navigation

### Why This Approach Works

1. **Risk Mitigation**: Each step is small and testable
2. **Early Validation**: Problems discovered quickly at each stage
3. **Clear Progress**: Each step has a clear success criteria
4. **No Big Bang**: Avoids the complexity of trying everything at once
5. **Learning Curve**: Builds understanding incrementally

### Avoiding Common Pitfalls

Based on PR #1665 analysis:
- **Don't use external linking**: Keep chat list self-contained
- **Avoid direct `.map()` on arrays**: Use proper reactive patterns
- **No well-known IDs**: Manage our own state internally
- **Test multi-tab early**: Catch reactive system issues early

## Related Pull Requests Analysis

### PR #1714: Encapsulate messages in llmDialog node
**Status:** Open  
**Impact:** HIGH - Directly affects chat.tsx implementation

This PR changes how the chat recipe manages messages:
- **Before**: Messages passed as input to chat recipe and llmDialog
- **After**: Messages encapsulated within llmDialog, returned as part of state

**Key Changes:**
- `chat.tsx` no longer receives `chat` messages array as input
- `llmDialog` now returns `{ pending, error, messages, addMessage }`
- Messages are managed internally by llmDialog

**Impact on CT-865:**
- When instantiating chat recipes, we no longer need to provide initial messages
- Each chat instance will have its own isolated message state
- Simplifies chat instantiation: just need to provide title, not message array
- The chat recipe interface becomes cleaner for our use case

### PR #1665: Implement reflection pattern (allCharms.tsx)
**Status:** Open  
**Impact:** MEDIUM - Provides useful patterns for list management

This PR implements a charms-list pattern that reflects over all charms in a space:
- Creates `charms-list.tsx` that receives `allCharms` as input
- Shows count, renders items in a grid/list format
- Implements `visit` handler for navigation using `navigateTo`
- Uses `ignore: true` flag to prevent recursive rendering

**Key Patterns to Leverage:**
```typescript
const visit = handler<{}, { charm: any }>((_, state) => {
  return navigateTo(state.charm);
});
```

**Impact on CT-865:**
- Direct pattern match for our chat-launcher implementation
- Can adapt the visit handler pattern for chat navigation
- Similar UI structure with count display and item rendering
- Shows proper use of handlers with navigateTo

### PR #1729: ct-select and chatbot.tsx model picker
**Status:** Open  
**Impact:** LOW - Renames chat.tsx to chatbot.tsx

This PR adds model selection to the chat interface:
- Renames `chat.tsx` to `chatbot.tsx`
- Adds model picker using `ct-select` component
- Fetches available models from API
- Implements two-way binding for ct-select with Cell support

**Impact on CT-865:**
- Need to decide whether to instantiate `chat.tsx` or `chatbot.tsx`
- If PR merges, update imports to use `chatbot.tsx`
- Model picker adds complexity but is orthogonal to our list management
- The two-way binding pattern in ct-select could be useful for future enhancements

## Updated Implementation Considerations

Based on the PR analysis:

1. **Chat Recipe Selection**: 
   - If PR #1714 merges: Simpler instantiation (no messages array needed)
   - If PR #1729 merges: Use `chatbot.tsx` instead of `chat.tsx`
   - Consider waiting for PR decisions or building compatibility layer

2. **Pattern Adoption**:
   - Use PR #1665's visit handler pattern directly
   - Adapt the list rendering approach from charms-list
   - Consider similar UI layout with count display

3. **State Management**:
   - With PR #1714, each chat maintains its own message state internally
   - Our chat-launcher only needs to track references and labels
   - No need to manage message arrays at the container level

4. **Future Compatibility**:
   - Design chat-launcher to work with both `chat.tsx` and `chatbot.tsx`
   - Keep instantiation logic flexible for recipe interface changes
   - Consider abstracting the chat recipe import for easy swapping