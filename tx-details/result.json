{
    "ok": {
        "did:key:z6MktCfWXiNSojxgbSUAFTTseYnroLjmKouE1mwQQ6peVz2f": {
            "application/commit+json": {
                "ba4jcbmeqyqul5p3yeca5l7lgpbw4sdkd4dksspjsjrckdcjzehpupmem": {
                    "is": {
                        "since": 87,
                        "transaction": {
                            "cmd": "/memory/transact",
                            "sub": "did:key:z6MktCfWXiNSojxgbSUAFTTseYnroLjmKouE1mwQQ6peVz2f",
                            "args": {
                                "changes": {
                                    "of:baedreicdazy6vm7pszguymknotivgw7igvrvn4oaoewcergwdvdwsgtate": {
                                        "application/json": {
                                            "ba4jcawouw4obqhxc72dug2mfsqg7de4bi72mbbaq4fsynnandw2qahpg": {
                                                "is": {
                                                    "value": {
                                                        "$TYPE": "ba4jcan23ohgpphzst3ja34nolpszagll5fijziwukefitwhzzpf6seqk",
                                                        "resultRef": {
                                                            "/": {
                                                                "link@1": {
                                                                    "path": [],
                                                                    "id": "of:baedreigx4zhe2s67gh5pivamq733btokma6feclod7mhxs7d3xi2jvtvsi"
                                                                }
                                                            }
                                                        },
                                                        "internal": {
                                                            "editContent": {
                                                                "$stream": true
                                                            },
                                                            "$event": {
                                                                "$stream": true
                                                            },
                                                            "mentioned": [],
                                                            "__#2stream": {
                                                                "$stream": true
                                                            },
                                                            "backlinks": [],
                                                            "value": {
                                                                "/": {
                                                                    "link@1": {
                                                                        "path": [
                                                                            "internal",
                                                                            "mentionable"
                                                                        ],
                                                                        "id": "of:baedreiebukh75cklqudutddiatk45ptx3dh4dau5le6crg5vgotgaos3oe",
                                                                        "space": "did:key:z6MktCfWXiNSojxgbSUAFTTseYnroLjmKouE1mwQQ6peVz2f"
                                                                    }
                                                                }
                                                            },
                                                            "__#1": "{\"argumentSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]},\"resultSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"mentioned\":{\"$ref\":\"#/$defs/AnonymousType_1\",\"default\":[]},\"backlinks\":{\"$ref\":\"#/$defs/AnonymousType_1\"},\"content\":{\"type\":\"string\",\"default\":\"\",\"description\":\"The content of the note\"},\"grep\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\"}},\"required\":[\"query\"],\"asOpaque\":true},\"editContent\":{\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"string\"}},\"required\":[\"value\"]}},\"required\":[\"detail\"],\"asOpaque\":true}},\"required\":[\"mentioned\",\"backlinks\",\"content\",\"grep\",\"editContent\"],\"$defs\":{\"AnonymousType_1\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"$ref\":\"#/$defs/AnonymousType_1\"},\"backlinks\":{\"$ref\":\"#/$defs/AnonymousType_1\"},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"initial\":{\"internal\":{\"editContent\":{\"$stream\":true},\"$event\":{\"$stream\":true},\"mentioned\":[],\"__#2stream\":{\"$stream\":true},\"backlinks\":[]}},\"result\":{\"$NAME\":{\"$alias\":{\"path\":[\"argument\",\"title\"],\"schema\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}},\"$UI\":{\"type\":\"vnode\",\"name\":\"ct-screen\",\"props\":{},\"children\":[{\"type\":\"vnode\",\"name\":\"div\",\"props\":{\"slot\":\"header\"},\"children\":[{\"type\":\"vnode\",\"name\":\"ct-input\",\"props\":{\"$value\":{\"$alias\":{\"path\":[\"argument\",\"title\"],\"schema\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}},\"placeholder\":\"Enter title...\"},\"children\":[]}]},{\"type\":\"vnode\",\"name\":\"ct-code-editor\",\"props\":{\"$value\":{\"$alias\":{\"path\":[\"argument\",\"content\"],\"schema\":{\"type\":\"string\",\"default\":\"\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}},\"$mentionable\":{\"$alias\":{\"path\":[\"internal\",\"__#0\"]}},\"$mentioned\":{\"$alias\":{\"path\":[\"internal\",\"mentioned\"]}},\"$pattern\":{\"$alias\":{\"path\":[\"internal\",\"__#1\"]}},\"onbacklink-click\":{\"$alias\":{\"path\":[\"internal\",\"__#2stream\"],\"schema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"required\":[\"charm\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"rootSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"required\":[\"charm\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}}}},\"onbacklink-create\":{\"$alias\":{\"path\":[\"internal\",\"$event\"],\"schema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\"},\"charmId\":true,\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"navigate\":{\"type\":\"boolean\"}},\"required\":[\"text\",\"charmId\",\"charm\",\"navigate\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"rootSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\"},\"charmId\":true,\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"navigate\":{\"type\":\"boolean\"}},\"required\":[\"text\",\"charmId\",\"charm\",\"navigate\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}}}},\"language\":\"text/markdown\",\"theme\":\"light\",\"wordWrap\":true,\"tabIndent\":true,\"lineNumbers\":true},\"children\":[]},{\"type\":\"vnode\",\"name\":\"ct-hstack\",\"props\":{\"slot\":\"footer\"},\"children\":[{\"$alias\":{\"path\":[\"internal\",\"__#3\"]}}]}]},\"title\":{\"$alias\":{\"path\":[\"argument\",\"title\"],\"schema\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}},\"content\":{\"$alias\":{\"path\":[\"argument\",\"content\"],\"schema\":{\"type\":\"string\",\"default\":\"\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}},\"mentioned\":{\"$alias\":{\"path\":[\"internal\",\"mentioned\"]}},\"backlinks\":{\"$alias\":{\"path\":[\"internal\",\"backlinks\"]}},\"grep\":{\"pattern\":{\"argumentSchema\":{\"type\":\"object\",\"properties\":{},\"description\":\"tool\"},\"resultSchema\":{},\"initial\":{},\"result\":{\"$alias\":{\"path\":[\"internal\",\"__#0\"],\"cell\":1}},\"nodes\":[{\"module\":{\"type\":\"javascript\",\"implementation\":\"({ query, content }) => {\\n                    return content.split(\\\"\\\\n\\\").filter((c) => c.includes(query));\\n                }\",\"argumentSchema\":{\"type\":\"object\",\"properties\":{\"query\":{\"type\":\"string\"},\"content\":{\"type\":\"string\"}},\"required\":[\"query\",\"content\"]},\"resultSchema\":{\"type\":\"array\",\"items\":true}},\"inputs\":{\"query\":{\"$alias\":{\"path\":[\"argument\",\"query\"],\"cell\":1}},\"content\":{\"$alias\":{\"path\":[\"argument\",\"content\"],\"cell\":1}}},\"outputs\":{\"$alias\":{\"path\":[\"internal\",\"__#0\"],\"cell\":1}}}]},\"extraParams\":{\"content\":{\"$alias\":{\"path\":[\"argument\",\"content\"],\"schema\":{\"type\":\"string\",\"default\":\"\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}}}},\"editContent\":{\"$alias\":{\"path\":[\"internal\",\"editContent\"],\"schema\":{\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"string\"}},\"required\":[\"value\"]}},\"required\":[\"detail\"]},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"string\"}},\"required\":[\"value\"]}},\"required\":[\"detail\"]}}}},\"nodes\":[{\"module\":{\"type\":\"javascript\",\"implementation\":\"({ detail }, { content }) => {\\n        content.set(detail.value);\\n    }\",\"wrapper\":\"handler\",\"argumentSchema\":{\"type\":\"object\",\"properties\":{\"$event\":{\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"string\"}},\"required\":[\"value\"]}},\"required\":[\"detail\"]},\"$ctx\":{\"type\":\"object\",\"properties\":{\"content\":{\"type\":\"string\",\"asCell\":true}},\"required\":[\"content\"]}}}},\"inputs\":{\"$ctx\":{\"content\":{\"$alias\":{\"path\":[\"argument\",\"content\"],\"schema\":{\"type\":\"string\",\"default\":\"\"},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\",\"default\":\"Untitled Note\"},\"content\":{\"type\":\"string\",\"default\":\"\"}},\"required\":[\"title\",\"content\"]}}}},\"$event\":{\"$alias\":{\"path\":[\"internal\",\"editContent\"],\"schema\":{\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"string\"}},\"required\":[\"value\"]}},\"required\":[\"detail\"]},\"rootSchema\":{\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"string\"}},\"required\":[\"value\"]}},\"required\":[\"detail\"]}}}},\"outputs\":{}},{\"module\":{\"type\":\"javascript\",\"implementation\":\"(i) => i\",\"argumentSchema\":{},\"resultSchema\":{}},\"inputs\":{\"$alias\":{\"path\":[\"internal\",\"value\"]}},\"outputs\":{\"$alias\":{\"path\":[\"internal\",\"__#0\"]}}},{\"module\":{\"type\":\"ref\",\"implementation\":\"wish\"},\"inputs\":[\"#mentionable\",[]],\"outputs\":{\"$alias\":{\"path\":[\"internal\",\"value\"]}}},{\"module\":{\"type\":\"javascript\",\"implementation\":\"({ detail }, { mentionable }) => {\\n        console.log(\\\"new charm\\\", detail.text, detail.charmId);\\n        if (detail.navigate) {\\n            return (0, commontools_4.navigateTo)(detail.charm);\\n        }\\n        else {\\n            mentionable.push(detail.charm);\\n        }\\n    }\",\"wrapper\":\"handler\",\"argumentSchema\":{\"type\":\"object\",\"properties\":{\"$event\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\"},\"charmId\":true,\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\",\"asCell\":true},\"navigate\":{\"type\":\"boolean\"}},\"required\":[\"text\",\"charmId\",\"charm\",\"navigate\"]}},\"required\":[\"detail\"]},\"$ctx\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"mentionable\":{\"$ref\":\"#/$defs/AnonymousType_1\",\"asCell\":true}},\"required\":[\"mentionable\"]}},\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"$ref\":\"#/$defs/AnonymousType_1\"},\"backlinks\":{\"$ref\":\"#/$defs/AnonymousType_1\"},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]},\"AnonymousType_1\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}}}}},\"inputs\":{\"$ctx\":{\"mentionable\":{\"$alias\":{\"path\":[\"internal\",\"__#0\"]}}},\"$event\":{\"$alias\":{\"path\":[\"internal\",\"$event\"],\"schema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\"},\"charmId\":true,\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"navigate\":{\"type\":\"boolean\"}},\"required\":[\"text\",\"charmId\",\"charm\",\"navigate\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"rootSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\"},\"charmId\":true,\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"navigate\":{\"type\":\"boolean\"}},\"required\":[\"text\",\"charmId\",\"charm\",\"navigate\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}}}}},\"outputs\":{}},{\"module\":{\"type\":\"javascript\",\"implementation\":\"() => JSON.stringify(Note)\",\"argumentSchema\":true,\"resultSchema\":{\"type\":\"string\"}},\"outputs\":{\"$alias\":{\"path\":[\"internal\",\"__#1\"]}}},{\"module\":{\"type\":\"javascript\",\"implementation\":\"({ detail }, _) => {\\n        return (0, commontools_4.navigateTo)(detail.charm);\\n    }\",\"wrapper\":\"handler\",\"argumentSchema\":{\"type\":\"object\",\"properties\":{\"$event\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\",\"asCell\":true}},\"required\":[\"charm\"]}},\"required\":[\"detail\"]},\"$ctx\":{\"type\":\"object\",\"properties\":{},\"additionalProperties\":false}},\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}}},\"inputs\":{\"$ctx\":{},\"$event\":{\"$alias\":{\"path\":[\"internal\",\"__#2stream\"],\"schema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"required\":[\"charm\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"rootSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"detail\":{\"type\":\"object\",\"properties\":{\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"required\":[\"charm\"]}},\"required\":[\"detail\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}}}}},\"outputs\":{}},{\"module\":{\"type\":\"ref\",\"implementation\":\"map\"},\"inputs\":{\"list\":{\"$alias\":{\"path\":[\"internal\",\"backlinks\"]}},\"op\":{\"argumentSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"element\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"params\":{\"type\":\"object\",\"properties\":{}}},\"required\":[\"element\",\"params\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"resultSchema\":{},\"initial\":{\"internal\":{\"$event\":{\"$stream\":true}}},\"result\":{\"type\":\"vnode\",\"name\":\"ct-button\",\"props\":{\"onClick\":{\"$alias\":{\"path\":[\"internal\",\"$event\"],\"schema\":true,\"rootSchema\":true,\"cell\":1}}},\"children\":[{\"$alias\":{\"path\":[\"internal\",\"__#0\"],\"cell\":1}}]},\"nodes\":[{\"module\":{\"type\":\"javascript\",\"implementation\":\"(_, { charm }) => {\\n        return (0, commontools_4.navigateTo)(charm);\\n    }\",\"wrapper\":\"handler\",\"argumentSchema\":{\"type\":\"object\",\"properties\":{\"$event\":true,\"$ctx\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"charm\":{\"$ref\":\"#/$defs/MentionableCharm\",\"asCell\":true}},\"required\":[\"charm\"]}},\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}}},\"inputs\":{\"$ctx\":{\"charm\":{\"$alias\":{\"path\":[\"argument\",\"element\"],\"schema\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]},\"rootSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"element\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"params\":{\"type\":\"object\",\"properties\":{}}},\"required\":[\"element\",\"params\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"cell\":1}}},\"$event\":{\"$alias\":{\"path\":[\"internal\",\"$event\"],\"schema\":true,\"rootSchema\":true,\"cell\":1}}},\"outputs\":{}},{\"module\":{\"type\":\"javascript\",\"implementation\":\"element => element?.[commontools_4.NAME]\"},\"inputs\":{\"$alias\":{\"path\":[\"argument\",\"element\"],\"schema\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]},\"rootSchema\":{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"element\":{\"$ref\":\"#/$defs/MentionableCharm\"},\"params\":{\"type\":\"object\",\"properties\":{}}},\"required\":[\"element\",\"params\"],\"$defs\":{\"MentionableCharm\":{\"type\":\"object\",\"properties\":{\"mentioned\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"backlinks\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/$defs/MentionableCharm\"}},\"$NAME\":{\"type\":\"string\"}},\"required\":[\"mentioned\",\"backlinks\"]}}},\"cell\":1}},\"outputs\":{\"$alias\":{\"path\":[\"internal\",\"__#0\"],\"cell\":1}}}]},\"params\":{}},\"outputs\":{\"$alias\":{\"path\":[\"internal\",\"__#3\"]}}}],\"program\":{\"main\":\"/note.tsx\",\"mainExport\":\"default\",\"files\":[{\"name\":\"/default-app.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  Cell,\\n  derive,\\n  handler,\\n  NAME,\\n  navigateTo,\\n  recipe,\\n  str,\\n  UI,\\n  wish,\\n} from \\\"commontools\\\";\\n\\nimport Chatbot from \\\"./chatbot.tsx\\\";\\nimport ChatbotOutliner from \\\"./chatbot-outliner.tsx\\\";\\nimport { default as Note } from \\\"./note.tsx\\\";\\nimport BacklinksIndex, { type MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\nimport ChatList from \\\"./chatbot-list-view.tsx\\\";\\nimport OmniboxFAB from \\\"./omnibox-fab.tsx\\\";\\n\\ntype MinimalCharm = {\\n  [NAME]?: string;\\n};\\n\\ntype CharmsListInput = void;\\n\\n// Recipe returns only UI, no data outputs (only symbol properties)\\ninterface CharmsListOutput {\\n  [key: string]: unknown;\\n  backlinksIndex: {\\n    mentionable: MentionableCharm[];\\n  };\\n  sidebarUI: unknown;\\n  fabUI: unknown;\\n}\\n\\nconst visit = handler<\\n  Record<string, never>,\\n  { charm: Cell<MinimalCharm> }\\n>((_, state) => {\\n  return navigateTo(state.charm);\\n}, { proxy: true });\\n\\nconst removeCharm = handler<\\n  Record<string, never>,\\n  {\\n    charm: Cell<MinimalCharm>;\\n    allCharms: Cell<MinimalCharm[]>;\\n  }\\n>((_, state) => {\\n  const allCharmsValue = state.allCharms.get();\\n  const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\\n\\n  if (index !== -1) {\\n    const charmListCopy = [...allCharmsValue];\\n    console.log(\\\"charmListCopy before\\\", charmListCopy.length);\\n    charmListCopy.splice(index, 1);\\n    console.log(\\\"charmListCopy after\\\", charmListCopy.length);\\n    state.allCharms.set(charmListCopy);\\n  }\\n});\\n\\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\\n  (_, { fabExpanded }) => {\\n    fabExpanded.set(!fabExpanded.get());\\n  },\\n);\\n\\nconst spawnChatList = handler<void, void>((_, __) => {\\n  return navigateTo(ChatList({\\n    selectedCharm: { charm: undefined },\\n    charmsList: [],\\n  }));\\n});\\n\\nconst spawnChatbot = handler<void, void>((_, __) => {\\n  return navigateTo(Chatbot({\\n    messages: [],\\n    tools: undefined,\\n  }));\\n});\\n\\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\\n  return navigateTo(ChatbotOutliner({\\n    title: \\\"Chatbot Outliner\\\",\\n    expandChat: false,\\n    messages: [],\\n    outline: {\\n      root: { body: \\\"\\\", children: [], attachments: [] },\\n    },\\n  }));\\n});\\n\\nconst spawnNote = handler<void, void>((_, __) => {\\n  return navigateTo(Note({\\n    title: \\\"New Note\\\",\\n    content: \\\"\\\",\\n  }));\\n});\\n\\nexport default recipe<CharmsListInput, CharmsListOutput>(\\n  \\\"DefaultCharmList\\\",\\n  (_) => {\\n    const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\\n      wish<MentionableCharm[]>(\\\"#allCharms\\\"),\\n      (c) => c,\\n    );\\n    const index = BacklinksIndex({ allCharms });\\n\\n    const fab = OmniboxFAB({\\n      mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\\n    });\\n\\n    return {\\n      backlinksIndex: index,\\n      [NAME]: str`DefaultCharmList (${allCharms.length})`,\\n      [UI]: (\\n        <ct-screen>\\n          <ct-keybind\\n            code=\\\"KeyN\\\"\\n            alt\\n            preventDefault\\n            onct-keybind={spawnChatList()}\\n          />\\n          <ct-keybind\\n            code=\\\"KeyO\\\"\\n            meta\\n            preventDefault\\n            onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\\n          />\\n          <ct-keybind\\n            code=\\\"KeyO\\\"\\n            ctrl\\n            preventDefault\\n            onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\\n          />\\n\\n          <ct-toolbar slot=\\\"header\\\" sticky>\\n            <div slot=\\\"start\\\">\\n              <ct-button\\n                onClick={spawnChatList()}\\n              >\\n                📂 Chat List\\n              </ct-button>\\n              <ct-button\\n                onClick={spawnChatbot()}\\n              >\\n                💬 Chatbot\\n              </ct-button>\\n              <ct-button\\n                onClick={spawnChatbotOutliner()}\\n              >\\n                📝 Chatbot Outliner\\n              </ct-button>\\n              <ct-button\\n                onClick={spawnNote()}\\n              >\\n                📄 Note\\n              </ct-button>\\n            </div>\\n          </ct-toolbar>\\n\\n          <ct-vscroll flex showScrollbar>\\n            <ct-vstack gap=\\\"4\\\" padding=\\\"6\\\">\\n              <h2>Charms ({allCharms.length})</h2>\\n\\n              <ct-table full-width hover>\\n                <thead>\\n                  <tr>\\n                    <th>Charm Name</th>\\n                    <th>Actions</th>\\n                  </tr>\\n                </thead>\\n                <tbody>\\n                  {allCharms.map((charm) => (\\n                    <tr>\\n                      <td>{charm?.[NAME] || \\\"Untitled Charm\\\"}</td>\\n                      <td>\\n                        <ct-hstack gap=\\\"2\\\">\\n                          <ct-button\\n                            size=\\\"sm\\\"\\n                            onClick={visit({ charm })}\\n                          >\\n                            Visit\\n                          </ct-button>\\n                          <ct-button\\n                            size=\\\"sm\\\"\\n                            variant=\\\"destructive\\\"\\n                            onClick={removeCharm({ charm, allCharms })}\\n                          >\\n                            Remove\\n                          </ct-button>\\n                        </ct-hstack>\\n                      </td>\\n                    </tr>\\n                  ))}\\n                </tbody>\\n              </ct-table>\\n            </ct-vstack>\\n          </ct-vscroll>\\n        </ct-screen>\\n      ),\\n      sidebarUI: undefined,\\n      fabUI: fab[UI],\\n    };\\n  },\\n);\\n\"},{\"name\":\"/chatbot.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  BuiltInLLMMessage,\\n  Cell,\\n  cell,\\n  Default,\\n  derive,\\n  fetchData,\\n  generateObject,\\n  handler,\\n  llmDialog,\\n  NAME,\\n  navigateTo,\\n  recipe,\\n  Stream,\\n  UI,\\n  VNode,\\n  wish,\\n} from \\\"commontools\\\";\\nimport { type MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\n\\nfunction schemaifyWish<T>(path: string) {\\n  return derive<T, T>(wish<T>(path), (i) => i);\\n}\\n\\nconst addAttachment = handler<\\n  {\\n    detail: {\\n      attachment: PromptAttachment;\\n    };\\n  },\\n  {\\n    allAttachments: Cell<Array<PromptAttachment>>;\\n  }\\n>((event, { allAttachments }) => {\\n  const { attachment } = event.detail;\\n  const current = allAttachments.get() || [];\\n  allAttachments.set([...current, attachment]);\\n});\\n\\nconst removeAttachment = handler<\\n  {\\n    detail: {\\n      id: string;\\n    };\\n  },\\n  {\\n    allAttachments: Cell<Array<PromptAttachment>>;\\n  }\\n>((event, { allAttachments }) => {\\n  const { id } = event.detail;\\n  const current = allAttachments.get() || [];\\n  allAttachments.set(current.filter((a) => a.id !== id));\\n});\\n\\nconst sendMessage = handler<\\n  {\\n    detail: {\\n      text: string;\\n      attachments: Array<PromptAttachment>;\\n      mentions: Array<any>;\\n      message: string; // Backward compatibility\\n    };\\n  },\\n  {\\n    addMessage: Stream<BuiltInLLMMessage>;\\n    allAttachments: Cell<Array<PromptAttachment>>;\\n  }\\n>((event, { addMessage, allAttachments }) => {\\n  const { text } = event.detail;\\n\\n  // Build content array from text and attachments\\n  const contentParts = [{ type: \\\"text\\\" as const, text }];\\n\\n  // Get current attachments from the global list\\n  const attachments = allAttachments.get() || [];\\n\\n  // Compute mentions from mention attachments so they are available to consumers\\n  const _mentions = attachments\\n    .filter((a) => a.type === \\\"mention\\\" && a.charm)\\n    .map((a) => a.charm);\\n\\n  // Process attachments\\n  for (const attachment of attachments) {\\n    if (attachment.type === \\\"file\\\" && attachment.data) {\\n      // For now, add a text reference\\n      contentParts.push({\\n        type: \\\"text\\\" as const,\\n        text: `[Attached file: ${attachment.name}]`,\\n      });\\n    } else if (attachment.type === \\\"clipboard\\\" && attachment.data) {\\n      // Append clipboard content as additional context\\n      contentParts.push({\\n        type: \\\"text\\\" as const,\\n        text: `\\\\n\\\\n--- Pasted content ---\\\\n${attachment.data}`,\\n      });\\n    }\\n    // Note: mentions are already in the text as clean names\\n    // The charm references are available in attachment.charm if needed\\n  }\\n\\n  addMessage.send({\\n    role: \\\"user\\\",\\n    content: contentParts,\\n  });\\n});\\n\\nconst clearChat = handler(\\n  (\\n    _: never,\\n    { messages, pending }: {\\n      messages: Cell<Array<BuiltInLLMMessage>>;\\n      pending: Cell<boolean | undefined>;\\n    },\\n  ) => {\\n    messages.set([]);\\n    pending.set(false);\\n  },\\n);\\n\\ntype ChatInput = {\\n  messages: Default<Array<BuiltInLLMMessage>, []>;\\n  tools: any;\\n  theme?: any;\\n};\\n\\ntype PromptAttachment = {\\n  id: string;\\n  name: string;\\n  type: \\\"file\\\" | \\\"clipboard\\\" | \\\"mention\\\";\\n  data?: any; // File | Blob | string\\n  charm?: any;\\n};\\n\\ntype ChatOutput = {\\n  messages: Array<BuiltInLLMMessage>;\\n  pending: boolean | undefined;\\n  addMessage: Stream<BuiltInLLMMessage>;\\n  clearChat: Stream<void>;\\n  cancelGeneration: Stream<void>;\\n  title?: string;\\n  attachments: Array<PromptAttachment>;\\n  tools: any;\\n  ui: {\\n    chatLog: VNode;\\n    promptInput: VNode;\\n    attachmentsAndTools: VNode;\\n  };\\n};\\n\\nexport const TitleGenerator = recipe<\\n  { model?: string; messages: Array<BuiltInLLMMessage> }\\n>(\\\"Title Generator\\\", ({ model, messages }) => {\\n  const titleMessages = derive(messages, (m) => {\\n    if (!m || m.length === 0) return \\\"\\\";\\n\\n    const messageCount = 2;\\n    const selectedMessages = m.slice(0, messageCount).filter(Boolean);\\n\\n    if (selectedMessages.length === 0) return \\\"\\\";\\n\\n    return selectedMessages.map((msg) => JSON.stringify(msg)).join(\\\"\\\\n\\\");\\n  });\\n\\n  const { result } = generateObject({\\n    system:\\n      \\\"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\\\",\\n    prompt: titleMessages,\\n    model,\\n    schema: {\\n      type: \\\"object\\\",\\n      properties: {\\n        title: {\\n          type: \\\"string\\\",\\n          description: \\\"The title of the chat\\\",\\n        },\\n      },\\n      required: [\\\"title\\\"],\\n    },\\n  });\\n\\n  const title = derive(result, (t) => {\\n    return t?.title || \\\"Untitled Chat\\\";\\n  });\\n\\n  return title;\\n});\\n\\nconst navigateToAttachment = handler<\\n  { id: string },\\n  { allAttachments: Array<PromptAttachment> }\\n>(({ id }, { allAttachments }) => {\\n  const attachment = allAttachments.find((a) => a.id === id);\\n\\n  return navigateTo(attachment?.charm);\\n});\\n\\nconst listAttachments = handler<\\n  { result: Cell<string> },\\n  { allAttachments: Array<PromptAttachment> }\\n>(({ result }, { allAttachments }) => {\\n  result.set(JSON.stringify(allAttachments.map((attachment) => ({\\n    id: attachment.id,\\n    name: attachment.name,\\n    type: attachment.type,\\n  }))));\\n});\\n\\nconst addAttachmentTool = handler<\\n  {\\n    mentionableName: string;\\n  },\\n  {\\n    mentionable: Array<MentionableCharm>;\\n    allAttachments: Cell<Array<PromptAttachment>>;\\n  }\\n>(({ mentionableName }, { mentionable, allAttachments }) => {\\n  const charm = mentionable.find((c) => c[NAME] === mentionableName);\\n\\n  // borrowed from `ct-prompt-input` to match\\n  const id = `attachment-${Date.now()}-${\\n    Math.random().toString(36).substring(2, 9)\\n  }`;\\n\\n  if (!charm) {\\n    throw new Error(\\n      `Unknown mentionable \\\"${mentionableName}\\\", cannot add attachment.`,\\n    );\\n  }\\n\\n  allAttachments.push({\\n    id,\\n    name: mentionableName,\\n    type: \\\"mention\\\",\\n    charm,\\n  });\\n});\\n\\nconst removeAttachmentTool = handler<\\n  {\\n    mentionableName: string;\\n  },\\n  {\\n    allAttachments: Cell<Array<PromptAttachment>>;\\n  }\\n>(({ mentionableName }, { allAttachments }) => {\\n  allAttachments.set(\\n    allAttachments.get().filter((attachment) =>\\n      attachment.name !== mentionableName\\n    ),\\n  );\\n});\\n\\nconst listMentionable = handler<\\n  {\\n    /** A cell to store the result text */\\n    result: Cell<string>;\\n  },\\n  { mentionable: MentionableCharm[] }\\n>(\\n  (args, state) => {\\n    try {\\n      const namesList = state.mentionable.map((charm) => charm[NAME]);\\n      args.result.set(JSON.stringify(namesList));\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\nexport default recipe<ChatInput, ChatOutput>(\\n  \\\"Chat\\\",\\n  ({ messages, tools, theme }) => {\\n    const model = cell<string>(\\\"anthropic:claude-sonnet-4-5\\\");\\n    const allAttachments = cell<Array<PromptAttachment>>([]);\\n    const mentionable = schemaifyWish<MentionableCharm[]>(\\\"#mentionable\\\");\\n\\n    // Derive tools from attachments\\n    const dynamicTools = derive(allAttachments, (attachments) => {\\n      const tools: Record<string, any> = {};\\n\\n      for (const attachment of attachments || []) {\\n        if (attachment.type === \\\"mention\\\" && attachment.charm) {\\n          const charmName = attachment.charm[NAME] || \\\"Charm\\\";\\n          tools[charmName] = {\\n            charm: attachment.charm,\\n            description: `Handlers from ${charmName}`,\\n          };\\n        }\\n      }\\n\\n      return tools;\\n    });\\n\\n    const attachmentTools = {\\n      navigateToAttachment: {\\n        description:\\n          \\\"Navigate to a mentionable by its ID in the attachments array.\\\",\\n        handler: navigateToAttachment({ allAttachments }),\\n      },\\n      listAttachments: {\\n        description: \\\"List all attachments in the attachments array.\\\",\\n        handler: listAttachments({ allAttachments }),\\n      },\\n      listMentionable: {\\n        description: \\\"List all mentionable NAMEs in the space.\\\",\\n        handler: listMentionable({ mentionable }),\\n      },\\n      addAttachment: {\\n        description:\\n          \\\"Add a new attachment to the attachments array by its mentionable NAME.\\\",\\n        handler: addAttachmentTool({ mentionable, allAttachments }),\\n      },\\n      removeAttachment: {\\n        description:\\n          \\\"Remove an attachment from the attachments array by its mentionable NAME.\\\",\\n        handler: removeAttachmentTool({ allAttachments }),\\n      },\\n    };\\n\\n    // Merge static and dynamic tools\\n    const mergedTools = derive(\\n      [tools, dynamicTools, attachmentTools],\\n      ([staticTools, dynamic, attachments]: [any, any, any]) => ({\\n        ...staticTools,\\n        ...dynamic,\\n        ...attachments,\\n      }),\\n    );\\n\\n    const { addMessage, cancelGeneration, pending, flattenedTools } = llmDialog(\\n      {\\n        system: \\\"You are a helpful assistant with some tools.\\\",\\n        messages,\\n        tools: mergedTools,\\n        model,\\n      },\\n    );\\n\\n    const { result } = fetchData({\\n      url: \\\"/api/ai/llm/models\\\",\\n      mode: \\\"json\\\",\\n    });\\n\\n    const items = derive(result, (models) => {\\n      if (!models) return [];\\n      const items = Object.keys(models as any).map((key) => ({\\n        label: key,\\n        value: key,\\n      }));\\n      return items;\\n    });\\n\\n    const title = TitleGenerator({ model, messages });\\n\\n    const promptInput = (\\n      <ct-prompt-input\\n        slot=\\\"footer\\\"\\n        placeholder=\\\"Ask the LLM a question...\\\"\\n        pending={pending}\\n        $mentionable={mentionable}\\n        modelItems={items}\\n        $model={model}\\n        onct-send={sendMessage({ addMessage, allAttachments })}\\n        onct-stop={cancelGeneration}\\n        onct-attachment-add={addAttachment({ allAttachments })}\\n        onct-attachment-remove={removeAttachment({ allAttachments })}\\n      />\\n    );\\n\\n    const chatLog = (\\n      <ct-vscroll\\n        style=\\\"padding: 1rem;\\\"\\n        flex\\n        showScrollbar\\n        fadeEdges\\n        snapToBottom\\n      >\\n        <ct-chat\\n          theme={theme}\\n          $messages={messages}\\n          pending={pending}\\n          tools={flattenedTools}\\n        />\\n      </ct-vscroll>\\n    );\\n\\n    const attachmentsAndTools = (\\n      <ct-hstack align=\\\"center\\\" gap=\\\"1\\\">\\n        <ct-attachments-bar\\n          attachments={allAttachments}\\n          removable\\n          onct-remove={removeAttachment({ allAttachments })}\\n        />\\n        <ct-tools-chip tools={flattenedTools} />\\n        <ct-button\\n          variant=\\\"pill\\\"\\n          type=\\\"button\\\"\\n          title=\\\"Clear chat\\\"\\n          onClick={clearChat({\\n            messages,\\n            pending,\\n          })}\\n        >\\n          Clear\\n        </ct-button>\\n      </ct-hstack>\\n    );\\n\\n    return {\\n      [NAME]: title,\\n      [UI]: (\\n        <ct-screen>\\n          <ct-vstack slot=\\\"header\\\">\\n            <ct-heading level={4}>{title}</ct-heading>\\n            {attachmentsAndTools}\\n          </ct-vstack>\\n\\n          {chatLog}\\n\\n          {promptInput}\\n        </ct-screen>\\n      ),\\n      messages,\\n      pending,\\n      addMessage,\\n      clearChat: clearChat({\\n        messages,\\n        pending,\\n      }),\\n      cancelGeneration,\\n      title,\\n      attachments: allAttachments,\\n      tools: flattenedTools,\\n      ui: {\\n        chatLog,\\n        promptInput,\\n        attachmentsAndTools,\\n      },\\n    };\\n  },\\n);\\n\"},{\"name\":\"/chatbot-outliner.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  BuiltInLLMMessage,\\n  Cell,\\n  Default,\\n  derive,\\n  handler,\\n  ifElse,\\n  JSONSchema,\\n  NAME,\\n  navigateTo,\\n  OpaqueRef,\\n  recipe,\\n  UI,\\n  wish,\\n} from \\\"commontools\\\";\\n\\nimport Chat from \\\"./chatbot.tsx\\\";\\nimport { MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\n\\ntype Charm = any;\\n\\ntype OutlinerNode = {\\n  body: Default<string, \\\"\\\">;\\n  children: Default<OutlinerNode[], []>;\\n  attachments: Default<OpaqueRef<any>[], []>;\\n};\\n\\ntype Outliner = {\\n  root: OutlinerNode;\\n};\\n\\ntype PageResult = {\\n  outline: Default<\\n    Outliner,\\n    { root: { body: \\\"\\\"; children: []; attachments: [] } }\\n  >;\\n};\\n\\nexport type PageInput = {\\n  outline: Outliner;\\n};\\n\\nconst handleCharmLinkClick = handler<\\n  {\\n    detail: {\\n      charm: Cell<Charm>;\\n    };\\n  },\\n  Record<string, never>\\n>(({ detail }, _) => {\\n  return navigateTo(detail.charm);\\n});\\n\\nfunction getMentionable() {\\n  return derive<MentionableCharm[], MentionableCharm[]>(\\n    wish<MentionableCharm[]>(\\\"#mentionable\\\"),\\n    (i) => i,\\n  );\\n}\\n\\nexport const Page = recipe<PageInput>(\\n  \\\"Page\\\",\\n  ({ outline }) => {\\n    const mentionable = getMentionable();\\n\\n    return {\\n      [NAME]: \\\"Page\\\",\\n      [UI]: (\\n        <ct-outliner\\n          $value={outline as any}\\n          $mentionable={mentionable}\\n          oncharm-link-click={handleCharmLinkClick({})}\\n        />\\n      ),\\n      outline,\\n    };\\n  },\\n);\\n\\ntype LLMTestInput = {\\n  title: Default<string, \\\"LLM Test\\\">;\\n  messages: Default<Array<BuiltInLLMMessage>, []>;\\n  expandChat: Default<boolean, false>;\\n  outline: Default<\\n    Outliner,\\n    { root: { body: \\\"Untitled Page\\\"; children: []; attachments: [] } }\\n  >;\\n};\\n\\ntype LLMTestResult = {\\n  messages: Default<Array<BuiltInLLMMessage>, []>;\\n};\\n\\n// put a node at the end of the outline (by appending to root.children)\\nconst appendOutlinerNode = handler<\\n  {\\n    /** The text content/title of the outliner node to be appended */\\n    body: string;\\n    /** A cell to store the result message indicating success or error */\\n    result: Cell<string>;\\n  },\\n  { outline: Cell<Outliner> }\\n>(\\n  (args, state) => {\\n    try {\\n      (state.outline.key(\\\"root\\\").key(\\\"children\\\")).push({\\n        body: args.body,\\n        children: [],\\n        attachments: [],\\n      });\\n\\n      args.result.set(\\n        `${state.outline.key(\\\"root\\\").key(\\\"children\\\").get().length} nodes`,\\n      );\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\nexport default recipe<LLMTestInput, LLMTestResult>(\\n  \\\"Outliner\\\",\\n  ({ title, expandChat, messages, outline }) => {\\n    const tools = {\\n      appendOutlinerNode: {\\n        description: \\\"Add a new outliner node.\\\",\\n        inputSchema: {\\n          type: \\\"object\\\",\\n          properties: {\\n            body: {\\n              type: \\\"string\\\",\\n              description: \\\"The title of the new node.\\\",\\n            },\\n          },\\n          required: [\\\"body\\\"],\\n        } as JSONSchema,\\n        handler: appendOutlinerNode({ outline }),\\n      },\\n    };\\n\\n    const chat = Chat({ messages, tools });\\n\\n    return {\\n      [NAME]: title,\\n      [UI]: (\\n        <ct-screen>\\n          <ct-hstack justify=\\\"between\\\" slot=\\\"header\\\">\\n            <div></div>\\n            <div>\\n              <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\\n            </div>\\n          </ct-hstack>\\n\\n          <ct-autolayout tabNames={[\\\"Chat\\\", \\\"Tools\\\"]}>\\n            <ct-screen>\\n              <div slot=\\\"header\\\">\\n                <ct-input\\n                  $value={title}\\n                  placeholder=\\\"Enter title...\\\"\\n                />\\n              </div>\\n\\n              <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\\n                <ct-vstack data-label=\\\"Tools\\\">\\n                  <Page outline={outline} />\\n                </ct-vstack>\\n              </ct-vscroll>\\n            </ct-screen>\\n\\n            {ifElse(\\n              expandChat,\\n              chat,\\n              null,\\n            )}\\n          </ct-autolayout>\\n        </ct-screen>\\n      ),\\n      messages,\\n    };\\n  },\\n);\\n\"},{\"name\":\"/note.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  Cell,\\n  cell,\\n  Default,\\n  derive,\\n  handler,\\n  NAME,\\n  navigateTo,\\n  Opaque,\\n  OpaqueRef,\\n  patternTool,\\n  recipe,\\n  UI,\\n  wish,\\n} from \\\"commontools\\\";\\nimport { type MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\ntype Input = {\\n  title: Default<string, \\\"Untitled Note\\\">;\\n  content: Default<string, \\\"\\\">;\\n};\\n\\ntype Output = {\\n  mentioned: Default<Array<MentionableCharm>, []>;\\n  backlinks: MentionableCharm[];\\n\\n  /** The content of the note */\\n  content: Default<string, \\\"\\\">;\\n  grep: OpaqueRef<{ query: string }>;\\n  editContent: OpaqueRef<{ detail: { value: string } }>;\\n};\\n\\nconst _updateTitle = handler<\\n  { detail: { value: string } },\\n  { title: Cell<string> }\\n>(\\n  (event, state) => {\\n    state.title.set(event.detail?.value ?? \\\"\\\");\\n  },\\n);\\n\\nconst _updateContent = handler<\\n  { detail: { value: string } },\\n  { content: Cell<string> }\\n>(\\n  (event, state) => {\\n    state.content.set(event.detail?.value ?? \\\"\\\");\\n  },\\n);\\n\\nconst handleCharmLinkClick = handler<\\n  {\\n    detail: {\\n      charm: Cell<MentionableCharm>;\\n    };\\n  },\\n  Record<string, never>\\n>(({ detail }, _) => {\\n  return navigateTo(detail.charm);\\n});\\n\\nconst handleNewBacklink = handler<\\n  {\\n    detail: {\\n      text: string;\\n      charmId: any;\\n      charm: Cell<MentionableCharm>;\\n      navigate: boolean;\\n    };\\n  },\\n  {\\n    mentionable: Cell<MentionableCharm[]>;\\n  }\\n>(({ detail }, { mentionable }) => {\\n  console.log(\\\"new charm\\\", detail.text, detail.charmId);\\n\\n  if (detail.navigate) {\\n    return navigateTo(detail.charm);\\n  } else {\\n    mentionable.push(detail.charm as unknown as MentionableCharm);\\n  }\\n});\\n\\n/** This edits the content */\\nconst handleEditContent = handler<\\n  { detail: { value: string } },\\n  { content: Cell<string> }\\n>(\\n  ({ detail }, { content }) => {\\n    content.set(detail.value);\\n  },\\n);\\n\\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\\n  (_, { charm }) => {\\n    return navigateTo(charm);\\n  },\\n);\\n\\nfunction schemaifyWish<T>(path: string, def: T | Opaque<T>) {\\n  return derive<T, T>(wish<T>(path, def as Opaque<T>), (i) => i);\\n}\\n\\nconst Note = recipe<Input, Output>(\\n  \\\"Note\\\",\\n  ({ title, content }) => {\\n    const mentionable = schemaifyWish<MentionableCharm[]>(\\n      \\\"#mentionable\\\",\\n      [],\\n    );\\n    const mentioned = cell<MentionableCharm[]>([]);\\n\\n    // populated in backlinks-index.tsx\\n    const backlinks = cell<MentionableCharm[]>([]);\\n\\n    // The only way to serialize a pattern, apparently?\\n    const pattern = derive(undefined, () => JSON.stringify(Note));\\n\\n    return {\\n      [NAME]: title,\\n      [UI]: (\\n        <ct-screen>\\n          <div slot=\\\"header\\\">\\n            <ct-input\\n              $value={title}\\n              placeholder=\\\"Enter title...\\\"\\n            />\\n          </div>\\n\\n          <ct-code-editor\\n            $value={content}\\n            $mentionable={mentionable}\\n            $mentioned={mentioned}\\n            $pattern={pattern}\\n            onbacklink-click={handleCharmLinkClick({})}\\n            onbacklink-create={handleNewBacklink({ mentionable })}\\n            language=\\\"text/markdown\\\"\\n            theme=\\\"light\\\"\\n            wordWrap\\n            tabIndent\\n            lineNumbers\\n          />\\n\\n          <ct-hstack slot=\\\"footer\\\">\\n            {backlinks?.map((charm) => (\\n              <ct-button\\n                onClick={handleCharmLinkClicked({ charm })}\\n              >\\n                {charm?.[NAME]}\\n              </ct-button>\\n            ))}\\n          </ct-hstack>\\n        </ct-screen>\\n      ),\\n      title,\\n      content,\\n      mentioned,\\n      backlinks,\\n      grep: patternTool(\\n        ({ query, content }: { query: string; content: string }) => {\\n          return derive({ query, content }, ({ query, content }) => {\\n            return content.split(\\\"\\\\n\\\").filter((c) => c.includes(query));\\n          });\\n        },\\n        { content },\\n      ),\\n      editContent: handleEditContent({ content }),\\n    };\\n  },\\n);\\n\\nexport default Note;\\n\"},{\"name\":\"/backlinks-index.tsx\",\"contents\":\"/// <cts-enable />\\nimport { Cell, lift, NAME, OpaqueRef, recipe, UI } from \\\"commontools\\\";\\n\\nexport type MentionableCharm = {\\n  [NAME]?: string;\\n  mentioned: MentionableCharm[];\\n  backlinks: MentionableCharm[];\\n};\\n\\nexport type WriteableBacklinks = {\\n  mentioned: WriteableBacklinks[];\\n  backlinks: Cell<WriteableBacklinks[]>;\\n};\\n\\ntype Input = {\\n  allCharms: MentionableCharm[];\\n};\\n\\ntype Output = {\\n  mentionable: MentionableCharm[];\\n};\\n\\nconst computeIndex = lift<\\n  { allCharms: WriteableBacklinks[] },\\n  void\\n>(\\n  ({ allCharms }) => {\\n    const cs = allCharms ?? [];\\n\\n    for (const c of cs) {\\n      c.backlinks?.set([]);\\n    }\\n\\n    for (const c of cs) {\\n      const mentions = c.mentioned ?? [];\\n      for (const m of mentions) {\\n        m?.backlinks?.push(c);\\n      }\\n    }\\n  },\\n);\\n\\n/**\\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\\n * unified mentionable list for consumers like editors.\\n *\\n * Behavior:\\n * - Backlinks are computed by scanning each charm's `mentioned` list and\\n *   mapping mention target -> list of source charms.\\n * - Mentionable list is a union of:\\n *   - every charm in `allCharms`\\n *   - any items a charm exports via a `mentionable` property\\n *     (either an array of charms or a Cell of such an array)\\n *\\n * The backlinks map is keyed by a charm's `content` value (falling back to\\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\\n * computing backlinks locally.\\n */\\nconst BacklinksIndex = recipe<Input, Output>(\\n  \\\"BacklinksIndex\\\",\\n  ({ allCharms }) => {\\n    computeIndex({\\n      allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\\n    });\\n\\n    // Compute mentionable list from allCharms via lift, then mirror that into\\n    // a real Cell for downstream consumers that expect a Cell.\\n    const computeMentionable = lift<\\n      { allCharms: any[] },\\n      MentionableCharm[]\\n    >(({ allCharms }) => {\\n      const cs = allCharms ?? [];\\n      const out: MentionableCharm[] = [];\\n      for (const c of cs) {\\n        out.push(c);\\n        const exported = (c as unknown as {\\n          mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\\n        }).mentionable;\\n        if (Array.isArray(exported)) {\\n          for (const m of exported) if (m) out.push(m);\\n        } else if (exported && typeof (exported as any).get === \\\"function\\\") {\\n          const arr = (exported as { get: () => MentionableCharm[] }).get() ??\\n            [];\\n          for (const m of arr) if (m) out.push(m);\\n        }\\n      }\\n      return out;\\n    });\\n\\n    return {\\n      [NAME]: \\\"BacklinksIndex\\\",\\n      [UI]: undefined,\\n      mentionable: computeMentionable({ allCharms }),\\n    };\\n  },\\n);\\n\\nexport default BacklinksIndex;\\n\"},{\"name\":\"/chatbot-list-view.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  Cell,\\n  cell,\\n  Default,\\n  derive,\\n  handler,\\n  ID,\\n  ifElse,\\n  lift,\\n  NAME,\\n  navigateTo,\\n  OpaqueRef,\\n  recipe,\\n  toSchema,\\n  UI,\\n  wish,\\n} from \\\"commontools\\\";\\n\\nimport Chat from \\\"./chatbot-note-composed.tsx\\\";\\nimport { ListItem } from \\\"./common-tools.tsx\\\";\\n\\nimport { type MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\ntype CharmEntry = {\\n  [ID]: string; // randomId is a string\\n  local_id: string; // same as ID but easier to access\\n  charm: any;\\n};\\n\\ntype Input = {\\n  selectedCharm: Default<{ charm: any }, { charm: undefined }>;\\n  charmsList: Default<CharmEntry[], []>;\\n  theme?: {\\n    accentColor: Default<string, \\\"#3b82f6\\\">;\\n    fontFace: Default<string, \\\"system-ui, -apple-system, sans-serif\\\">;\\n    borderRadius: Default<string, \\\"0.5rem\\\">;\\n  };\\n};\\n\\ntype Output = {\\n  selectedCharm: Default<{ charm: any }, { charm: undefined }>;\\n  // Expose a mentionable list aggregated from local chat entries\\n  // Returned as an opaque ref to an array (not a Cell), suitable for\\n  // upstream aggregators that read exported mentionables.\\n  mentionable?: MentionableCharm[];\\n};\\n\\nconst removeChat = handler<\\n  unknown,\\n  {\\n    charmsList: Cell<CharmEntry[]>;\\n    id: string;\\n    selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\\n  }\\n>(\\n  (\\n    _,\\n    { charmsList, id, selectedCharm },\\n  ) => {\\n    const list = charmsList.get();\\n    const index = list.findIndex((entry) => entry.local_id === id);\\n    if (index === -1) return;\\n\\n    const removed = list[index];\\n    const next = [...list];\\n    next.splice(index, 1);\\n    charmsList.set(next);\\n\\n    // If we removed the currently selected charm, choose a new selection.\\n    const current = selectedCharm.get();\\n    if (current?.charm === removed.charm) {\\n      const replacement = next[index] ?? next[index - 1];\\n      if (replacement) {\\n        selectedCharm.set({ charm: replacement.charm });\\n      } else {\\n        selectedCharm.set({ charm: undefined as unknown as any });\\n      }\\n    }\\n  },\\n);\\n\\n// this will be called whenever charm or selectedCharm changes\\n// pass isInitialized to make sure we dont call this each time\\n// we change selectedCharm, otherwise creates a loop\\nconst storeCharm = lift(\\n  toSchema<{\\n    charm: any;\\n    selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\\n    charmsList: Cell<CharmEntry[]>;\\n    allCharms: Cell<MentionableCharm[]>;\\n    theme?: {\\n      accentColor: Default<string, \\\"#3b82f6\\\">;\\n      fontFace: Default<string, \\\"system-ui, -apple-system, sans-serif\\\">;\\n      borderRadius: Default<string, \\\"0.5rem\\\">;\\n    };\\n    isInitialized: Cell<boolean>;\\n  }>(),\\n  undefined,\\n  ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\\n    if (!isInitialized.get()) {\\n      console.log(\\n        \\\"storeCharm storing charm:\\\",\\n        charm,\\n      );\\n      selectedCharm.set({ charm });\\n\\n      // create the chat charm with a custom name including a random suffix\\n      const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\\n      charmsList.push({ [ID]: randomId, local_id: randomId, charm });\\n\\n      isInitialized.set(true);\\n      return charm;\\n    } else {\\n      console.log(\\\"storeCharm: already initialized\\\");\\n    }\\n    return undefined;\\n  },\\n);\\n\\nconst populateChatList = lift(\\n  toSchema<{\\n    charmsList: CharmEntry[];\\n    allCharms: Cell<any[]>;\\n    selectedCharm: Cell<{ charm: any }>;\\n  }>(),\\n  undefined,\\n  (\\n    { charmsList, allCharms, selectedCharm },\\n  ) => {\\n    if (charmsList.length === 0) {\\n      const isInitialized = cell(false);\\n      return storeCharm({\\n        charm: Chat({\\n          title: \\\"New Chat\\\",\\n          messages: [],\\n        }),\\n        selectedCharm,\\n        charmsList,\\n        allCharms,\\n        isInitialized: isInitialized as unknown as Cell<boolean>,\\n      });\\n    }\\n\\n    return charmsList;\\n  },\\n);\\n\\nconst createChatRecipe = handler<\\n  unknown,\\n  {\\n    selectedCharm: Cell<{ charm: any }>;\\n    charmsList: Cell<CharmEntry[]>;\\n    allCharms: Cell<MentionableCharm[]>;\\n  }\\n>(\\n  (_, { selectedCharm, charmsList, allCharms }) => {\\n    const isInitialized = cell(false);\\n\\n    const charm = Chat({\\n      title: \\\"New Chat\\\",\\n      messages: [],\\n    });\\n    // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\\n    return storeCharm({\\n      charm,\\n      selectedCharm,\\n      charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\\n      allCharms,\\n      isInitialized: isInitialized as unknown as Cell<boolean>,\\n    });\\n  },\\n);\\n\\nconst selectCharm = handler<\\n  unknown,\\n  { selectedCharm: Cell<{ charm: any }>; charm: any }\\n>(\\n  (_, { selectedCharm, charm }) => {\\n    console.log(\\\"selectCharm: updating selectedCharm to \\\", charm);\\n    selectedCharm.set({ charm });\\n    return selectedCharm;\\n  },\\n);\\n\\nconst logCharmsList = lift<\\n  { charmsList: Cell<CharmEntry[]> },\\n  Cell<CharmEntry[]>\\n>(\\n  ({ charmsList }) => {\\n    console.log(\\\"logCharmsList: \\\", charmsList.get());\\n    return charmsList;\\n  },\\n);\\n\\nconst _handleCharmLinkClicked = handler(\\n  (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\\n    return navigateTo(charm);\\n  },\\n);\\n\\nconst _merge = lift(\\n  (\\n    { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\\n  ) => {\\n    return [...charmsList.map((c) => c.charm), ...allCharms];\\n  },\\n);\\n\\nconst getSelectedCharm = lift<\\n  { entry: { charm: any | undefined } },\\n  {\\n    chat: unknown;\\n    list: ListItem[];\\n  } | undefined\\n>(\\n  ({ entry }) => {\\n    return entry?.charm;\\n  },\\n);\\n\\nconst getCharmName = lift(({ charm }: { charm: any }) => {\\n  return charm?.[NAME] || \\\"Unknown\\\";\\n});\\n\\nconst extractLocalMentionable = lift<\\n  { list: CharmEntry[] },\\n  MentionableCharm[]\\n>(({ list }) => {\\n  const out: MentionableCharm[] = [];\\n  for (const entry of list) {\\n    const c = entry.charm;\\n    out.push(c.chat);\\n  }\\n  return out;\\n});\\n\\n// create the named cell inside the recipe body, so we do it just once\\nexport default recipe<Input, Output>(\\n  \\\"Launcher\\\",\\n  ({ selectedCharm, charmsList, theme }) => {\\n    const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\\n      wish<MentionableCharm[]>(\\\"#allCharms\\\", []),\\n      (c) => c,\\n    );\\n    logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\\n\\n    populateChatList({\\n      selectedCharm: selectedCharm as unknown as Cell<\\n        Pick<CharmEntry, \\\"charm\\\">\\n      >,\\n      charmsList,\\n      allCharms,\\n    });\\n\\n    const selected = getSelectedCharm({ entry: selectedCharm });\\n\\n    // Aggregate mentionables from the local charms list so that this\\n    // container exposes its child chat charms as mention targets.\\n    const localMentionable = extractLocalMentionable({ list: charmsList });\\n\\n    const localTheme = theme ?? {\\n      accentColor: cell(\\\"#3b82f6\\\"),\\n      fontFace: cell(\\\"system-ui, -apple-system, sans-serif\\\"),\\n      borderRadius: cell(\\\"0.5rem\\\"),\\n    };\\n\\n    return {\\n      [NAME]: \\\"Launcher\\\",\\n      [UI]: (\\n        <ct-theme theme={localTheme as any}>\\n          <ct-screen>\\n            <div slot=\\\"header\\\">\\n              <ct-toolbar dense sticky>\\n                <div slot=\\\"start\\\">\\n                  <ct-button\\n                    id=\\\"new-chat-btn\\\"\\n                    onClick={createChatRecipe({\\n                      selectedCharm,\\n                      charmsList,\\n                      allCharms,\\n                    })}\\n                  >\\n                    Create New Chat\\n                    <ct-kbd>alt+N</ct-kbd>\\n                  </ct-button>\\n                </div>\\n              </ct-toolbar>\\n\\n              {/* Keyboard shortcuts */}\\n              <ct-keybind\\n                code=\\\"KeyN\\\"\\n                alt\\n                preventDefault\\n                onct-keybind={createChatRecipe({\\n                  selectedCharm,\\n                  charmsList,\\n                  allCharms,\\n                })}\\n              />\\n            </div>\\n            <ct-autolayout\\n              leftOpen\\n              rightOpen={false}\\n            >\\n              {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\\n              {/* this should be fixed after the builder-refactor (DX1) */}\\n              <ct-screen>\\n                <ct-render $cell={selected.chat} />\\n              </ct-screen>\\n\\n              <aside slot=\\\"left\\\">\\n                <div>\\n                  <ct-heading level={3}>Chat List</ct-heading>\\n                </div>\\n                <div role=\\\"list\\\">\\n                  {charmsList.map((charmEntry) => (\\n                    <ct-list-item\\n                      onct-activate={selectCharm({\\n                        selectedCharm,\\n                        charm: charmEntry.charm,\\n                      })}\\n                    >\\n                      <span>{getCharmName({ charm: charmEntry.charm })}</span>\\n                      <span slot=\\\"meta\\\">{charmEntry.local_id}</span>\\n                      <ct-button\\n                        slot=\\\"actions\\\"\\n                        size=\\\"sm\\\"\\n                        title=\\\"Delete Chat\\\"\\n                        variant=\\\"destructive\\\"\\n                        onClick={removeChat({\\n                          charmsList: charmsList as unknown as OpaqueRef<\\n                            CharmEntry[]\\n                          >,\\n                          id: charmEntry.local_id,\\n                          selectedCharm: selectedCharm as unknown as OpaqueRef<\\n                            Default<{ charm: any }, { charm: undefined }>\\n                          >,\\n                        })}\\n                      >\\n                        🗑️\\n                      </ct-button>\\n                    </ct-list-item>\\n                  ))}\\n                </div>\\n              </aside>\\n\\n              <aside slot=\\\"right\\\">\\n                {ifElse(\\n                  selected,\\n                  <>\\n                    <ct-ct-collapsible>\\n                      <ct-heading slot=\\\"trigger\\\" level={5} no-margin>\\n                        List\\n                      </ct-heading>\\n                      <ct-list $value={selected.list} />\\n                    </ct-ct-collapsible>\\n                  </>,\\n                  null,\\n                )}\\n                <ct-collapsible>\\n                  <ct-heading slot=\\\"trigger\\\" level={5} no-margin>\\n                    Theme\\n                  </ct-heading>\\n                  <ct-vstack style=\\\"padding: 0.5rem 0; gap: 0.5rem;\\\">\\n                    <ct-vstack>\\n                      <ct-text>Font Family</ct-text>\\n                      <ct-select\\n                        items={[\\n                          {\\n                            label: \\\"System\\\",\\n                            value: \\\"system-ui, -apple-system, sans-serif\\\",\\n                          },\\n                          {\\n                            label: \\\"Monospace\\\",\\n                            value: \\\"ui-monospace, Consolas, monospace\\\",\\n                          },\\n                          {\\n                            label: \\\"Serif\\\",\\n                            value: \\\"Georgia, Times, serif\\\",\\n                          },\\n                          {\\n                            label: \\\"Sans Serif\\\",\\n                            value: \\\"Arial, Helvetica, sans-serif\\\",\\n                          },\\n                        ]}\\n                        $value={localTheme.fontFace}\\n                      />\\n                    </ct-vstack>\\n\\n                    <ct-vstack>\\n                      <ct-text>Accent Color</ct-text>\\n                      <ct-select\\n                        items={[\\n                          { label: \\\"Blue\\\", value: \\\"#3b82f6\\\" },\\n                          { label: \\\"Purple\\\", value: \\\"#8b5cf6\\\" },\\n                          { label: \\\"Green\\\", value: \\\"#10b981\\\" },\\n                          { label: \\\"Red\\\", value: \\\"#ef4444\\\" },\\n                          { label: \\\"Orange\\\", value: \\\"#f97316\\\" },\\n                          { label: \\\"Pink\\\", value: \\\"#ec4899\\\" },\\n                          { label: \\\"Indigo\\\", value: \\\"#6366f1\\\" },\\n                          { label: \\\"Teal\\\", value: \\\"#14b8a6\\\" },\\n                        ]}\\n                        $value={localTheme.accentColor}\\n                      />\\n                    </ct-vstack>\\n\\n                    <ct-vstack>\\n                      <ct-text>Border Radius</ct-text>\\n                      <ct-select\\n                        items={[\\n                          { label: \\\"None\\\", value: \\\"0px\\\" },\\n                          { label: \\\"Small\\\", value: \\\"0.25rem\\\" },\\n                          { label: \\\"Medium\\\", value: \\\"0.5rem\\\" },\\n                          { label: \\\"Large\\\", value: \\\"0.75rem\\\" },\\n                          { label: \\\"Extra Large\\\", value: \\\"1rem\\\" },\\n                          { label: \\\"Rounded\\\", value: \\\"1.5rem\\\" },\\n                        ]}\\n                        $value={localTheme.borderRadius}\\n                      />\\n                    </ct-vstack>\\n                  </ct-vstack>\\n                </ct-collapsible>\\n              </aside>\\n            </ct-autolayout>\\n          </ct-screen>\\n        </ct-theme>\\n      ),\\n      selectedCharm,\\n      charmsList,\\n      // Expose the aggregated mentionables for parent-level indexing.\\n      mentionable: localMentionable,\\n    };\\n  },\\n);\\n\"},{\"name\":\"/omnibox-fab.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  Cell,\\n  cell,\\n  derive,\\n  handler,\\n  ifElse,\\n  NAME,\\n  recipe,\\n  UI,\\n} from \\\"commontools\\\";\\nimport Chatbot from \\\"./chatbot.tsx\\\";\\nimport { calculator, readWebpage, searchWeb } from \\\"./common-tools.tsx\\\";\\nimport { MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\n\\ninterface OmniboxFABInput {\\n  mentionable: Cell<MentionableCharm[]>;\\n}\\n\\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\\n  value.set(!value.get());\\n});\\n\\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\\n  (_, { fabExpanded }) => {\\n    fabExpanded.set(false);\\n  },\\n);\\n\\nconst dismissPeek = handler<\\n  any,\\n  { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\\n  // Store the current assistant message count so we know which message was dismissed\\n  peekDismissedIndex.set(assistantMessageCount);\\n});\\n\\nexport default recipe<OmniboxFABInput>(\\n  \\\"OmniboxFAB\\\",\\n  ({ mentionable: _mentionable }) => {\\n    const omnibot = Chatbot({\\n      messages: [],\\n      tools: {\\n        searchWeb: {\\n          pattern: searchWeb,\\n        },\\n        readWebpage: {\\n          pattern: readWebpage,\\n        },\\n        calculator: {\\n          pattern: calculator,\\n        },\\n      },\\n    });\\n\\n    const fabExpanded = cell(false);\\n    const showHistory = cell(false);\\n    const peekDismissedIndex = cell(-1); // Track which message index was dismissed\\n\\n    // Derive assistant message count for dismiss tracking\\n    const assistantMessageCount = derive(\\n      omnibot.messages,\\n      (messages) => messages.filter((m) => m.role === \\\"assistant\\\").length,\\n    );\\n\\n    // Derive latest assistant message for peek\\n    const latestAssistantMessage = derive(omnibot.messages, (messages) => {\\n      if (!messages || messages.length === 0) return null;\\n\\n      for (let i = messages.length - 1; i >= 0; i--) {\\n        const msg = messages[i];\\n        if (msg.role === \\\"assistant\\\") {\\n          const content = typeof msg.content === \\\"string\\\"\\n            ? msg.content\\n            : msg.content.map((part: any) => {\\n              if (part.type === \\\"text\\\") return part.text;\\n              return \\\"\\\";\\n            }).join(\\\"\\\");\\n\\n          return content;\\n        }\\n      }\\n      return null;\\n    });\\n\\n    return {\\n      [NAME]: \\\"OmniboxFAB\\\",\\n      messages: omnibot.messages,\\n      [UI]: (\\n        <ct-fab\\n          expanded={fabExpanded}\\n          variant=\\\"primary\\\"\\n          position=\\\"bottom-right\\\"\\n          pending={omnibot.pending}\\n          $previewMessage={latestAssistantMessage}\\n          onct-fab-backdrop-click={closeFab({ fabExpanded })}\\n          onct-fab-escape={closeFab({ fabExpanded })}\\n          onClick={toggle({ value: fabExpanded })}\\n        >\\n          <div style=\\\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\\\">\\n            {/* Chevron at top - the \\\"handle\\\" for the drawer */}\\n            <div style=\\\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\\\">\\n              <ct-chevron-button\\n                expanded={showHistory}\\n                loading={omnibot.pending}\\n                onct-toggle={toggle({ value: showHistory })}\\n              />\\n            </div>\\n\\n            <div\\n              style={derive(\\n                showHistory,\\n                (show) =>\\n                  `flex: ${\\n                    show ? \\\"1\\\" : \\\"0\\\"\\n                  }; min-height: 0; display: flex; flex-direction: column; opacity: ${\\n                    show ? \\\"1\\\" : \\\"0\\\"\\n                  }; max-height: ${\\n                    show ? \\\"480px\\\" : \\\"0\\\"\\n                  }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\\n                    show ? \\\"auto\\\" : \\\"none\\\"\\n                  };`,\\n              )}\\n            >\\n              <div style=\\\"padding: .25rem; flex-shrink: 0;\\\">\\n                {omnibot.ui.attachmentsAndTools}\\n              </div>\\n              <div style=\\\"flex: 1; overflow-y: auto; min-height: 0;\\\">\\n                {omnibot.ui.chatLog}\\n              </div>\\n            </div>\\n\\n            {ifElse(\\n              derive(\\n                [\\n                  showHistory,\\n                  latestAssistantMessage,\\n                  peekDismissedIndex,\\n                  assistantMessageCount,\\n                ],\\n                ([show, msg, dismissedIdx, count]) =>\\n                  !show && msg && count !== dismissedIdx,\\n              ),\\n              <div style=\\\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\\\">\\n                <ct-button\\n                  variant=\\\"ghost\\\"\\n                  size=\\\"icon\\\"\\n                  onClick={dismissPeek({\\n                    peekDismissedIndex,\\n                    assistantMessageCount,\\n                  })}\\n                  style=\\\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\\\"\\n                  title=\\\"Dismiss\\\"\\n                >\\n                  ×\\n                </ct-button>\\n                <div\\n                  onClick={toggle({ value: showHistory })}\\n                  style=\\\"cursor: pointer;\\\"\\n                >\\n                  <ct-chat-message\\n                    role=\\\"assistant\\\"\\n                    compact\\n                    content={latestAssistantMessage}\\n                    pending={omnibot.pending}\\n                  />\\n                </div>\\n              </div>,\\n              null,\\n            )}\\n\\n            {/* Prompt input - always at bottom */}\\n            <div style=\\\"padding: 0.5rem; flex-shrink: 0;\\\">\\n              {omnibot.ui.promptInput}\\n            </div>\\n          </div>\\n        </ct-fab>\\n      ),\\n      fabExpanded,\\n    };\\n  },\\n);\\n\"},{\"name\":\"/chatbot-note-composed.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  BuiltInLLMMessage,\\n  Cell,\\n  cell,\\n  Default,\\n  derive,\\n  handler,\\n  NAME,\\n  navigateTo,\\n  Opaque,\\n  OpaqueRef,\\n  recipe,\\n  wish,\\n} from \\\"commontools\\\";\\n\\nimport Chat from \\\"./chatbot.tsx\\\";\\nimport Note from \\\"./note.tsx\\\";\\nimport {\\n  addListItem,\\n  calculator,\\n  ListItem,\\n  readListItems,\\n  readWebpage,\\n  searchWeb,\\n} from \\\"./common-tools.tsx\\\";\\n\\nimport { type MentionableCharm } from \\\"./backlinks-index.tsx\\\";\\n\\nfunction schemaifyWish<T>(path: string, def: Opaque<T>) {\\n  return derive<T, T>(wish<T>(path, def), (i) => i);\\n}\\n\\ntype ChatbotNoteInput = {\\n  title: Default<string, \\\"LLM Test\\\">;\\n  messages: Default<Array<BuiltInLLMMessage>, []>;\\n};\\n\\ntype ChatbotNoteResult = {\\n  messages: Default<Array<BuiltInLLMMessage>, []>;\\n  chat: any;\\n  list: Default<ListItem[], []>;\\n  // Optional: expose sub-charms as mentionable targets\\n  mentionable?: MentionableCharm[];\\n};\\n\\nconst newNote = handler<\\n  {\\n    /** The text content of the note */\\n    title: string;\\n    content?: string;\\n    /** A cell to store the result message indicating success or error */\\n    result: Cell<string>;\\n  },\\n  { allCharms: Cell<MentionableCharm[]>; index: any }\\n>(\\n  (args, _) => {\\n    try {\\n      const n = Note({\\n        title: args.title,\\n        content: args.content || \\\"\\\",\\n      });\\n\\n      args.result.set(\\n        `Created note ${args.title}!`,\\n      );\\n\\n      // TODO(bf): we have to navigate here until DX1 lands\\n      // then we go back to pushing to allCharms\\n      return navigateTo(n);\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\nconst listMentionable = handler<\\n  {\\n    /** A cell to store the result text */\\n    result: Cell<string>;\\n  },\\n  { mentionable: MentionableCharm[] }\\n>(\\n  (args, state) => {\\n    try {\\n      const namesList = state.mentionable.map((charm) => charm[NAME]);\\n      args.result.set(JSON.stringify(namesList));\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\nconst readContentByIndex = handler<\\n  {\\n    /** A cell to store the result text */\\n    index: number;\\n    result: Cell<string>;\\n  },\\n  { allNotes: Note[] }\\n>(\\n  (args, state) => {\\n    try {\\n      args.result.set(\\n        state.allNotes[args.index]?.content || \\\"No content found\\\",\\n      );\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\ntype Note = MentionableCharm & { content: string };\\nconst editContentByIndex = handler<\\n  {\\n    /** The index of the note to edit */\\n    index: number;\\n    /** The new text content of the note */\\n    body: string;\\n    /** A cell to store the result message indicating success or error */\\n    result: Cell<string>;\\n  },\\n  { allNotes: Cell<Note[]> }\\n>(\\n  (args, state) => {\\n    try {\\n      const charms = state.allNotes.get();\\n      if (args.index < 0 || args.index >= charms.length) {\\n        args.result.set(`Error: Invalid index ${args.index}`);\\n        return;\\n      }\\n\\n      state.allNotes.key(args.index).key(\\\"content\\\").set(args.body);\\n      args.result.set(`Updated note at index ${args.index}!`);\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\nconst navigateToNote = handler<\\n  {\\n    /** The index of the note to navigate to */\\n    index: number;\\n    /** A cell to store the result message indicating success or error */\\n    result: Cell<string>;\\n  },\\n  { allCharms: Cell<MentionableCharm[]> }\\n>(\\n  (args, state) => {\\n    try {\\n      const charms = state.allCharms.get();\\n      if (args.index < 0 || args.index >= charms.length) {\\n        args.result.set(`Error: Invalid index ${args.index}`);\\n        return;\\n      }\\n\\n      const targetCharm = charms[args.index];\\n      args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\\n\\n      return navigateTo(state.allCharms.key(args.index));\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\ntype BacklinksIndex = {\\n  mentionable: MentionableCharm[];\\n};\\n\\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\\n  \\\"Chatbot + Note\\\",\\n  ({ title, messages }) => {\\n    const allCharms = schemaifyWish<MentionableCharm[]>(\\\"#allCharms\\\", []);\\n    const index = schemaifyWish<BacklinksIndex>(\\\"#default/backlinksIndex\\\", {\\n      mentionable: [],\\n    });\\n    const mentionable = schemaifyWish<MentionableCharm[]>(\\n      \\\"#mentionable\\\",\\n      [],\\n    );\\n\\n    const list = cell<ListItem[]>([]);\\n\\n    const tools = {\\n      searchWeb: {\\n        pattern: searchWeb,\\n      },\\n      readWebpage: {\\n        pattern: readWebpage,\\n      },\\n      calculator: {\\n        pattern: calculator,\\n      },\\n      addListItem: {\\n        handler: addListItem({ list }),\\n      },\\n      readListItems: {\\n        handler: readListItems({ list }),\\n      },\\n      listMentionable: {\\n        description:\\n          \\\"List all mentionable items titles (read the body with readNoteByIndex).\\\",\\n        handler: listMentionable({ mentionable }),\\n      },\\n      readContentByIndex: {\\n        description:\\n          \\\"Read the content of a mentionable by its index in the listMentionable() list (if possible)\\\",\\n        handler: readContentByIndex({\\n          allNotes: mentionable as unknown as OpaqueRef<Note[]>,\\n        }),\\n      },\\n      editContentByIndex: {\\n        description:\\n          \\\"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\\\",\\n        handler: editContentByIndex({\\n          allNotes: mentionable as unknown as OpaqueRef<Note[]>,\\n        }),\\n      },\\n      navigateToNote: {\\n        description:\\n          \\\"Navigate to a mentionable by its index in the listMentionable() list.\\\",\\n        handler: navigateToNote({\\n          allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\\n        }),\\n      },\\n      newNote: {\\n        description: \\\"Create a new note instance\\\",\\n        handler: newNote({\\n          allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\\n          index: index as unknown as OpaqueRef<any>,\\n        }),\\n      },\\n    };\\n\\n    const chat = Chat({ messages, tools });\\n\\n    return {\\n      [NAME]: title,\\n      chat,\\n      messages,\\n      list,\\n      // Expose sub-charms as mentionable targets\\n      mentionable: [chat as unknown as MentionableCharm],\\n    };\\n  },\\n);\\n\"},{\"name\":\"/common-tools.tsx\",\"contents\":\"/// <cts-enable />\\nimport {\\n  BuiltInLLMTool,\\n  Cell,\\n  derive,\\n  fetchData,\\n  handler,\\n  ifElse,\\n  recipe,\\n} from \\\"commontools\\\";\\n\\n///// COMMON TOOLS (get it?) ////\\n\\n/**\\n * Calculate the result of a mathematical expression.\\n * Supports +, -, *, /, and parentheses.\\n */\\ntype CalculatorRequest = {\\n  /** The mathematical expression to evaluate. */\\n  expression: string;\\n  /** The base to use for the calculation. */\\n  base?: number;\\n};\\n\\nexport const calculator = recipe<\\n  CalculatorRequest,\\n  string | { error: string }\\n>(\\\"Calculator\\\", ({ expression, base }) => {\\n  return derive({ expression, base }, ({ expression, base }) => {\\n    const sanitized = expression.replace(/[^0-9+\\\\-*/().\\\\s]/g, \\\"\\\");\\n    let sanitizedBase = Number(base);\\n    if (\\n      Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\\n    ) {\\n      sanitizedBase = 10;\\n    }\\n    let result;\\n    try {\\n      result = Function(\\n        `\\\"use strict\\\"; return Number(${sanitized}).toString(${sanitizedBase})`,\\n      )();\\n    } catch (error) {\\n      result = { error: (error as any)?.message || \\\"<error>\\\" };\\n    }\\n    return result;\\n  });\\n});\\n\\n/** Add an item to the list. */\\ntype AddListItemRequest = {\\n  /** The item to add to the list. */\\n  item: string;\\n  result: Cell<string>;\\n};\\n\\n/** Read all items from the list. */\\ntype ReadListItemsRequest = {\\n  result: Cell<string>;\\n};\\n\\nexport type ListItem = {\\n  title: string;\\n};\\n\\nexport const addListItem = handler<\\n  AddListItemRequest,\\n  { list: Cell<ListItem[]> }\\n>(\\n  (args, state) => {\\n    try {\\n      state.list.push({ title: args.item });\\n      args.result.set(`${state.list.get().length} items`);\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\nexport const readListItems = handler<\\n  ReadListItemsRequest,\\n  { list: ListItem[] }\\n>(\\n  (args, state) => {\\n    try {\\n      const items = state.list;\\n      if (items.length === 0) {\\n        args.result.set(\\\"The list is empty\\\");\\n      } else {\\n        const itemList = items.map((item, index) =>\\n          `${index + 1}. ${item.title}`\\n        ).join(\\\"\\\\n\\\");\\n        args.result.set(`List items (${items.length} total):\\\\n${itemList}`);\\n      }\\n    } catch (error) {\\n      args.result.set(`Error: ${(error as any)?.message || \\\"<error>\\\"}`);\\n    }\\n  },\\n);\\n\\n/** Search the web for information. */\\ntype SearchQuery = {\\n  /** The query to search the web for. */\\n  query: string;\\n};\\n\\ntype SearchWebResult = {\\n  results: {\\n    title: string;\\n    url: string;\\n    description: string;\\n  }[];\\n};\\n\\nexport const searchWeb = recipe<\\n  SearchQuery,\\n  SearchWebResult | { error: string }\\n>(\\\"Search Web\\\", ({ query }) => {\\n  const { result, error } = fetchData<SearchWebResult>({\\n    url: \\\"/api/agent-tools/web-search\\\",\\n    mode: \\\"json\\\",\\n    options: {\\n      method: \\\"POST\\\",\\n      headers: {\\n        \\\"Content-Type\\\": \\\"application/json\\\",\\n      },\\n      body: {\\n        query,\\n        max_results: 5,\\n      },\\n    },\\n  });\\n\\n  // TODO(seefeld): Should we instead return { result, error }? Or allocate a\\n  // special [ERROR] for errors? Ideally this isn't specific to using recipes as\\n  // tools but a general pattern.\\n  return ifElse(error, { error }, result);\\n});\\n\\n/** Read and extract content from a specific webpage URL. */\\ntype ReadWebRequest = {\\n  /** The URL of the webpage to read and extract content from. */\\n  url: string;\\n};\\n\\ntype ReadWebResult = {\\n  content: string;\\n  metadata: {\\n    title?: string;\\n    author?: string;\\n    date?: string;\\n    word_count: number;\\n  };\\n};\\n\\nexport const readWebpage = recipe<\\n  ReadWebRequest,\\n  ReadWebResult | { error: string }\\n>(\\\"Read Webpage\\\", ({ url }) => {\\n  const { result, error } = fetchData<ReadWebResult>({\\n    url: \\\"/api/agent-tools/web-read\\\",\\n    mode: \\\"json\\\",\\n    options: {\\n      method: \\\"POST\\\",\\n      headers: {\\n        \\\"Content-Type\\\": \\\"application/json\\\",\\n      },\\n      body: {\\n        url,\\n        max_tokens: 4000,\\n        include_code: true,\\n      },\\n    },\\n  });\\n\\n  return ifElse(error, { error }, result);\\n});\\n\\ntype ToolsInput = {\\n  list: ListItem[];\\n};\\n\\nexport default recipe<ToolsInput>(\\\"Tools\\\", ({ list }) => {\\n  const tools: Record<string, BuiltInLLMTool> = {\\n    search_web: {\\n      pattern: searchWeb,\\n    },\\n    read_webpage: {\\n      pattern: readWebpage,\\n    },\\n    calculator: {\\n      pattern: calculator,\\n    },\\n    addListItem: {\\n      handler: addListItem({ list }),\\n    },\\n  };\\n\\n  return { tools, list };\\n});\\n\"}]}}",
                                                            "__#0": {
                                                                "/": {
                                                                    "link@1": {
                                                                        "path": [
                                                                            "internal",
                                                                            "mentionable"
                                                                        ],
                                                                        "id": "of:baedreiebukh75cklqudutddiatk45ptx3dh4dau5le6crg5vgotgaos3oe",
                                                                        "space": "did:key:z6MktCfWXiNSojxgbSUAFTTseYnroLjmKouE1mwQQ6peVz2f"
                                                                    }
                                                                }
                                                            },
                                                            "__#3": {
                                                                "/": {
                                                                    "link@1": {
                                                                        "path": [],
                                                                        "id": "of:baedreief5sqwzadk6n7xcq7biov6yywjfs2cacmawgf7axfjntzzsyaetu",
                                                                        "space": "did:key:z6MktCfWXiNSojxgbSUAFTTseYnroLjmKouE1mwQQ6peVz2f"
                                                                    }
                                                                }
                                                            }
                                                        },
                                                        "spell": {
                                                            "/": {
                                                                "link@1": {
                                                                    "id": "of:baedreifi7y4fcxjecm2zbrfw5todn6gjb6ygxlay55wzvc3mt6kmm4u5ue"
                                                                }
                                                            }
                                                        },
                                                        "argument": {
                                                            "title": "New Notek",
                                                            "content": "12345"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "iss": "did:key:z6MktCfWXiNSojxgbSUAFTTseYnroLjmKouE1mwQQ6peVz2f",
                            "prf": [],
                            "iat": 1761786010,
                            "exp": 1761789610
                        }
                    }
                }
            }
        }
    }
}