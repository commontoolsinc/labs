import { isAlias, isStreamAlias } from "@commontools/builder";
import { getTopFrame, type JSONSchema } from "@commontools/builder";
import { getDoc, isDoc, isDocLink, type DocImpl, type DocLink, type DeepKeyLookup } from "./doc.js";
import {
  type QueryResult,
  createQueryResultProxy,
  getDocLinkOrValue,
} from "./query-result-proxy.js";
import { followAliases, followLinks } from "./utils.js";
import { queueEvent, subscribe, type ReactivityLog } from "./scheduler.js";
import { type EntityId, getEntityId } from "./cell-map.js";
import { type Cancel } from "./cancel.js";
import { validateAndTransform } from "./schema.js";

/**
 * This is the regular Cell interface, generated by DocImpl.asCell().
 *
 * This abstracts away the paths behind an interface that e.g. the UX code or
 * modules that prefer cell interfaces can use.
 *
 * @method get Returns the current value of the cell.
 * @returns {T}
 *
 * @method set Alias for `send`. Sets a new value for the cell.
 * @method send Sets a new value for the cell.
 * @param {T} value - The new value to set.
 * @returns {void}
 *
 * @method key Returns a new cell for the specified key path.
 * @param {K} valueKey - The key to access in the cell's value.
 * @returns {Cell<T[K]>}
 *
 * @method sink Adds a callback that is called immediately and on cell changes.
 * @param {function} callback - The callback to be called when the cell changes.
 * @returns {function} - A function to Cleanup the callback.
 *
 * @method updates Adds a callback that is called on cell changes.
 * @param {function} callback - The callback to be called when the cell changes.
 * @returns {function} - A function to Cleanup the callback.
 *
 * @method getAsProxy Returns a value proxy for the cell.
 * @param {Path} path - The path to follow.
 * @returns {QueryResult<DeepKeyLookup<T, Path>>}
 *
 * @method getAsCellReference Returns a cell reference for the cell.
 * @returns {DocLink}
 *
 * @method toJSON Returns a JSON pointer to the cell (not the contents!).
 * @returns {{"/": string}}
 *
 * @method value Returns the current value of the cell.
 * @returns {T}
 *
 * @method entityId Returns the current entity ID of the cell.
 * @returns {EntityId | undefined}
 */
export interface Cell<T> {
  get(): T;
  set(value: T): void;
  send(value: T): void;
  update(value: Partial<T>): void;
  push(
    value:
      | (T extends Array<infer U> ? U : any)
      | DocImpl<T extends Array<infer U> ? U : any>
      | DocLink,
  ): void;
  sink(callback: (value: T) => void): () => void;
  updates(callback: (value: T) => void): () => void;
  key<K extends keyof T>(valueKey: K): Cell<T[K]>;
  asSchema(schema: JSONSchema): Cell<T>;
  getAsQueryResult<Path extends PropertyKey[]>(
    path?: Path,
    log?: ReactivityLog,
  ): QueryResult<DeepKeyLookup<T, Path>>;
  getAsDocLink(): DocLink;
  toJSON(): { "/": string } | undefined;
  value: T;
  docLink: DocLink;
  entityId: EntityId | undefined;
  [isCellMarker]: true;
  copyTrap: boolean;
  schema?: JSONSchema;
}

export function createCell<T>(
  doc: DocImpl<any>,
  path: PropertyKey[] = [],
  log?: ReactivityLog,
  schema?: JSONSchema,
): Cell<T> {
  // Follow aliases, doc links, etc. in path, so that we end up on the right
  // doc, meaning the one that contains the value we want to access without any
  // redirects in between.
  //
  // If the path points to a redirect itself, we don't want to follow it: Other
  // functions will do that. We just want to skip the interim ones.
  //
  // Let's look at a few examples:
  //
  // Doc: { link }, path: [] --> no change
  // Doc: { link }, path: ["foo"] --> follow link, path: ["foo"]
  // Doc: { foo: { link } }, path: ["foo"] --> no change
  // Doc: { foo: { link } }, path: ["foo", "bar"] --> follow link, path: ["bar"]

  let ref: DocLink = { cell: doc, path: [] };
  const seen: DocLink[] = [];

  let keys = [...path];
  while (keys.length) {
    // First follow all the aliases and links, _before_ accessing the key.
    ref = followLinks(ref, seen, log);
    doc = ref.cell;
    path = [...ref.path, ...keys];

    // Now access the key.
    const key = keys.shift()!;
    ref = { cell: doc, path: [...ref.path, key] };
  }

  // Follow aliases on the last key, but no other kinds of links.
  if (isAlias(ref.cell.getAtPath(ref.path))) {
    ref = followAliases(ref.cell.getAtPath(ref.path), ref.cell, log);
    doc = ref.cell;
    path = ref.path;
  }

  // Then follow the other links and see whether this is a stream alias.
  ref = followLinks(ref, seen, log);
  const isStream = isStreamAlias(ref.cell.getAtPath(ref.path));

  if (isStream) return createStreamCell(ref.cell, ref.path);
  else return createRegularCell(doc, path, log, schema);
}

function createStreamCell<T>(doc: DocImpl<any>, path: PropertyKey[]): Cell<T> {
  const listeners = new Set<(event: T) => void>();

  const self: Cell<T> = {
    // Implementing just the subset of Cell<T> that is needed for streams.
    send: (event: T) => {
      queueEvent({ cell: doc, path }, event);
      listeners.forEach((callback) => callback(event));
    },
    sink: (callback: (value: T) => void): Cancel => {
      listeners.add(callback);
      return () => listeners.delete(callback);
    },
    updates: (callback: (value: T) => void): Cancel => self.sink(callback),
  } as Cell<T>;

  return self;
}

function createRegularCell<T>(
  doc: DocImpl<any>,
  path: PropertyKey[],
  log?: ReactivityLog,
  schema?: JSONSchema,
): Cell<T> {
  const self: Cell<T> = {
    get: () => validateAndTransform(doc, path, schema, log),
    set: (newValue: T) => doc.setAtPath(path, newValue, log),
    send: (newValue: T) => self.set(newValue),
    update: (value: Partial<T>) => {
      const previousValue = doc.getAtPath(path);
      if (typeof previousValue !== "object" || previousValue === null)
        throw new Error("Can't update non-object value");
      const newValue = {
        ...previousValue,
        ...value,
      };
      doc.setAtPath(path, newValue, log);
    },
    push: (value: any) => {
      const array = doc.getAtPath(path) ?? [];
      if (!Array.isArray(array)) throw new Error("Can't push into non-array value");

      // Every element pushed to the array should be it's own doc or link to
      // one. So if it isn't already, make it one.
      if (isCell(value)) {
        value = value.getAsDocLink();
      } else if (isDoc(value)) {
        value = { cell: value, path: [] };
      } else {
        value = getDocLinkOrValue(value);
        if (!isDocLink(value)) {
          const cause = {
            parent: doc.entityId,
            path: path,
            length: array.length,
            // Context is the event id in event handlers, making this unique.
            // TODO: In this case it shouldn't depend on the length, maybe
            // instead just call order in the current context.
            context: getTopFrame()?.cause ?? "unknown",
          };

          value = { cell: getDoc<any>(value, cause), path: [] };
        }
      }

      doc.setAtPath(path, [...array, value], log);
    },
    sink: (callback: (value: T) => void) =>
      subscribeToReferencedDocs(doc, path, schema, callback, true),
    updates: (callback: (value: T) => void) =>
      subscribeToReferencedDocs(doc, path, schema, callback, false),
    key: <K extends keyof T>(key: K) => {
      const currentSchema =
        schema?.type === "object"
          ? (schema.properties?.[key as string] ??
            (typeof schema.additionalProperties === "object"
              ? schema.additionalProperties
              : undefined))
          : schema?.type === "array"
            ? schema.items
            : undefined;
      return doc.asCell([...path, key], log, currentSchema) as Cell<T[K]>;
    },
    asSchema: (newSchema: JSONSchema) => createCell(doc, path, log, newSchema),
    getAsQueryResult: (subPath: PropertyKey[] = [], newLog?: ReactivityLog) =>
      createQueryResultProxy(doc, [...path, ...subPath], newLog ?? log),
    getAsDocLink: () => ({ cell: doc, path }) satisfies DocLink,
    toJSON: () => doc.toJSON(),
    get value(): T {
      return self.get();
    },
    get docLink(): DocLink {
      return { cell: doc, path };
    },
    get entityId(): EntityId | undefined {
      return getEntityId(self.getAsDocLink());
    },
    [isCellMarker]: true,
    get copyTrap(): boolean {
      throw new Error("Copy trap: Don't copy renderer cells. Create references instead.");
    },
    schema,
  };

  return self;
}

function subscribeToReferencedDocs<T>(
  doc: DocImpl<any>,
  path: PropertyKey[],
  schema: JSONSchema | undefined,
  callback: (value: T) => void,
  callCallbackOnFirstRun: boolean,
): Cancel {
  const initialLog = { reads: [], writes: [] } satisfies ReactivityLog;

  // Get the value once to determine all the docs that need to be subscribed to.
  const value = validateAndTransform(doc, path, schema, initialLog) as T;

  // Subscribe to the docs that are read (via logs), call callback on next change.
  const cancel = subscribe(
    (log) => callback(validateAndTransform(doc, path, schema, log) as T),
    initialLog,
  );

  // Call the callback once with initial valueif requested.
  if (callCallbackOnFirstRun) callback(value);

  return cancel;
}

/**
 * Check if value is a simple cell.
 *
 * @param {any} value - The value to check.
 * @returns {boolean}
 */
export function isCell(value: any): value is Cell<any> {
  return typeof value === "object" && value !== null && value[isCellMarker] === true;
}

const isCellMarker = Symbol("isCell");
