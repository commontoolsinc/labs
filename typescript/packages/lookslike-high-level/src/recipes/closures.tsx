import { h } from "@commontools/html";
import {
  lift,
  UI,
  compute,
  render,
  NAME,
  cell,
} from "@commontools/builder";
import { z } from "zod";

export const counter = lift<{ count: number }>(state => {
  return {
    [UI]: render(() => (
      <div>
        [
        <button
          onclick={() => {
            console.log("clicked", state.count);
            state.count = state.count + 1;
          }}
        >
          #{`${state.count}`} - {state.count}
        </button>
        ]
      </div>
    )),
  };
});

export default lift(
  z
    .object({ test: z.string().default("Test string") })
    .describe("Closures experiment"),
  z.object({}),
  ({ test }) => {
    // Just test data
    const list = compute(() => [1, 2, 3]);

    // Closure to compute
    const concat = compute(() => "Hello " + test);

    // Closure using something generated by another closure
    const ui = compute(() => <div>{`${concat}`}!</div>);

    // The inner function is a recipe, so this worked before
    const listUI = list.map(item => <li>#{item}</li>);

    // Now let's do a computation closure inside the recipe closure!
    const listUI2 = list.map(item => (
      <li>
        {compute(() => (
          <span>#{item * 2}</span>
        ))}
      </li>
    ));

    const counterUI = counter(cell({ count: 0 }))[UI]; // cell() so that it's mutable

    return {
      [NAME]: `closures with ${test}`,
      [UI]: (
        <div>
          <div>Test string:{ui}</div>
          <div>List 1:</div>
          <ul>{listUI}</ul>
          <div>List 2:</div>
          <ul>{listUI2}</ul>
          <div>Counter:</div>
          <div>{counterUI}</div>
        </div>
      ),
    };
  },
);
