import { h } from "@commontools/common-html";
import { recipe, lift, UI, OpaqueRef } from "@commontools/common-builder";
import { z } from "zod";

const compute: <T>(fn: () => T) => OpaqueRef<T> = (fn: () => any) =>
  lift(fn)(undefined);

export const closures = recipe(
  z
    .object({ test: z.string().default("Test string") })
    .describe("Closures experiment"),
  z.object({}),
  ({ test }) => {
    // Just test data
    const list = compute(() => [1, 2, 3]);

    // Closure to compute

    const concat = compute(() => "Hello " + test);

    // Closure using something generated by another closure
    const ui = compute(() => <div>{`${concat}`}!</div>);

    // The inner function is a recipe, so this worked before
    const listUI = list.map((item) => <li>#{item}</li>);

    // Now let's do a computation closure inside the recipe closure!
    const listUI2 = list.map((item) => (
      <li>
        {compute(() => (
          <span>#{item * 2}</span>
        ))}
      </li>
    ));

    return {
      [UI]: (
        <div>
          <div>Test string:{ui}</div>
          <div>List 1:</div>
          <ul>{listUI}</ul>
          <div>List 2:</div>
          <ul>{listUI2}</ul>
        </div>
      ),
    };
  },
);
