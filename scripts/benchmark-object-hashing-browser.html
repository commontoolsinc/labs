<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object Hashing Benchmark - Browser</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    h1, h2, h3 {
      color: #4ec9b0;
    }
    pre {
      background: #2d2d2d;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    .status {
      color: #ce9178;
    }
    .complete {
      color: #4ec9b0;
    }
    .error {
      color: #f48771;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #404040;
    }
    th {
      background: #2d2d2d;
      color: #4ec9b0;
    }
    tr:hover {
      background: #2d2d2d;
    }
  </style>
</head>
<body>
  <h1>Object Hashing Benchmark - Browser</h1>
  <div id="status" class="status">Loading libraries...</div>
  <div id="output"></div>

  <script type="module">
    const outputDiv = document.getElementById('output');
    const statusDiv = document.getElementById('status');

    function log(message) {
      const pre = document.createElement('pre');
      pre.textContent = message;
      outputDiv.appendChild(pre);
    }

    async function main() {
      try {
        statusDiv.textContent = 'Loading libraries from esm.sh...';

        // Import libraries from esm.sh
        const [
          MerkleReference,
          objectHash,
          hashIt,
          stableStringify,
          { sha256 },
          { createSHA256 }
        ] = await Promise.all([
          import('https://esm.sh/merkle-reference@2.2.0'),
          import('https://esm.sh/object-hash@3.0.0'),
          import('https://esm.sh/hash-it@6.0.0'),
          import('https://esm.sh/fast-json-stable-stringify@2.1.0'),
          import('https://esm.sh/@noble/hashes@1.4.0/sha256'),
          import('https://esm.sh/hash-wasm@4.11.0')
        ]);

        statusDiv.textContent = 'Creating test data...';

        // Test data structures
        const testData = {
          // Small structures
          small: {
            simple: { a: 1, b: 2, c: 3 },
            nested: { a: { b: { c: 1 } } },
            array: [1, 2, 3, 4, 5],
            mixed: { a: [1, 2], b: { c: 3 }, d: "hello" },
          },

          // Large structures
          large: {
            // Wide object (many properties)
            wide: Object.fromEntries(
              Array.from({ length: 1000 }, (_, i) => [`key${i}`, i]),
            ),

            // Deep nesting
            deep: (() => {
              let obj = { value: "bottom" };
              for (let i = 0; i < 100; i++) {
                obj = { nested: obj };
              }
              return obj;
            })(),

            // Large array
            largeArray: Array.from({ length: 1000 }, (_, i) => ({
              id: i,
              name: `item${i}`,
              value: Math.random(),
            })),

            // Sparse array
            sparse: (() => {
              const arr = new Array(1000);
              arr[0] = "first";
              arr[100] = "middle";
              arr[999] = "last";
              return arr;
            })(),

            // Complex nested structure
            complex: {
              users: Array.from({ length: 100 }, (_, i) => ({
                id: i,
                name: `user${i}`,
                profile: {
                  age: 20 + (i % 50),
                  tags: [`tag${i % 10}`, `tag${(i + 1) % 10}`],
                  settings: {
                    theme: i % 2 === 0 ? "dark" : "light",
                    notifications: i % 3 === 0,
                  },
                },
              })),
              metadata: {
                version: "1.0.0",
                timestamp: Date.now(),
                count: 100,
              },
            },
          },
        };

        statusDiv.textContent = 'Creating hash functions...';

        // Create hash functions
        const hashFunctions = {};

        // Noble hashes (default for merkle-reference)
        hashFunctions["noble"] = (data) => sha256(data);

        // hash-wasm
        const hasher = await createSHA256();
        hashFunctions["hash-wasm"] = (data) => {
          hasher.init();
          hasher.update(data);
          return hasher.digest("binary");
        };

        statusDiv.textContent = 'Creating strategies...';

        // Create strategies
        const strategies = {};

        // merkle-reference with different hash functions
        for (const [name, hashFn] of Object.entries(hashFunctions)) {
          const treeBuilder = MerkleReference.Tree.createBuilder(hashFn);
          strategies[`merkle-reference[${name}]`] = (obj) => {
            const ref = treeBuilder.refer(obj);
            return ref.hash.toString();
          };
        }

        // object-hash
        strategies["object-hash"] = (obj) => {
          return objectHash.default(obj);
        };

        // hash-it
        strategies["hash-it"] = (obj) => {
          return hashIt.default(obj).toString();
        };

        // fast-json-stable-stringify + noble sha256
        strategies["stable-stringify+noble"] = (obj) => {
          const str = stableStringify.default(obj);
          const encoder = new TextEncoder();
          const data = encoder.encode(str);
          const hash = sha256(data);
          return Array.from(hash).map((b) => b.toString(16).padStart(2, "0")).join("");
        };

        // JSON.stringify (baseline - NOT stable for property order)
        strategies["JSON.stringify+noble (UNSTABLE)"] = (obj) => {
          const str = JSON.stringify(obj);
          const encoder = new TextEncoder();
          const data = encoder.encode(str);
          const hash = sha256(data);
          return Array.from(hash).map((b) => b.toString(16).padStart(2, "0")).join("");
        };

        // Test stability
        function testStability(strategy) {
          const obj1 = { a: 1, b: 2, c: 3 };
          const obj2 = { c: 3, b: 2, a: 1 };
          const obj3 = { b: 2, a: 1, c: 3 };

          const hash1 = strategy(obj1);
          const hash2 = strategy(obj2);
          const hash3 = strategy(obj3);

          return hash1 === hash2 && hash2 === hash3;
        }

        // Benchmark runner
        async function benchmark(fn, iterations = 1000) {
          // Warmup
          for (let i = 0; i < Math.min(100, iterations / 10); i++) {
            fn();
          }

          // Actual benchmark
          const start = performance.now();
          for (let i = 0; i < iterations; i++) {
            fn();
          }
          const end = performance.now();

          return end - start;
        }

        statusDiv.textContent = 'Running benchmarks...';
        log('=== Object Hashing Benchmark ===\n');
        log('Environment: Browser (Chrome)\n');

        // Test stability
        log('## Stability Test (property order independence)\n');
        for (const [name, strategy] of Object.entries(strategies)) {
          const stable = testStability(strategy);
          log(`${name.padEnd(40)} ${stable ? '✓ STABLE' : '✗ UNSTABLE'}`);
        }
        log('');

        // Benchmark each strategy on each data structure
        const results = {};

        const testCases = [
          { category: "small", name: "simple", data: testData.small.simple, iterations: 10000 },
          { category: "small", name: "nested", data: testData.small.nested, iterations: 10000 },
          { category: "small", name: "array", data: testData.small.array, iterations: 10000 },
          { category: "small", name: "mixed", data: testData.small.mixed, iterations: 10000 },
          { category: "large", name: "wide", data: testData.large.wide, iterations: 1000 },
          { category: "large", name: "deep", data: testData.large.deep, iterations: 1000 },
          { category: "large", name: "largeArray", data: testData.large.largeArray, iterations: 100 },
          { category: "large", name: "sparse", data: testData.large.sparse, iterations: 1000 },
          { category: "large", name: "complex", data: testData.large.complex, iterations: 100 },
        ];

        for (const testCase of testCases) {
          log(`\n## ${testCase.category}/${testCase.name}\n`);
          statusDiv.textContent = `Running: ${testCase.category}/${testCase.name}...`;

          for (const [strategyName, strategy] of Object.entries(strategies)) {
            try {
              const time = await benchmark(
                () => strategy(testCase.data),
                testCase.iterations,
              );
              const opsPerSec = (testCase.iterations / time) * 1000;

              if (!results[strategyName]) {
                results[strategyName] = {};
              }
              results[strategyName][`${testCase.category}/${testCase.name}`] = {
                time,
                opsPerSec,
              };

              log(
                `${strategyName.padEnd(40)} ${time.toFixed(2)}ms (${
                  opsPerSec.toFixed(0)
                } ops/sec)`,
              );
            } catch (err) {
              log(`${strategyName.padEnd(40)} ERROR: ${err.message}`);
            }
          }
        }

        // Summary table
        log('\n\n=== SUMMARY (ops/sec - higher is better) ===\n');

        const strategyNames = Object.keys(strategies);
        const testNames = testCases.map((t) => `${t.category}/${t.name}`);

        // Header
        log(
          'Strategy'.padEnd(40) +
            testNames
              .map((n) => {
                const short = n.split('/')[1].substring(0, 10);
                return short.padEnd(12);
              })
              .join(''),
        );
        log('-'.repeat(40 + testNames.length * 12));

        // Rows
        for (const strategyName of strategyNames) {
          const row = strategyName.padEnd(40);
          const values = testNames.map((testName) => {
            const result = results[strategyName]?.[testName];
            if (!result) return 'N/A'.padEnd(12);
            const opsPerSec = result.opsPerSec;
            if (opsPerSec > 1000000) {
              return `${(opsPerSec / 1000000).toFixed(1)}M`.padEnd(12);
            } else if (opsPerSec > 1000) {
              return `${(opsPerSec / 1000).toFixed(1)}K`.padEnd(12);
            } else {
              return `${opsPerSec.toFixed(0)}`.padEnd(12);
            }
          });
          log(row + values.join(''));
        }

        log('\n=== DONE ===\n');
        statusDiv.className = 'complete';
        statusDiv.textContent = 'Benchmark complete!';

        // Make results available to puppeteer/playwright
        window.benchmarkResults = results;
        window.benchmarkComplete = true;

      } catch (err) {
        statusDiv.className = 'error';
        statusDiv.textContent = `Error: ${err.message}`;
        log(`\nERROR: ${err.message}`);
        log(err.stack);
      }
    }

    main();
  </script>
</body>
</html>
