# CT-807: Demo - User Login with Individual Sessions Pattern via Chat Example

## Issue Summary

This issue aims to demonstrate a pattern for implementing user-specific sessions within CommonTools recipes. The current system shares all state between users visiting the same charm URL, making it impossible to have individual user settings like usernames. This issue proposes a two-tier architecture pattern using a chat application as the demonstration use case.

## Problem Statement

In the current CommonTools framework, when multiple users visit the same charm URL, they all see and interact with the exact same state. Any modification to a field by one user is immediately visible to all other users, as if they all share the same session. This shared state model prevents implementing features that require user-specific data, such as:
- Individual usernames
- Personal settings
- User-specific preferences
- Private form inputs

## Key Terms and Concepts

### Recipe
A `recipe` is a function that defines a reusable component in CommonTools. It takes input state and returns output state with a UI representation. Recipes are defined using the `recipe<Input, Output>()` function (packages/runner/src/builder/recipe.ts:57-124).

### Cell
A `Cell<T>` is the fundamental reactive state primitive in CommonTools (packages/runner/src/cell.ts:51-100). Cells provide methods like:
- `get()`: Returns the current value
- `set(value)`: Updates the value
- `key(path)`: Returns a cell for a nested property

### Handler
A `handler` is a function that processes events and can modify state. Handlers are defined using the `handler<Event, State>()` function and are typically used for onClick events and other interactions.

### navigateTo
The `navigateTo()` function (packages/runner/src/builtins/navigate-to.ts:6-27) is a built-in that triggers navigation to a new charm instance. It takes a recipe instance as input and causes the browser to navigate to that charm's URL.

### Charm
A charm is an instance of a recipe that has been deployed and is accessible via a URL. Each charm maintains its own state, which is currently shared among all visitors.

## Affected Source Code

### Primary Files

1. **recipes/chat-main.tsx** (Lines 1-99)
   - Currently contains a copy of the instantiate-recipe.tsx pattern
   - Will be modified to implement the chat demonstration
   - Contains the Counter recipe (lines 43-61) and Counter Factory (lines 81-98)

2. **packages/patterns/instantiate-recipe.tsx** (Lines 76-79)
   - Shows the pattern of creating new recipe instances
   - Uses `navigateTo(charm)` to navigate to newly created instances
   - Reference implementation for the dynamic instance creation pattern

3. **packages/runner/src/builtins/navigate-to.ts** (Lines 6-27)
   - Core navigation functionality
   - Handles the actual navigation when a new instance is created
   - Uses `runtime.navigateCallback` to trigger browser navigation

### Related Components

4. **packages/runner/src/builder/recipe.ts** (Lines 57-124)
   - Recipe factory creation and management
   - Handles input/output schema definitions
   - Manages the recipe graph construction

5. **packages/runner/src/cell.ts** (Lines 51-100)
   - Cell interface and reactive state management
   - Provides the reactive primitives that enable automatic state synchronization
   - Methods like `get()`, `set()`, and `update()` for state manipulation

## Proposed Architecture

### Data Types

```typescript
type ChatMessage = {
  userId: string;        // Unique identifier for the user
  message: string;       // The chat message content
  timestamp?: number;    // Optional timestamp
};

type SharedState = {
  messages: ChatMessage[];              // Array of all chat messages
  users: Map<string, string>;          // Map of userId to username
};

type LocalUserState = {
  userId: string;       // This user's unique ID
  username: string;     // This user's chosen username
};
```

### Component Structure

#### 1. Main Chat Recipe (Shared State Container)
- **Location**: recipes/chat-main.tsx
- **Purpose**: Holds the shared chat state that all users interact with
- **State**: 
  - `messages`: Array of ChatMessage objects
  - `users`: Map of userId to username
- **UI Elements**:
  - Display of current users and messages
  - "Generate User Session" button
- **Key Functionality**:
  - Creates new user session instances via `navigateTo()`
  - Passes shared state as input to child instances

#### 2. User Session Recipe (Individual Instance)
- **Location**: Can be defined within the same file or separately
- **Purpose**: Provides individual user interface with private state
- **Input**: Receives SharedState from parent
- **Local State**:
  - `userId`: Generated unique identifier
  - `username`: User's chosen name (private to this instance)
- **Key Functionality**:
  - Username input field (local to this instance)
  - Message input and send functionality
  - Updates shared state when:
    - User sets their username (updates users Map)
    - User sends a message (adds to messages array)

## How the Reactive System Enables This Pattern

The CommonTools reactive system automatically propagates state changes across all instances that reference the same underlying state object. This works because:

1. **Shared State Reference**: When the main recipe passes its state to a child recipe via `navigateTo()`, the child receives a reference to the same reactive Cell objects.

2. **Automatic Synchronization**: When the child recipe modifies the shared state (e.g., `state.messages.push(newMessage)`), the reactive system automatically notifies all other instances observing that state.

3. **Individual URLs**: Each call to `navigateTo()` creates a new charm instance with its own URL, allowing for local state that isn't shared.

## Implementation Approach

### Step 1: Define Data Structures
- Create TypeScript interfaces for ChatMessage and SharedState
- Define the schema for recipe inputs and outputs

### Step 2: Implement Main Chat Recipe
1. Initialize shared state with empty messages array and users Map
2. Create UI to display current state
3. Implement "Generate User Session" button handler:
   ```typescript
   const createUserSession = handler((_, state) => {
     const sessionCharm = UserSessionRecipe(state);
     return navigateTo(sessionCharm);
   });
   ```

### Step 3: Implement User Session Recipe
1. Accept SharedState as input
2. Maintain local userId and username state
3. Create UI with:
   - Username input field (local state)
   - Message composition area
   - Chat display (from shared state)
4. Implement handlers for:
   - Setting username (updates both local and shared state)
   - Sending messages (updates shared messages array)

### Step 4: Test Reactive Updates
1. Open multiple browser windows/tabs
2. Create user sessions from the main recipe
3. Verify that:
   - Each session can set its own username
   - Messages from one session appear in all others
   - User list updates across all instances

## Alternative Approaches Considered

1. **URL Parameters**: Passing user identity via URL parameters
   - Limitation: Still shares the same charm instance

2. **Browser Local Storage**: Storing user identity locally
   - Limitation: Doesn't integrate with the reactive system

3. **Server-Side Sessions**: Traditional session management
   - Limitation: Goes against the charm's serverless model

## Success Criteria

1. **Individual Usernames**: Each user can set and maintain their own username without affecting others
2. **Shared Messages**: All messages appear in real-time across all user sessions
3. **User List Synchronization**: The user list updates when new users join
4. **Pattern Clarity**: The implementation clearly demonstrates a reusable pattern for other recipes
5. **No State Conflicts**: Changes to local state (username input) don't affect other users

## Next Steps

1. Implement the basic two-tier architecture
2. Add proper TypeScript types and schemas
3. Implement message sending and display
4. Add user list management
5. Test with multiple concurrent users
6. Document the pattern for reuse in other recipes
7. Consider enhancements like user presence indicators and message persistence