# CT-807: Demo - User Login with Individual Sessions Pattern via Chat Example

## Issue Summary

This issue aims to demonstrate a pattern for implementing user-specific sessions
within CommonTools recipes. The current system shares all state between users
visiting the same charm URL, making it impossible to have individual user
settings like usernames. This issue proposes a two-tier architecture pattern
using a chat application as the demonstration use case.

## Problem Statement

In the current CommonTools framework, when multiple users visit the same charm
URL, they all see and interact with the exact same state. Any modification to a
field by one user is immediately visible to all other users, as if they all
share the same session. This shared state model prevents implementing features
that require user-specific data, such as:

- Individual usernames
- Personal settings
- User-specific preferences
- Private form inputs

## Key Terms and Concepts

### Recipe

A `recipe` is a function that defines a reusable component in CommonTools. It
takes input state and returns output state with a UI representation. Recipes are
defined using the `recipe<Input, Output>()` function
(packages/runner/src/builder/recipe.ts:57-124).

### Cell

A `Cell<T>` is the fundamental reactive state primitive in CommonTools
(packages/runner/src/cell.ts:51-100). Cells provide methods like:

- `get()`: Returns the current value
- `set(value)`: Updates the value
- `key(path)`: Returns a cell for a nested property

### Handler

A `handler` is a function that processes events and can modify state. Handlers
are defined using the `handler<Event, State>()` function and are typically used
for onClick events and other interactions.

### navigateTo

The `navigateTo()` function (packages/runner/src/builtins/navigate-to.ts:6-27)
is a built-in that triggers navigation to a new charm instance. It takes a
recipe instance as input and causes the browser to navigate to that charm's URL.

### Charm

A charm is an instance of a recipe that has been deployed and is accessible via
a URL. Each charm maintains its own state, which is currently shared among all
visitors.

## Affected Source Code

### Primary Files

1. **recipes/chat-main.tsx** (Lines 1-99)
   - Currently contains a copy of the instantiate-recipe.tsx pattern
   - Will be modified to implement the chat demonstration
   - Contains the Counter recipe (lines 43-61) and Counter Factory (lines 81-98)

2. **packages/patterns/instantiate-recipe.tsx** (Lines 76-79)
   - Shows the pattern of creating new recipe instances
   - Uses `navigateTo(charm)` to navigate to newly created instances
   - Reference implementation for the dynamic instance creation pattern

3. **packages/runner/src/builtins/navigate-to.ts** (Lines 6-27)
   - Core navigation functionality
   - Handles the actual navigation when a new instance is created
   - Uses `runtime.navigateCallback` to trigger browser navigation

### Related Components

4. **packages/runner/src/builder/recipe.ts** (Lines 57-124)
   - Recipe factory creation and management
   - Handles input/output schema definitions
   - Manages the recipe graph construction

5. **packages/runner/src/cell.ts** (Lines 51-100)
   - Cell interface and reactive state management
   - Provides the reactive primitives that enable automatic state
     synchronization
   - Methods like `get()`, `set()`, and `update()` for state manipulation

## Proposed Architecture

### Data Types

```typescript
type ChatMessage = {
  userId: string; // Unique identifier for the user
  message: string; // The chat message content
  timestamp?: number; // Optional timestamp
};

type SharedState = {
  messages: ChatMessage[]; // Array of all chat messages
  users: Map<string, string>; // Map of userId to username
};

type LocalUserState = {
  userId: string; // This user's unique ID
  username: string; // This user's chosen username
};
```

### Component Structure

#### 1. Main Chat Recipe (Shared State Container)

- **Location**: recipes/chat-main.tsx
- **Purpose**: Holds the shared chat state that all users interact with
- **State**:
  - `messages`: Array of ChatMessage objects
  - `users`: Map of userId to username
- **UI Elements**:
  - Display of current users and messages
  - "Generate User Session" button
- **Key Functionality**:
  - Creates new user session instances via `navigateTo()`
  - Passes shared state as input to child instances

#### 2. User Session Recipe (Individual Instance)

- **Location**: Can be defined within the same file or separately
- **Purpose**: Provides individual user interface with private state
- **Input**: Receives SharedState from parent
- **Local State**:
  - `userId`: Generated unique identifier
  - `username`: User's chosen name (private to this instance)
- **Key Functionality**:
  - Username input field (local to this instance)
  - Message input and send functionality
  - Updates shared state when:
    - User sets their username (updates users Map)
    - User sends a message (adds to messages array)

## How the Reactive System Enables This Pattern

The CommonTools reactive system automatically propagates state changes across
all instances that reference the same underlying state object. This works
because:

1. **Shared State Reference**: When the main recipe passes its state to a child
   recipe via `navigateTo()`, the child receives a reference to the same
   reactive Cell objects.

2. **Automatic Synchronization**: When the child recipe modifies the shared
   state (e.g., `state.messages.push(newMessage)`), the reactive system
   automatically notifies all other instances observing that state.

3. **Individual URLs**: Each call to `navigateTo()` creates a new charm instance
   with its own URL, allowing for local state that isn't shared.

## Implementation Approach

### Step 1: Define Data Structures

- Create TypeScript interfaces for ChatMessage and SharedState
- Define the schema for recipe inputs and outputs

### Step 2: Implement Main Chat Recipe

1. Initialize shared state with empty messages array and users Map
2. Create UI to display current state
3. Implement "Generate User Session" button handler:
   ```typescript
   const createUserSession = handler((_, state) => {
     const sessionCharm = UserSessionRecipe(state);
     return navigateTo(sessionCharm);
   });
   ```

### Step 3: Implement User Session Recipe

1. Accept SharedState as input
2. Maintain local userId and username state
3. Create UI with:
   - Username input field (local state)
   - Message composition area
   - Chat display (from shared state)
4. Implement handlers for:
   - Setting username (updates both local and shared state)
   - Sending messages (updates shared messages array)

### Step 4: Test Reactive Updates

1. Open multiple browser windows/tabs
2. Create user sessions from the main recipe
3. Verify that:
   - Each session can set its own username
   - Messages from one session appear in all others
   - User list updates across all instances

## Alternative Approaches Considered

1. **URL Parameters**: Passing user identity via URL parameters
   - Limitation: Still shares the same charm instance

2. **Browser Local Storage**: Storing user identity locally
   - Limitation: Doesn't integrate with the reactive system

3. **Server-Side Sessions**: Traditional session management
   - Limitation: Goes against the charm's serverless model

## Success Criteria

1. **Individual Usernames**: Each user can set and maintain their own username
   without affecting others
2. **Shared Messages**: All messages appear in real-time across all user
   sessions
3. **User List Synchronization**: The user list updates when new users join
4. **Pattern Clarity**: The implementation clearly demonstrates a reusable
   pattern for other recipes
5. **No State Conflicts**: Changes to local state (username input) don't affect
   other users

## Next Steps

1. Implement the basic two-tier architecture
2. Add proper TypeScript types and schemas
3. Implement message sending and display
4. Add user list management
5. Test with multiple concurrent users
6. Document the pattern for reuse in other recipes
7. Consider enhancements like user presence indicators and message persistence

## Update (Implementation Notes and Lessons Learned)

- Assumption corrected: Simply passing an array value between recipes does not
  create shared state. Recipes expect OpaqueRefs for inputs; plain arrays in
  handler state are readonly snapshots.

- asCell on schema: Marking `messages` with `asCell: true` in both the main
  recipe input/result schemas ensures the field is a reactive Cell. This allows
  handlers to mutate via `.push()` and recipes to pass references instead of
  snapshots.

- Handler proxy usage: Using `handler(fn, { proxy: true })` for the
  create-session handler is required so the handler receives the original
  OpaqueRefs for state (not readonly values). Without proxy, the state seen
  inside the handler is a readonly shape and cannot be passed to a child recipe
  expecting an OpaqueRef.

- navigateTo pattern: The correct flow is
  `const child = ChildRecipe({ messages: state.messages }); return navigateTo(child);`
  where `state.messages` is the OpaqueRef/Cell stemming from an `asCell` schema.

- UI list rendering: Ensure `.map(...)` returns proper JSX with `key` on list
  items, e.g. `<li key={i}>{msg.message}</li>`, not `li>key=...` text.

- Result schemas: Provide explicit result schemas for both recipes. This helps
  the framework bind cells and names consistently and avoids implicit,
  mismatched shapes.

- Why earlier attempts failed:
  - Passing `Cell<...>` to a recipe input typed as Opaque/Default caused type
    errors; recipe inputs/results operate on OpaqueRefs/JSONSchema, not runtime
    Cell types directly.
  - Non-proxy handlers yielded readonly state, so passing that to a child recipe
    violated expected OpaqueRef types; the proxy option fixes that.

- Debugging cell identity: The public `Cell<T>` interface intentionally hides
  internal identifiers in the public API. While internal cells have
  `entityId`/link metadata, those are not exposed on the public type. For
  debugging, rely on behavior (cross-session updates) and schema wiring
  (`asCell`) rather than logging raw ids.

- Deploy gotchas:
  - Use `deno task ct` to ensure CLI path/version consistency.
  - Provide relative paths to `ct dev --show-transformed` to avoid double-root
    concatenation.
  - Increment `--space` names (e.g., `ellyse09`) to avoid caching when
    validating changes locally.
